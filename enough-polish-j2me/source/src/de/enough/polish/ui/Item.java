//#condition polish.usePolishGui
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2003, 2004 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.ui;

import java.io.IOException;

import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;

//#if polish.android
	import de.enough.polish.android.lcdui.AndroidDisplay;
	import android.view.View;
//#endif
	
//#debug ovidiu
import de.enough.polish.benchmark.Benchmark;

//#if polish.blackberry
	import net.rim.device.api.ui.Field;
//#endif

import de.enough.polish.event.AsynchronousMultipleCommandListener;
import de.enough.polish.event.EventManager;
import de.enough.polish.event.GestureEvent;
import de.enough.polish.event.UiEventListener;
import de.enough.polish.util.ArrayList;
import de.enough.polish.util.Arrays;
import de.enough.polish.util.DeviceControl;
import de.enough.polish.util.DrawUtil;
import de.enough.polish.util.HashMap;
import de.enough.polish.util.RgbImage;


/**
 * A superclass for components that can be added to a Form.
 * 
 * <p>Items support following CSS attributes:
 * </p>
 * <ul>
 * 		<li><b>margin, margin-left, margin-right, margin-top, margin-bottom</b>: margins between border and next item.</li>
 * 		<li><b>padding, padding-left, padding-right, padding-top, padding-bottom, padding-vertical, padding-horizontal</b>: paddings between border and content.</li>
 * 		<li><b>background</b>: The background of this item.</li>
 * 		<li><b>border</b>: The border of this item.</li>
 * 		<li><b>min-width</b>: The minimum width of this item.</li>
 * 		<li><b>max-width</b>: The maximum width of this item.</li>
 * 		<li><b>min-height</b>: The minimum height of this item.</li>
 * 		<li><b>max-height</b>: The maximum height of this item.</li>
 * 		<li><b>before</b>: URL of image that should be placed before this item.</li>
 * 		<li><b>after</b>: URL of image that should be placed after this item.</li>
 * 		<li><b>include-label</b>: set to true when the background and border should include the label of this item as well.</li>
 * 		<li><b>colspan</b>: when this item is embedded in a table, you can span it over several cells, e.g. colspan: 2;.</li>
 * 		<li><b>label-style</b>: The name of the specialized label style for this item, e.g. "label-style: funnyLabel;"</li>
 * 		<li><b>focused-style</b>: The name of the specialized focused style for this item, e.g. "focused-style: funnyFocused;"</li>
 * 		<li><b>view-type</b>: The view of this item.</li>
 * </ul>
 * 
 * A superclass for components that can be added to a <A HREF="../../../javax/microedition/lcdui/Form.html"><CODE>Form</CODE></A>. All <code>Item</code> objects have a label field,
 * which is a string that is
 * attached to the item. The label is typically displayed near the component
 * when it is displayed within a screen.  The label should be positioned on
 * the same horizontal row as the item or
 * directly above the item.  The implementation should attempt to distinguish
 * label strings from other textual content, possibly by displaying the label
 * in a different font, aligning it to a different margin, or appending a
 * colon to it if it is placed on the same line as other string content.
 * If the screen is scrolling, the implementation should try
 * to keep the label visible at the same time as the <code>Item</code>.
 * 
 * <p>In some cases,
 * when the user attempts to interact with an <code>Item</code>,
 * the system will switch to
 * a system-generated screen where the actual interaction takes place. If
 * this occurs, the label will generally be carried along and displayed within
 * this new screen in order to provide the user with some context for the
 * operation. For this reason it is recommended that applications supply a
 * label to all interactive Item objects. However, this is not required, and
 * a <code>null</code> value for a label is legal and specifies
 * the absence of a label.
 * </p>
 * 
 * <h3>Item Layout</h3>
 * 
 * <p>An <code>Item's</code> layout within its container is
 * influenced through layout directives:</p>
 * 
 * <ul>
 * <li> <code>LAYOUT_DEFAULT</code> </li>
 * <li> <code>LAYOUT_LEFT</code> </li>
 * <li> <code>LAYOUT_RIGHT</code> </li>
 * <li> <code>LAYOUT_CENTER</code> </li>
 * <li> <code>LAYOUT_TOP</code> </li>
 * <li> <code>LAYOUT_BOTTOM</code> </li>
 * <li> <code>LAYOUT_VCENTER</code> </li>
 * <li> <code>LAYOUT_NEWLINE_BEFORE</code> </li>
 * <li> <code>LAYOUT_NEWLINE_AFTER</code> </li>
 * <li> <code>LAYOUT_SHRINK</code> </li>
 * <li> <code>LAYOUT_VSHRINK</code> </li>
 * <li> <code>LAYOUT_EXPAND</code> </li>
 * <li> <code>LAYOUT_VEXPAND</code> </li>
 * <li> <code>LAYOUT_2</code> </li>
 * </ul>
 * 
 * <p>The <code>LAYOUT_DEFAULT</code> directive indicates
 * that the container's default
 * layout policy is to be used for this item.
 * <code>LAYOUT_DEFAULT</code> has the value
 * zero and has no effect when combined with other layout directives.  It is
 * useful within programs in order to document the programmer's intent.</p>
 * 
 * <p>The <code>LAYOUT_LEFT</code>, <code>LAYOUT_RIGHT</code>, and
 * <code>LAYOUT_CENTER</code> directives indicate
 * horizontal alignment and are mutually exclusive.  Similarly, the
 * <code>LAYOUT_TOP</code>, <code>LAYOUT_BOTTOM</code>, and
 * <code>LAYOUT_VCENTER</code> directives indicate vertical
 * alignment and are mutually exclusive.</p>
 * 
 * <p>A horizontal alignment directive, a vertical alignment directive, and
 * any combination of other layout directives may be combined using the
 * bit-wise <code>OR</code> operator (<code>|</code>) to compose a
 * layout directive value.  Such a value
 * is used as the parameter to the <A HREF="../../../javax/microedition/lcdui/Item.html#setLayout(int)"><CODE>setLayout(int)</CODE></A> method and is the return
 * value from the <A HREF="../../../javax/microedition/lcdui/Item.html#getLayout()"><CODE>getLayout()</CODE></A> method.</p>
 * 
 * <p>Some directives have no defined behavior in some contexts.  A layout
 * directive is ignored if its behavior is not defined for the particular
 * context within which the <code>Item</code> resides.</p>
 * 
 * <p>A complete specification of the layout of <code>Items</code>
 * within a <code>Form</code> is given
 * <a href="Form.html#layout">here</a>.</p>
 * 
 * <a name="sizes"></a>
 * <h3>Item Sizes</h3>
 * 
 * <p><code>Items</code> have two explicit size concepts: the <em>minimum</em>
 * size and the
 * <em>preferred</em> size.  Both the minimum and the preferred sizes refer to
 * the total area of the <code>Item</code>, which includes space for the
 * <code>Item's</code> contents,
 * the <code>Item's</code> label, as well as other space that is
 * significant to the layout
 * policy.  These sizes do not include space that is not significant for
 * layout purposes.  For example, if the addition of a label to an
 * <code>Item</code> would
 * cause other <code>Items</code> to move in order to make room,
 * then the space occupied by
 * this label is significant to layout and is counted as part of
 * the <code>Item's</code>
 * minimum and preferred sizes.  However, if an implementation were to place
 * the label in a margin area reserved exclusively for labels, this would not
 * affect the layout of neighboring <code>Items</code>.
 * In this case, the space occupied
 * by the label would not be considered part of the minimum and preferred
 * sizes.</p>
 * 
 * <p>The minimum size is the smallest size at which the
 * <code>Item</code> can function and
 * display its contents, though perhaps not optimally.  The minimum size
 * may be recomputed whenever the <code>Item's</code> contents changes.</p>
 * 
 * <p>The preferred size is generally a size based on the
 * <code>Item's</code> contents and
 * is the smallest size at which no information is clipped and text wrapping
 * (if any) is kept to a tolerable minimum.  The preferred size may be
 * recomputed whenever the <code>Item's</code> contents changes.
 * The application can
 * <em>lock</em> the preferred width or preferred height (or both) by
 * supplying specific values for parameters to the <A HREF="../../../javax/microedition/lcdui/Item.html#setpreferredSize(int, int)"><CODE>setpreferredSize</CODE></A> method.  The manner in which an
 * <code>Item</code> fits its contents
 * within an application-specified preferred size is implementation-specific.
 * However, it is recommended that textual content be word-wrapped to fit the
 * preferred size set by the application.  The application can <em>unlock</em>
 * either or both dimensions by supplying the value <code>-1</code>
 * for parameters to the <code>setpreferredSize</code> method.</p>
 * 
 * <p>When an <code>Item</code> is created, both the preferred width
 * and height are
 * unlocked.  In this state, the implementation computes the preferred width
 * and height based on the <code>Item's</code> contents, possibly
 * including other relevant
 * factors such as the <code>Item's</code> graphic design and the
 * screen dimensions.
 * After having locked either the preferred width or height, the application
 * can restore the initial, unlocked state by calling
 * <code>setpreferredSize(-1,&nbsp;-1)</code>.</p>
 * 
 * <p>The application can lock one dimension of the preferred size and leave
 * the other unlocked.  This causes the system to compute an appropriate value
 * for the unlocked dimension based on arranging the contents to fit the
 * locked dimension.  If the contents changes, the size on the unlocked
 * dimension is recomputed to reflect the new contents, but the size on the
 * locked dimension remains unchanged.  For example, if the application called
 * <code>setpreferredSize(50,&nbsp;-1)</code>, the preferred width would be
 * locked at <code>50</code> pixels and the preferred height would
 * be computed based on the
 * <code>Item's</code> contents.  Similarly, if the application called
 * <code>setpreferredSize(-1,&nbsp;60)</code>, the preferred height would be
 * locked at <code>60</code> pixels and the preferred width would be
 * computed based on the
 * <code>Item's</code> contents.  This feature is particularly useful
 * for <code>Items</code> with
 * textual content that can be line wrapped.</p>
 * 
 * <p>The application can also lock both the preferred width and height to
 * specific values.  The <code>Item's</code> contents are truncated or padded
 * as necessary to honor this request.  For <code>Items</code> containing
 * text, the text should be wrapped to the specified width, and any truncation
 * should occur at the end of the text.</p>
 * 
 * <p><code>Items</code> also have an implicit maximum size provided by the
 * implementation.  The maximum width is typically based on the width of the
 * screen space available to a <code>Form</code>.  Since <code>Forms</code>
 * can scroll vertically, the maximum height should typically not be based on
 * the height of the available screen space.</p>
 * 
 * <p>If the application attempts to lock a preferred size dimension to a
 * value smaller than the minimum or larger than the maximum, the
 * implementation may disregard the requested value and instead use either the
 * minimum or maximum as appropriate.  If this occurs, the actual values used
 * must be visible to the application via the values returned from the
 * <A HREF="../../../javax/microedition/lcdui/Item.html#getpreferredWidth()"><CODE>getpreferredWidth</CODE></A> and
 * <A HREF="../../../javax/microedition/lcdui/Item.html#getpreferredHeight()"><CODE>getpreferredHeight</CODE></A> methods.
 * </p>
 * 
 * <h3>Commands</h3>
 * 
 * <p>A <code>Command</code> is said to be present on an <code>Item</code>
 * if the <code>Command</code> has been
 * added to this <code>Item</code> with a prior call to <A HREF="../../../javax/microedition/lcdui/Item.html#addCommand(javax.microedition.lcdui.Command)"><CODE>addCommand(javax.microedition.lcdui.Command)</CODE></A>
 * or <A HREF="../../../javax/microedition/lcdui/Item.html#setDefaultCommand(javax.microedition.lcdui.Command)"><CODE>setDefaultCommand(javax.microedition.lcdui.Command)</CODE></A> and if
 * the <code>Command</code> has not been removed with a subsequent call to
 * <A HREF="../../../javax/microedition/lcdui/Item.html#removeCommand(javax.microedition.lcdui.Command)"><CODE>removeCommand(javax.microedition.lcdui.Command)</CODE></A>.  <code>Commands</code> present on an
 * item should have a command
 * type of <code>ITEM</code>.  However, it is not an error for a
 * command whose type is
 * other than <code>ITEM</code> to be added to an item.
 * For purposes of presentation and
 * placement within its user interface, the implementation is allowed to
 * treat a command's items as if they were of type <code>ITEM</code>. </p>
 * 
 * <p><code>Items</code> may have a <em>default</em> <code>Command</code>.
 * This state is
 * controlled by the <A HREF="../../../javax/microedition/lcdui/Item.html#setDefaultCommand(javax.microedition.lcdui.Command)"><CODE>setDefaultCommand(javax.microedition.lcdui.Command)</CODE></A> method.  The default
 * <code>Command</code> is eligible to be bound to a special
 * platform-dependent user
 * gesture.  The implementation chooses which gesture is the most
 * appropriate to initiate the default command on that particular
 * <code>Item</code>.
 * For example, on a device that has a dedicated selection key, pressing
 * this key might invoke the item's default command.  Or, on a
 * stylus-based device, tapping on the <code>Item</code> might
 * invoke its default
 * command.  Even if it can be invoked through a special gesture, the
 * default command should also be invokable in the same fashion as
 * other item commands.</p>
 * 
 * <p>It is possible that on some devices there is no special gesture
 * suitable for invoking the default command on an item.  In this case
 * the default command must be accessible to the user in the same
 * fashion as other item commands.  The implementation may use the state
 * of a command being the default in deciding where to place the command
 * in its user interface.</p>
 * 
 * <p>It is possible for an <code>Item</code> not to have a default command.
 * In this
 * case, the implementation may bind its special user gesture (if any)
 * for another purpose, such as for displaying a menu of commands.  The
 * default state of an <code>Item</code> is not to have a default command.
 * An <code>Item</code>
 * may be set to have no default <code>Command</code> by removing it from
 * the <code>Item</code> or
 * by passing <code>null</code> to the <code>setDefaultCommand()</code>
 * method.</p>
 * 
 * <p>The same command may occur on more than one
 * <code>Item</code> and also on more than
 * one <code>Displayable</code>.  If this situation occurs, the user
 * must be provided with
 * distinct gestures to invoke that command on each <code>Item</code> or
 * <code>Displayable</code> on
 * which it occurs, while those <code>Items</code> or <code>Displayables</code>
 * are visible on the
 * display.  When the user invokes the command, the listener
 * (<code>CommandListener</code>
 * or <code>ItemCommandListener</code> as appropriate) of just the
 * object on which the
 * command was invoked will be called.</p>
 * 
 * <p>Adding commands to an <code>Item</code> may affect its appearance, the
 * way it is laid out, and the traversal behavior.  For example, the presence
 * of commands on an <code>Item</code> may cause row breaks to occur, or it
 * may cause additional graphical elements (such as a menu icon) to appear.
 * In particular, if a <code>StringItem</code> whose appearance mode is
 * <code>PLAIN</code> (see below) is given one or more <code>Commands</code>,
 * the implementation is allowed to treat it as if it had a different
 * appearance mode.</p>
 * 
 * <p>J2ME Polish notifies the command-listener of the current screen,
 * when an item-command has been selected and no item-command-listener
 * has been registered.
 * </p>
 * 
 * <a name="appearance"></a>
 * <h3>Appearance Modes</h3>
 * 
 * <p>The <code>StringItem</code> and <code>ImageItem</code> classes have an
 * <em>appearance mode</em> attribute that can be set in their constructors.
 * This attribute can have one of the values <A HREF="../../../javax/microedition/lcdui/Item.html#PLAIN"><CODE>PLAIN</CODE></A>,
 * <A HREF="../../../javax/microedition/lcdui/Item.html#HYPERLINK"><CODE>HYPERLINK</CODE></A>, or <A HREF="../../../javax/microedition/lcdui/Item.html#BUTTON"><CODE>BUTTON</CODE></A>.
 * An appearance mode of <code>PLAIN</code> is typically used
 * for non-interactive
 * display of textual or graphical material.  The appearance
 * mode values do not have any side effects on the interactivity of the item.
 * In order to be interactive, the item must have one or more
 * <code>Commands</code>
 * (preferably with a default command assigned), and it must have a
 * <code>CommandListener</code> that receives notification of
 * <code>Command</code> invocations.  The
 * appearance mode values also do not have any effect on the semantics of
 * <code>Command</code> invocation on the item.  For example,
 * setting the appearance mode
 * of a <code>StringItem</code> to be <code>HYPERLINK</code>
 * requests that the implementation display
 * the string contents as if they were a hyperlink in a browser.  It is the
 * application's responsibility to attach a <code>Command</code>
 * and a listener to the
 * <code>StringItem</code> that provide behaviors that the user
 * would expect from invoking
 * an operation on a hyperlink, such as loading the referent of the link or
 * adding the link to the user's set of bookmarks.</p>
 * 
 * <p>Setting the appearance mode of an <code>Item</code> to be other than
 * <code>PLAIN</code> may affect its minimum, preferred, and maximum sizes, as
 * well as the way it is laid out.  For example, a <code>StringItem</code>
 * with an appearance mode of <code>BUTTON</code> should not be wrapped across
 * rows.  (However, a <code>StringItem</code> with an appearance mode of
 * <code>HYPERLINK</code> should be wrapped the same way as if its appearance
 * mode is <code>PLAIN</code>.)</p>
 * 
 * <p>A <code>StringItem</code> or <code>ImageItem</code>
 * in <code>BUTTON</code> mode can be used to create a
 * button-based user interface.  This can easily lead to applications that are
 * inconvenient to use.  For example, in a traversal-based system, users must
 * navigate to a button before they can invoke any commands on it.  If buttons
 * are spread across a long <code>Form</code>, users may be required
 * to perform a
 * considerable amount of navigation in order to discover all the available
 * commands.  Furthermore, invoking a command from a button at the
 * other end of the <code>Form</code> can be quite cumbersome.
 * Traversal-based systems
 * often provide a means of invoking commands from anywhere (such as from a
 * menu), without the need to traverse to a particular item.  Instead of
 * adding a command to a button and placing that button into a
 * <code>Form</code>, it would
 * often be more appropriate and convenient for users if that command were
 * added directly to the <code>Form</code>.  Buttons should be used
 * only in cases where
 * direct user interaction with the item's string or image contents is
 * essential to the user's understanding of the commands that can be invoked
 * from that item.</p>
 * 
 * <h3>Default State</h3>
 * 
 * <p>Unless otherwise specified by a subclass, the default state of newly
 * created <code>Items</code> is as follows:</p>
 * 
 * <ul>
 * <li>the <code>Item</code> is not contained within
 * (&quot;owned by&quot;) any container;</li>
 * <li>there are no <code>Commands</code> present;</li>
 * <li>the default <code>Command</code> is <code>null</code>;</li>
 * <li>the <code>ItemCommandListener</code> is <code>null</code>;</li>
 * <li>the layout directive value is <code>LAYOUT_DEFAULT</code>; and</li>
 * <li>both the preferred width and preferred height are unlocked.</li>
 * </ul>
 * 
 * <p>copyright Enough Software 2004 - 2009</p>
 * @since MIDP 1.0
 */
public abstract class Item implements UiElement, Animatable
{
//#if polish.handleEvents || polish.css.animations
	//#define tmp.handleEvents
	private boolean hasBeenShownBefore;
//#endif
	
	/**
	 * A J2ME Polish constant defining a transparent/invisible color.
	 * TRANSPARENT has the value -1.
	 */
	public static final int TRANSPARENT = -1;
	
	/**
	 * A J2ME Polish constant defining a vertical orientation.
	 * VERTICAL has the value 0.
	 */
	public static final int VERTICAL = 0;
	
	/**
	 * A J2ME Polish constant defining a horizontal orientation.
	 * HORIZONTAL has the value 1.
	 */
	public static final int HORIZONTAL = 1;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should follow the default layout policy of its container.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>LAYOUT_DEFAULT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_DEFAULT = 0;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * left-aligned layout.
	 * 
	 * <P>Value <code>1</code> is assigned to <code>LAYOUT_LEFT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_LEFT = 1;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * right-aligned layout.
	 * 
	 * <P>Value <code>2</code> is assigned to <code>LAYOUT_RIGHT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_RIGHT = 2;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * horizontally centered layout.
	 * 
	 * <P>Value <code>3</code> is assigned to <code>LAYOUT_CENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_CENTER = 3;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * top-aligned layout.
	 * 
	 * <P>Value <code>0x10</code> is assigned to <code>LAYOUT_TOP</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_TOP = 0x10;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * bottom-aligned layout.
	 * 
	 * <P>Value <code>0x20</code> is assigned to <code>LAYOUT_BOTTOM</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_BOTTOM = 0x20;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * vertically centered layout.
	 * 
	 * <P>Value <code>0x30</code> is assigned to
	 * <code>LAYOUT_VCENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VCENTER = 0x30;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should be placed at the beginning of a new line or row.
	 * 
	 * <P>Value <code>0x100</code> is assigned to
	 * <code>LAYOUT_NEWLINE_BEFORE</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_BEFORE = 0x100;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should the last on its line or row, and that the next
	 * <code>Item</code> (if any) in the container
	 * should be placed on a new line or row.
	 * 
	 * <P>Value <code>0x200</code> is assigned to
	 * <code>LAYOUT_NEWLINE_AFTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_AFTER = 0x200;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be reduced to its minimum width.
	 * 
	 * <P>Value <code>0x400</code> is assigned to <code>LAYOUT_SHRINK</code></P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_SHRINK = 0x400;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be increased to fill available space.
	 * 
	 * <P>Value <code>0x800</code> is assigned to <code>LAYOUT_EXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_EXPAND = 0x800;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be reduced to its minimum height.
	 * 
	 * <P>Value <code>0x1000</code> is assigned to
	 * <code>LAYOUT_VSHRINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VSHRINK = 0x1000;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be increased to fill available space.
	 * 
	 * <P>Value <code>0x2000</code> is assigned to
	 * <code>LAYOUT_VEXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VEXPAND = 0x2000;

	/**
	 * A layout directive indicating that new MIDP 2.0 layout
	 * rules are in effect for this <code>Item</code>.  If this
	 * bit is clear, indicates that MIDP 1.0 layout behavior
	 * applies to this <code>Item</code>.
	 * 
	 * <P>Value <code>0x4000</code> is assigned to
	 * <code>LAYOUT_2</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_2 = 0x4000;

	/**
	 * An appearance mode value indicating that the <code>Item</code> is to have
	 * a normal appearance.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>PLAIN</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int PLAIN = 0;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a hyperlink.
	 * <P>Value <code>1</code> is assigned to <code>HYPERLINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int HYPERLINK = 1;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a button.
	 * <P>Value <code>2</code> is assigned to <code>BUTTON</code>.</P>
	 * 
	 * @since MIDP 2.0
	 */
	public static final int BUTTON = 2;

	/**
	 * A J2ME Polish appearance mode value indicating that the <code>Item</code>
	 * accepts input from the user.
	 * <P>Value <code>3</code> is assigned to <code>INTERACTIVE</code>.</P>
	 */
	public static final int INTERACTIVE = 3;
	
	private static final ArrayList COMMANDS = new ArrayList();
	
	protected int layout;
	protected ItemCommandListener itemCommandListener;
	protected Command defaultCommand;
	protected int preferredWidth;
	protected int preferredHeight;
	//#ifdef  polish.css.width
		protected Dimension cssWidth;
	//#endif
	//#ifdef  polish.css.height
		protected Dimension cssHeight;
	//#endif
	protected Dimension minimumWidth;
	protected Dimension minimumHeight;
	//#ifdef polish.css.max-width
		protected Dimension maximumWidth;
	//#endif
	//#ifdef polish.css.max-height
		protected Dimension maximumHeight;
	//#endif
	
	//#ifdef polish.css.min-item-width
		protected Dimension minimumItemWidth;
	//#endif
	//#ifdef polish.css.min-item-height
		protected Dimension minimumItemHeight;
	//#endif
	//#ifdef polish.css.max-item-width
		protected Dimension maximumItemWidth;
	//#endif
	//#ifdef polish.css.max-item-height
		protected Dimension maximumItemHeight;
	//#endif
		
	boolean isInitialized;
	
	/** the background of this item  */
	public Background background;
	protected Border border;
	//#if polish.css.border-adjust
		private Dimension borderAdjust;
	//#endif
	//#if polish.css.bgborder
		/** the background border of an item - this border is painted before the background. This field
		 * is only present when polish.css.bgborder is true.
		 */
		protected Border bgBorder;
	//#endif
		
	protected Style style;
	/** the width of this item - only for read access */
	public int itemWidth;
	/** the height of this item - only for read access */
	public int itemHeight;
	protected int paddingLeft;
	protected int paddingTop;
	protected int paddingRight;
	protected int paddingBottom;
	protected int paddingVertical;
	protected int paddingHorizontal;
	protected int marginLeft;
	protected int marginTop;
	protected int marginRight;
	protected int marginBottom;
	/** The width of this item's content **/
	protected int contentWidth;
	/** The height of this item's content **/
	protected int contentHeight;
	protected int availContentWidth;
	protected int availContentHeight;
	protected int backgroundWidth;
	protected int backgroundHeight;
	/** The appearance mode of this item, either PLAIN or one of the interactive modes BUTTON, HYPERLINK or INTERACTIVE. */
	public int appearanceMode;
	/**
	 * The screen to which this item belongs to.
	 */
	protected Screen screen;
	//#ifdef polish.useDynamicStyles
		/**
		 * The appropriate CSS selector of this item. 
		 * This is either the style's name or a selector
		 * depending on the state of this item. A StringItem
		 * can have the selector "p", "a" or "button", for example.
		 * This variable can only be used, when the proprocessing variable
		 * "polish.useDynamicStyles" is defined.
		 */
		protected String cssSelector;
	//#endif
	/**
	 * Determines whether the style has be dynamically assigned already.
	 */
	protected boolean isStyleInitialised;
	/**
	 * The parent of this item.
	 */
	protected Item parent;

	protected ArrayList commands;
	
	protected boolean isLayoutCenter;
	protected boolean isLayoutExpand;
	protected boolean isLayoutRight;
	// the current positions of this item:
	/** the horizontal start position relative to it's parent's item left content edge */
	public int relativeX;
	/** the vertical start position of this item relative to it's parent item top content edge */
	public int relativeY; 
	/** the horizontal position of this item's content relative to it's left edge (so for a left aligned item its marginLeft + border.widthLeft + paddingLeft */
	protected int contentX;
	/** the vertical position of this item's content relative to it's top edge */
	protected int contentY; // absolute top vertical position of the content 
	// the current positions of an internal element relative to the content origin 
	// which should be visible:
	/** no internal position has been set for this item, value is -9999. 
	 * This is used as a value for internalX to describe that the item has no intenal position set 
	 */
	public final static int NO_POSITION_SET = -9999;
	/** 
	 * The internal horizontal position of this item's content relative to it's left edge. 
	 * When it is equal NO_POSITION_SET this item's internal position is not known.
	 * The internal position is useful for items that have a large content which
	 * needs to be scrolled, e.g. containers.  
	 */
	protected int internalX = NO_POSITION_SET;
	/** the vertical position of this item's internal content relative to it's top edge */
	protected int internalY;
	/** The internal width of this item's content.  */
	protected int internalWidth;
	/** The internal height of this item's content.  */
	protected int internalHeight;
	/** flag indicating whether this item is focused, please use isFocused() for accessing it. */
	public boolean isFocused;
	protected boolean isJustFocused;
	
	//#ifdef polish.css.before
		private String beforeUrl;
		private int beforeWidth;
		private int beforeHeight;
		private Image beforeImage;
	//#endif

	//#ifdef polish.css.after
		private String afterUrl;
		private int afterWidth;
		private int afterHeight;
		private Image afterImage;
	//#endif
	// label settings:
	protected Style labelStyle = StyleSheet.labelStyle;
	protected StringItem label;
	/** indicates that label and content are positioned on the same row if true */
	protected boolean useSingleRow;
	//#if polish.blackberry
		/** a blackberry specific internal field */
		public Field _bbField;
	//#endif
	//#if polish.android
		protected View _androidView;
	//#endif
	protected Style focusedStyle;
	protected boolean isPressed;
	//#if polish.css.pressed-style
		private Style normalStyle;
		private Style pressedStyle;
	//#endif

	//#if polish.css.colspan
		protected int colSpan = 1;
	//#endif
	//#if polish.css.rowspan
		protected int rowSpan = 1;
	//#endif
	//#if polish.css.include-label
		protected boolean includeLabel;
	//#endif
	//#if polish.css.complete-background
		protected Background completeBackground;
	//#endif
	//#if polish.css.complete-border
		protected Border completeBorder;
	//#endif
	//#if polish.css.complete-background || polish.css.complete-border
		protected Dimension completeBackgroundPadding;
	//#endif
	/** The vertical offset for the background, can be used for smoother scrolling, for example */ 
	protected int backgroundYOffset;

	//#ifdef polish.css.view-type
		protected ItemView view;
		protected boolean preserveViewType;
		protected boolean setView;
	//#endif
	//#if polish.supportInvisibleItems || polish.css.visible
		//#define tmp.invisible
		protected boolean isInvisible;
		private int invisibleAppearanceModeCache;
		private int invisibleItemHeight;
	//#endif
	protected boolean isShown;
	private HashMap attributes;

	//#if polish.css.opacity && polish.midp2
		protected int opacity = 255;
		protected int[] opacityRgbData;
		protected boolean opacityPaintNormally;
		private int opacityAtGeneration;
	//#endif
	private ItemStateListener itemStateListener;

	//#if polish.css.x-adjust
		protected Dimension xAdjustment;
	//#endif
	//#if polish.css.y-adjust
		protected Dimension yAdjustment;
	//#endif
	//#if polish.css.content-x-adjust
		protected Dimension contentXAdjustment;
	//#endif
	//#if polish.css.content-y-adjust
		protected Dimension contentYAdjustment;
	//#endif

	//#if polish.css.background-width
		private int originalBackgroundWidth;
	//#endif
	//#if polish.css.background-height
		private int originalBackgroundHeight;
	//#endif
	//#if polish.css.background-anchor && (polish.css.background-width || polish.css.background-height)
		private int backgroundAnchor;
	//#endif
	//#if polish.css.content-visible
		protected boolean isContentVisible = true;
	//#endif
	//#if polish.css.filter
		private RgbFilter[] filters;
		private boolean isFiltersActive;
		private boolean filterPaintNormally;
		private RgbFilter[] originalFilters;
		private RgbImage filterRgbImage;
		private RgbImage filterProcessedRgbImage;
                public boolean cacheItemImage ;
	//#endif
	//#if polish.css.inline-label
		protected boolean isInlineLabel;
	//#endif
	protected int availableWidth;
	protected int availableHeight;
	protected boolean ignoreRepaintRequests;

	private ItemTransition itemTransition;

	private boolean preserveBackground;
	private boolean preserveBorder;
	//#if polish.css.visited-style
		private boolean hasBeenVisited;
	//#endif
	//#if polish.css.portrait-style || polish.css.landscape-style
		protected Style landscapeStyle;
		protected Style portraitStyle;
	//#endif
	//#if polish.Item.ShowCommandsOnHold
		//#define tmp.supportTouchGestures
		private boolean isShowCommands;
		private Container commandsContainer;
	//#endif
	//#if polish.supportTouchGestures
		//#define tmp.supportTouchGestures
	//#endif
	//#if tmp.supportTouchGestures
		private long gestureStartTime;
		private int gestureStartX;
		private int gestureStartY;
		private boolean isIgnorePointerReleaseForGesture;
	//#endif
	//#if polish.useNativeGui
		protected NativeItem nativeItem;
	//#endif
	private UiEventListener uiEventListener;
	private CycleListener cycleListener;




	/**
	 * Convenience constructor.
	 * Creates a new item without label, with a left aligned layout and Item.PLAIN appearance mode.
	 */
	protected Item() {
		this( null, LAYOUT_DEFAULT, PLAIN, null );
	}
	
	/**
	 * Convenience constructor.
	 * Creates a new item without label, with a left aligned layout, an Item.PLAIN appearance mode and the given style.
	 * @param style the style for this item
	 */
	protected Item( Style style ) {
		this( null, LAYOUT_DEFAULT, PLAIN, style );
	}
	
	/**
	 * Convenience constructor.
	 * Creates a new item with the specified label and layout, an Item.PLAIN appearance mode and default style.
	 * @param label the label of this item
	 * @param layout the layout of this item
	 */
	protected Item( String label, int layout) {
		this( label, layout, PLAIN, null );
	}

	/**
	 * Creates a new Item.
	 * 
	 * @param label the label of this item
	 * @param layout the layout of this item
	 * @param appearanceMode the mode of this item, either Item.PLAIN or Item.INTERACTIVE (Item.BUTTON, Item.HYPERLINK, Item.INTERACTIVE)
	 * @param style the style of this item - contains the background, border etc.
	 */
	protected Item(String label, int layout, int appearanceMode, Style style) {
		this.style = style;
		this.layout = layout;
		this.appearanceMode = appearanceMode;
		if (label != null && label.length() != 0) {
			setLabel( label );
		}
		if (style == null) {
			this.layout = layout;
		} else {
			this.style = style;
			this.isStyleInitialised = false;
		}

                //#if polish.css.filter
                cacheItemImage = true ;
                //#endif
	}

	/**
	 * Sets the label of the <code>Item</code>. If <code>label</code>
	 * is <code>null</code>, specifies that this item has no label.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param label - the label string
	 * @throws IllegalStateException - if this Item is contained  within an Alert
	 * @see #getLabel()
	 */
	public void setLabel( String label)
	{
		if (this.label == null) {
			this.label = new StringItem( null, label, this.labelStyle );
			this.label.parent = this; // orginally used "this.parent", however that field might not be known at this moment.
			if (this.isShown){
				this.label.showNotify();
			}
		} else if ((label == null && this.label.getText() == null) || (label != null && label.equals(this.label.getText())) ){
			return;
		} else {
			this.label.setText( label );
		}
		if (isInitialized()) {
			setInitialized(false);
			repaint();
		}
	}

	/**
	 * Gets the label of this <code>Item</code> object.
	 * 
	 * @return the label string
	 * @see #setLabel(java.lang.String)
	 */
	public String getLabel()
	{
		if (this.label == null) {
			return null;
		} else {
			return this.label.getText();
		}
	}
	
	/**
	 * Retrieves the label item that is used by this item.\
	 * 
	 * @return the item or null when no item is used.
	 */
	public Item getLabelItem() {
		return this.label;
	}

	/**
	 * Gets the layout directives used for placing the item.
	 * 
	 * @return a combination of layout directive values
	 * @see #setLayout(int)
	 * @since  MIDP 2.0
	 */
	public int getLayout()
	{
		return this.layout;
	}

	/**
	 * Sets the layout directives for this item.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param layout - a combination of layout directive values for this item
	 * @throws IllegalArgumentException - if the value of layout is not a bit-wise OR combination of layout directives
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getLayout()
	 * @since  MIDP 2.0
	 */
	public void setLayout(int layout)
	{
		if (layout != this.layout) {
			this.layout = layout;

			// horizontal styles: center -> right -> left
			if ( ( layout & LAYOUT_CENTER ) == LAYOUT_CENTER ) {
				this.isLayoutCenter = true;
				this.isLayoutRight = false;
			} else {
				this.isLayoutCenter = false;
				if ( (layout & LAYOUT_RIGHT ) == LAYOUT_RIGHT ) {
					this.isLayoutRight = true;
				} else {
					this.isLayoutRight = false;
				}
			}
			
			// vertical styles: vcenter -> bottom -> top
			// expanding layouts:
			if ( ( layout & LAYOUT_EXPAND ) == LAYOUT_EXPAND ) {
				this.isLayoutExpand = true;
			} else {
				this.isLayoutExpand = false;
			}
			if (isInitialized()) {
				setInitialized(false);
				repaint();
			} else if (!this.isStyleInitialised && this.style != null) {
				setStyle( this.style );
				this.layout = layout;
			}
		}
	}

	/**
	 * Returns the appearance mode of this <code>Item</code>.
	 * See <a href="Item.html#appearance">Appearance Modes</a>.
	 * 
	 * @return the appearance mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 * @since  MIDP 2.0
	 */
	public int getAppearanceMode()
	{
		return this.appearanceMode;
	}
	
	/**
	 * Sets the appearance mode of this item.
	 * 
	 * @param appearanceMode the mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 */
	public void setAppearanceMode( int appearanceMode ) {
		this.appearanceMode = appearanceMode;
	}
	
	
	//#ifdef polish.css.view-type
	/**
	 * Sets the view type for this item.
	 * Please note that this is only supported when view-type CSS attributes are used within
	 * your application.
	 * @param view the new view, use null to remove the current view
	 */
	public void setView( ItemView view ) {
		if (!this.isStyleInitialised && this.style != null) {
			setStyle( this.style );
		}
		this.view = view;
		if (view != null && this.style != null) {
			view.setStyle( this.style );
		}
	}
	//#endif
	
	//#ifdef polish.css.view-type	
	/**
	 * Retrieves the view type for this item.
	 * Please note that this is only supported when view-type CSS attributes are used within
	 * your application.
	 * 
	 * @return the current view, may be null
	 */
	public ItemView getView() {
		return this.view;
	}
	//#endif
	
	/**
	 * Retrieves the style of this item.
	 * 
	 * @return the style of this item.
	 */
	public Style getStyle() {
		return this.style;
	}
	
	/**
	 * Sets a new background for this item.
	 * @param background the new background, use null for not showing a background
	 */
	public void setBackground( Background background ) {
		this.preserveBackground = true;
		this.background = background;
                this.background.setParentItem(this);
	}
	
	/**
	 * Sets a new border for this item
	 * @param border the new border, use null for not showing a border
	 */
	public void setBorder( Border border ) {
		this.preserveBorder = true;
		this.border = border;
	}
	
	/**
	 * Sets the style for an item
	 * with the use of style preprocessing e.g.:
	 * //#style myStyle
	 * setStyle();
	 */
	public void setStyle() {
		// do nothing here
	}
	
	/**
	 * Sets the style of this item.
	 * 
	 * @param style the new style for this item.
	 * @throws NullPointerException when style is null
	 */
	public void setStyle( Style style ) {
		//#debug
		System.out.println("setting style " + style.name + " for " + this + ", prevStyle=" + (this.style == null ? "<null>" : this.style.name) );
		this.isStyleInitialised = true;
		this.style = style;
		
		if (style != StyleSheet.defaultStyle) {
			setLayout( style.layout );
		}
		//System.out.println( this + " style [" + style.name + "]: right: " + this.isLayoutRight + " center: " + this.isLayoutCenter + " expand: " + this.isLayoutExpand + " layout=" + Integer.toHexString(this.layout));
		if (this.isShown) {
			if (this.background != style.background && !this.preserveBackground) {
				if (this.background != null) {
					this.background.hideNotify();
				}
				if (style.background != null) {
					style.background.showNotify();
				}
			}
			if (this.border != style.border && !this.preserveBackground) {
				if (this.border != null) {
					this.border.hideNotify();
				}
				if (style.border != null) {
					style.border.showNotify();
				}
			}
		}
		if (!this.preserveBackground) {
			this.background = style.background;
		}
		if (!this.preserveBorder) {
			this.border = style.border;
		}
		
		//#if polish.css.content-visible
			Boolean contentVisibleBool = style.getBooleanProperty("content-visible");
			if (contentVisibleBool != null) {
				this.isContentVisible = contentVisibleBool.booleanValue();
			}
		//#endif
		//#if polish.css.bgborder
			Border bgBord = (Border) style.getObjectProperty("bgborder");
			this.bgBorder = bgBord;
		//#endif
		
		//#ifdef polish.css.label-style
			Style labStyle = (Style) style.getObjectProperty("label-style");
			if (labStyle != null) {
				this.labelStyle = labStyle;
			} else if (this.labelStyle == null) {
				this.labelStyle = StyleSheet.labelStyle;
			}
		//#else
			this.labelStyle = StyleSheet.labelStyle;
		//#endif
		if (this.label != null) {
			this.label.setStyle( this.labelStyle );			
		}
		
		//#ifdef polish.css.focused-style
			//Object object = style.getObjectProperty("focused-style");
			//if (object != null) {
			//	System.out.println("focused-type: " + object.getClass().getName());
			//}
			Style focused = (Style) style.getObjectProperty("focused-style");
			if (focused != null) {
				this.focusedStyle = focused;
			}
		//#endif
		//#if polish.css.pressed-style
			Style pressed = (Style) style.getObjectProperty("pressed-style");
			if (pressed != null) {
				this.pressedStyle = pressed;
			}
		//#endif

		//#if polish.css.complete-background
			Background bg = (Background) style.getObjectProperty("complete-background");
			if (this.isShown && this.completeBackground != bg) {
				if (this.completeBackground != null) {
					this.completeBackground.hideNotify();
				}
				if (bg != null) {
					bg.showNotify();
				}
			}
			this.completeBackground = bg;
		//#endif
		//#if polish.css.complete-border
			Border brd = (Border) style.getObjectProperty("complete-border");
			if (this.isShown && this.completeBorder != brd) {
				if (this.completeBorder != null) {
					this.completeBorder.hideNotify();
				}
				if (brd != null) {
					brd.showNotify();
				}
			}
			this.completeBorder = brd;
		//#endif
			
		//#ifdef polish.css.view-type
			ItemView viewType = (ItemView) style.getObjectProperty("view-type");
	//		if (this instanceof ChoiceGroup) {
	//			System.out.println("SET.STYLE / CHOICEGROUP: found view-type (1): " + (viewType != null) + " for " + this);
	//		}
			if (viewType != null && viewType.isValid(this, style)) {
				this.view = getView( viewType, style );
			}
		//#endif
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.setStyle(style);
			}
		//#endif	
		//#if polish.css.background-anchor && (polish.css.background-width || polish.css.background-height)
			Integer bgAnchor = style.getIntProperty("background-anchor");
			if (bgAnchor != null) {
				this.backgroundAnchor = bgAnchor.intValue();
			}
		//#endif
		//#if polish.css.filter
			RgbFilter[] filterObjects = (RgbFilter[]) style.getObjectProperty("filter");
			if (filterObjects != null) {
				if (filterObjects != this.originalFilters) {
					this.filters = new RgbFilter[ filterObjects.length ];
					for (int i = 0; i < filterObjects.length; i++)
					{
						RgbFilter rgbFilter = filterObjects[i];
						try
						{
							this.filters[i] = (RgbFilter) rgbFilter.getClass().newInstance();
						} catch (Exception e)
						{
							//#debug warn
							System.out.println("Unable to initialize filter class " + rgbFilter.getClass().getName() + e );
						}
					}
					this.originalFilters = filterObjects;
				}
			}
		//#endif
			
		//#if polish.css.inline-label
			Boolean inlineBool = style.getBooleanProperty("inline-label");
			if (inlineBool != null) {
				this.isInlineLabel = inlineBool.booleanValue();
			}
		//#endif
		
		//#if polish.css.portrait-style || polish.css.landscape-style
			//#if polish.css.landscape-style
				Style lsStyle = (Style) style.getObjectProperty("landscape-style");
				if (lsStyle != null && lsStyle != style) {
					this.landscapeStyle = lsStyle;
					if ((!this.isFocused)&& style.name != null && style.name.indexOf("landscape") == -1) {
						this.portraitStyle = style;
					}
				}
			//#endif
			//#if polish.css.portrait-style
				Style ptStyle = (Style) style.getObjectProperty("portrait-style");
				if (ptStyle != null && ptStyle != style) {
					if ((!this.isFocused)&& style.name != null && style.name.indexOf("portrait") == -1) {
						this.landscapeStyle = style;
					}
					this.portraitStyle = ptStyle;
				}
			//#endif
		//#endif

		// now set other style attributes:
		setStyle( style, true );
		setInitialized(false);
	}
	
	//#ifdef polish.css.view-type	
	/**
	 * Retrieves the view type for this item or instantiates a new one.
	 * Please note that this is only supported when view-type CSS attributes are used within
	 * your application.
	 * 
	 * @param viewType the view registered in the style
	 * @param viewStyle the style
	 * @return the view, may be null
	 */
	protected ItemView getView(ItemView viewType, Style viewStyle)
	{
		if (this.view == null || this.view.getClass() != viewType.getClass()) {
			try {
				// formerly we have used the style's instance when that instance was still free.
				// However, that approach lead to GC problems, as the style is not garbage collected.
				viewType = (ItemView) viewType.getClass().newInstance();
				viewType.parentItem = this;
				if (this.isShown) {
					if (this.view != null) {
						this.view.hideNotify();
					}
					viewType.showNotify();
				}
				return viewType;
			} catch (Exception e) {
				//#debug error
				System.out.println("Container: Unable to init view-type " + e );
			}
		}
		return this.view;
	}
	//#endif

	/**
	 * Sets the style of this item for animatable CSS attributes.
	 * 
	 * @param style the new style for this element.
	 * @param resetStyle true when style settings should be resetted. This is not the case
	 * 			when styles are animated, for example.
	 * @throws NullPointerException when style is null
	 */
	public void setStyle( Style style, boolean resetStyle ) {
		if(!resetStyle && isInitialized()) {
//			boolean initializationRequired = false;
			Dimension value;
			//#if polish.css.margin
				value = (Dimension) style.getObjectProperty("margin");
				if (value != null) {
					int margin = value.getValue(this.availableWidth);
					this.marginLeft = margin;
					this.marginRight = margin;
					this.marginTop = margin;
					this.marginBottom = margin;
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.margin-left
				value = (Dimension) style.getObjectProperty("margin-left");
				if (value != null) {
					this.marginLeft = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.margin-right
				value = (Dimension) style.getObjectProperty("margin-right");
				if (value != null) {
					this.marginRight = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.margin-top
				value = (Dimension) style.getObjectProperty("margin-top");
				if (value != null) {
					this.marginTop = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.margin-bottom
				value = (Dimension) style.getObjectProperty("margin-bottom");
				if (value != null) {
					this.marginBottom = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.padding
				value = (Dimension) style.getObjectProperty("padding");
				if (value != null) {
					int padding = value.getValue(this.availableWidth);
					this.paddingLeft = padding;
					this.paddingRight = padding;
					this.paddingTop = padding;
					this.paddingHorizontal = padding;
					this.paddingVertical = padding;
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.padding-left
				value = (Dimension) style.getObjectProperty("padding-left");
				if (value != null) {
					this.paddingLeft = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.padding-right
				value = (Dimension) style.getObjectProperty("padding-right");
				if (value != null) {
					this.paddingRight = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.padding-top
				value = (Dimension) style.getObjectProperty("padding-top");
				if (value != null) {
					this.paddingTop = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.padding-bottom
				value = (Dimension) style.getObjectProperty("padding-bottom");
				if (value != null) {
					this.paddingBottom = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.padding-horizontal
				value = (Dimension) style.getObjectProperty("padding-horizontal");
				if (value != null) {
					this.paddingHorizontal = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
			//#if polish.css.padding-vertical
				value = (Dimension) style.getObjectProperty("padding-vertical");
				if (value != null) {
					this.paddingVertical = value.getValue(this.availableWidth);
//					initializationRequired = true;
				}
			//#endif
//			if (initializationRequired) {
//				if (this.parent != null) {
//					this.parent.isInitialized = false;
//				} else if (this.screen != null) {
//					this.screen.requestInit();
//				}
//			}
		}
		
		//#ifdef polish.css.before
			String beforeUrlStr = style.getProperty("before"); 
			if (beforeUrlStr != null) {
				if ( !beforeUrlStr.equals(this.beforeUrl) ) {
					try {
						this.beforeImage = StyleSheet.getImage(beforeUrlStr, null, true );
						this.beforeWidth = this.beforeImage.getWidth();
						this.beforeHeight = this.beforeImage.getHeight();
					} catch (IOException e) {
						this.beforeUrl = null;
						this.beforeImage = null;
						this.beforeWidth = 0;
						this.beforeHeight = 0;						
					}
				}
				this.beforeUrl = beforeUrlStr;
			} else if (resetStyle) {
				this.beforeImage = null;
				this.beforeWidth = 0;
				this.beforeHeight = 0;
				this.beforeUrl = beforeUrlStr;
			}
		//#endif
		//#ifdef polish.css.after
			String afterUrlStr = style.getProperty("after");
			if (afterUrlStr != null) {
				if ( !afterUrlStr.equals(this.afterUrl) ) {
					try {
						this.afterImage = StyleSheet.getImage(afterUrlStr, null, true );
						this.afterWidth = this.afterImage.getWidth();
						this.afterHeight = this.afterImage.getHeight();
					} catch (IOException e) {
						this.afterUrl = null;
						this.afterWidth = 0;
						this.afterHeight = 0;
						this.afterImage = null;
					}
				}
				this.afterUrl = afterUrlStr;
			} else if (resetStyle) {
				this.afterWidth = 0;
				this.afterHeight = 0;
				this.afterImage = null;
				this.afterUrl = afterUrlStr;
			}
		//#endif
		//#ifdef polish.css.min-width
			Dimension minWidthDim = (Dimension) style.getObjectProperty("min-width");
			if (minWidthDim != null) {
				this.minimumWidth = minWidthDim;
			}
		//#endif
		//#ifdef polish.css.max-width
			Dimension maxWidthDim  = (Dimension) style.getObjectProperty("max-width");
			if (maxWidthDim != null) {
				this.maximumWidth = maxWidthDim;
			}
		//#endif
		//#ifdef polish.css.width
			Dimension widthDim  = (Dimension) style.getObjectProperty("width");
			if (widthDim != null) {
				this.cssWidth = widthDim;
			}
		//#endif
		
		//#ifdef polish.css.min-item-width
			Dimension minItemWidthDim = (Dimension) style.getObjectProperty("min-item-width");
			if (minItemWidthDim != null) {
				this.minimumItemWidth = minItemWidthDim;
			}
		//#endif
		//#ifdef polish.css.max-item-width
			Dimension maxItemWidthDim  = (Dimension) style.getObjectProperty("max-item-width");
			if (maxItemWidthDim != null) {
				this.maximumItemWidth = maxItemWidthDim;
			}
		//#endif
			
		//#ifdef polish.css.min-height
			Dimension minHeightDim = (Dimension) style.getObjectProperty("min-height");
			if (minHeightDim != null) {
				this.minimumHeight = minHeightDim;
			}
		//#endif
		//#ifdef polish.css.max-height
			Dimension maxHeightDim  = (Dimension) style.getObjectProperty("max-height");
			if (maxHeightDim != null) {
				this.maximumHeight = maxHeightDim;
			}
		//#endif
			
		//#ifdef polish.css.height
			Dimension heightDim  = (Dimension) style.getObjectProperty("height");
			if (heightDim != null) {
				this.cssHeight = heightDim;
			}
		//#endif

		//#ifdef polish.css.min-item-height
			Dimension minItemHeightDim = (Dimension) style.getObjectProperty("min-item-height");
			if (minItemHeightDim != null) {
				this.minimumItemHeight = minItemHeightDim;
			}
		//#endif
		//#ifdef polish.css.max-item-height
			Dimension maxItemHeightDim  = (Dimension) style.getObjectProperty("max-item-height");
			if (maxItemHeightDim != null) {
				this.maximumItemHeight = maxItemHeightDim;
			}
		//#endif
			
		//#if polish.css.colspan
			Integer colSpanInt = style.getIntProperty("colspan");
			if ( colSpanInt != null ) {
				this.colSpan = colSpanInt.intValue();
			}
		//#endif	
		//#if polish.css.rowspan
			Integer rowSpanInt = style.getIntProperty("rowspan");
			if ( rowSpanInt != null ) {
				this.rowSpan = rowSpanInt.intValue();
			}
		//#endif	
		//#if polish.css.include-label
			Boolean includeLabelBool = style.getBooleanProperty("include-label");
			if (includeLabelBool != null) {
				this.includeLabel = includeLabelBool.booleanValue();
			}
		//#endif

		//#if polish.css.complete-background || polish.css.complete-border 
			//#if polish.css.complete-background-padding
				Dimension completeBackgroundPaddingDim = (Dimension) style.getObjectProperty("complete-background-padding");
				if (completeBackgroundPaddingDim != null) {
					this.completeBackgroundPadding = completeBackgroundPaddingDim;
				}
			//#endif
		//#endif
	

		//#if polish.css.opacity && polish.midp2
			Dimension opacityInt = (Dimension) style.getObjectProperty("opacity");
			if (opacityInt != null) {
				this.opacity = opacityInt.getValue(255);
				//System.out.println("Setting opacity to " + this.opacity + " for item " + this + " and style " + style.name);
			} else if (!resetStyle && this.opacity != 255 && this.opacity != 0) {
				// when an attribut is changed, you have to re-generate the opacity buffer:
				this.opacityAtGeneration = this.opacity + 1;
			}
		//#endif
		//#if polish.css.visible
			Boolean visibleBool = style.getBooleanProperty("visible");
			if (visibleBool != null) {
				setVisible( visibleBool.booleanValue() );
			}
		//#endif
			
		//#if polish.css.x-adjust
			Dimension xInt = (Dimension) style.getObjectProperty("x-adjust");
			if (xInt != null) {
				this.xAdjustment = xInt;
			}
		//#endif
		//#if polish.css.y-adjust
			Dimension yInt = (Dimension) style.getObjectProperty("y-adjust");
			if (yInt != null) {
				this.yAdjustment = yInt;
				//System.out.println("setStyle: got yAdjustment of " + yInt.getValue(100) );
			}
		//#endif
		//#if polish.css.content-x-adjust
			Dimension contentXInt = (Dimension) style.getObjectProperty("content-x-adjust");
			if (contentXInt != null) {
				this.contentXAdjustment = contentXInt;
			}
		//#endif
		//#if polish.css.content-y-adjust
			Dimension contentYInt = (Dimension) style.getObjectProperty("content-y-adjust");
			if (contentYInt != null) {
				this.contentYAdjustment = contentYInt;
			}
		//#endif
		if (!resetStyle && isInitialized()) {
			//#if polish.css.background-width
				Dimension bgWidth = (Dimension) style.getObjectProperty("background-width");
				if (bgWidth != null) {
					this.backgroundWidth = bgWidth.getValue(this.originalBackgroundWidth);
				}
			//#endif
			//#if polish.css.background-height
				Dimension bgHeight = (Dimension) style.getObjectProperty("background-height");
				if (bgHeight != null) {
					this.backgroundHeight = bgHeight.getValue(this.originalBackgroundHeight);
				}
			//#endif
		}
		//#if polish.css.border-adjust
			Dimension borderAdjustDim = (Dimension) style.getObjectProperty("border-adjust");
			if (borderAdjustDim != null) {
				this.borderAdjust = borderAdjustDim;
			} else if (resetStyle) {
				this.borderAdjust = null;
			}
		//#endif

		//#if polish.css.filter && polish.midp2
		if (this.filters != null) {
			boolean isActive = false;
			for (int i=0; i<this.filters.length; i++) {
				RgbFilter filter = this.filters[i];
				filter.setStyle(style, resetStyle);
				isActive |= filter.isActive();
			}
			this.isFiltersActive = isActive;
			this.filterRgbImage = null;
		}
		//#endif
			
		//#if polish.css.animations
		if (!resetStyle) {
			//#ifdef polish.css.view-type
				if (this.view != null) {
					this.view.setStyle(style, resetStyle);
				}
			//#endif
			if (this.background != null) {
				this.background.setStyle(style);
			}
			if (this.border != null) {
				this.border.setStyle(style);
			}
		}
		//#endif
	}

	/**
	 * Retrieves the complete width of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a StringItem gets a new text.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param availWidth the maximum visible width of any following lines
	 * @return the complete width of this item.
	 */
	public int getItemWidth( int firstLineWidth, int availWidth) {
		return getItemWidth(firstLineWidth, availWidth, this.availableHeight);
	}

	
	/**
	 * Retrieves the complete width of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a StringItem gets a new text.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param availWidth the maximum visible width of any following lines
	 * @param availHeight the maximum visible height, -1 if unknown
	 * @return the complete width of this item.
	 */
	public int getItemWidth( int firstLineWidth, int availWidth, int availHeight ) {
		if (!isInitialized() || this.availableWidth != availWidth || this.availableHeight != availHeight  ) {
			init( firstLineWidth, availWidth, availHeight );
		}
		return this.itemWidth;
	}
	
	/**
	 * Retrieves the complete height of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a new style is set.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param availWidth the maximum visible width of any following lines
	 * @return the complete heigth of this item.
	 */
	public int getItemHeight( int firstLineWidth, int availWidth) {
		return getItemHeight(firstLineWidth, availWidth, this.availableHeight);
	}

	/**
	 * Retrieves the complete height of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a new style is set.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param availWidth the maximum visible width of any following lines
	 * @param availHeight the maximum visible height, -1 if unknown
	 * @return the complete heigth of this item.
	 */
	public int getItemHeight( int firstLineWidth, int availWidth, int availHeight ) {
		if (!isInitialized() || this.availableWidth != availWidth || this.availableHeight != availHeight  ) {
			init( firstLineWidth, availWidth, availHeight );
		}
		return this.itemHeight;
	}
	
	//#if polish.LibraryBuild
		/**
		 * Adds a command to this item
		 * 
		 * @param cmd the command
		 */
		public void addCommand(javax.microedition.lcdui.Command cmd) {
			// ignore
		}
	//#endif


	/**
	 * Adds a context sensitive <code>Command</code> to the item.
	 * The semantic type of
	 * <code>Command</code> should be <code>ITEM</code>. The implementation
	 * will present the command
	 * only when the item is active, for example, highlighted.
	 * <p>
	 * If the added command is already in the item (tested by comparing the
	 * object references), the method has no effect. If the item is
	 * actually visible on the display, and this call affects the set of
	 * visible commands, the implementation should update the display as soon
	 * as it is feasible to do so.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be added
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @throws NullPointerException if cmd is null
	 * @since  MIDP 2.0
	 */
	public void addCommand( Command cmd) {
		addCommand( cmd, null );
	}
	
	/**
	 * Adds a context sensitive <code>Command</code> to the item.
	 * The semantic type of
	 * <code>Command</code> should be <code>ITEM</code>. The implementation
	 * will present the command
	 * only when the item is active, for example, highlighted.
	 * <p>
	 * If the added command is already in the item (tested by comparing the
	 * object references), the method has no effect. If the item is
	 * actually visible on the display, and this call affects the set of
	 * visible commands, the implementation should update the display as soon
	 * as it is feasible to do so.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be added
	 * @param commandStyle the style of the command, for the moment this is ignored
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @throws NullPointerException if cmd is null
	 * @since  MIDP 2.0
	 */
	public void addCommand( Command cmd, Style commandStyle )
	{
		if (this.commands == null) {
			this.commands = new ArrayList();
		}
		if (!this.commands.contains( cmd )) {
			this.commands.add(cmd);
			//#if tmp.invisible
				if (this.isInvisible) {
					if (this.invisibleAppearanceModeCache == PLAIN) {
						this.invisibleAppearanceModeCache = HYPERLINK;
					}
				} else {
			//#endif
					if (this.appearanceMode == PLAIN) {
						this.appearanceMode = HYPERLINK;
					}
			//#if tmp.invisible
				}
			//#endif
			if (this.isFocused) {
				showCommands();
//				Screen scr = getScreen();
//				if (scr != null) {
//					scr.addCommand( cmd );
//				}
			}
			//#if polish.Item.ShowCommandsOnHold
				this.commandsContainer = null;
			//#endif
			if (this.isInitialized) {
				repaint();
			}
		}
	}
	
	/**
	 * Removes the context sensitive command from item. If the command is not
	 * in the <code>Item</code> (tested by comparing the object references),
	 * the method has
	 * no effect. If the <code>Item</code> is actually visible on the display,
	 * and this  call
	 * affects the set of visible commands, the implementation should update
	 * the display as soon as it is feasible to do so.
	 * 
	 * 
	 * If the command to be removed happens to be the default command,
	 * the command is removed and the default command on this Item is
	 * set to <code>null</code>.
	 * 
	 * The following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * is equivalent to the following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.setDefaultCommand(null);
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * 
	 * @param cmd - the command to be removed
	 * @since  MIDP 2.0
	 */
	public void removeCommand( Command cmd ) {
		if (this.commands != null) {
			if (cmd == this.defaultCommand) {
				this.defaultCommand = null;
			}
			if (this.commands.remove(cmd)) {
				if (this.isFocused) {
					Screen scr = getScreen();
					if (scr != null) {
						scr.removeCommand( cmd );
					}
				}
				//#if polish.Item.ShowCommandsOnHold
					this.commandsContainer = null;
				//#endif
				if (this.isInitialized) {
					repaint();
				}
			}
		}
	}

	/**
	 * Repaints the complete screen to which this item belongs to.
	 * Subclasses can call this method whenever their contents
	 * have changed and they need an immediate refresh.
	 *  
	 * @see #repaint()
	 * @see #repaint(int, int, int, int)
	 */
	protected void repaintFully() {
		//repaint( this.relativeX, this.relativeY, this.itemWidth, this.itemHeight );
		//if (this.parent instanceof Container) {
		//	((Container) this.parent).isInitialized = false;
		//}
		Screen scr = getScreen();
		if (scr != null && scr == StyleSheet.currentScreen) {
			scr.requestRepaint();
		}
	}
	
	/**
	 * Repaints the screen to which this item belongs to depending on the isInitialized field
	 * When this item is initialized, only the area covered by this item is repainted (unless other repaint requests are queued).
	 * When this item is not initialized (isInitialized == false), a repaint for the complete screen is triggered, as there might be
	 * a size change involved.
	 * Subclasses can call this method whenever their contents have changed and they need an immediate refresh.
	 * 
	 * @see #isInitialized 
	 * @see #repaintFully()
	 * @see #repaint(int, int, int, int)
	 */
	protected void repaint() {
		if (this.ignoreRepaintRequests) {
			return;
		}
		//#if tmp.invisible
			if (this.isInvisible) {
				return;
			}
		//#endif
		//#if polish.Bugs.fullRepaintRequired
			repaintFully();
		//#else
			//System.out.println("repaint(): " + this.relativeX + ", " + this.relativeY + ", " + this.itemWidth + ", " + this.itemHeight);
			if (this.isInitialized) {
				// note: -contentX, -contentY fails for right or center layouts
				repaint( - (this.paddingLeft + this.marginLeft + getBorderWidthLeft()), -(this.paddingTop + this.marginTop + getBorderWidthTop()), this.itemWidth, this.itemHeight );
			} else {
				repaintFully();
			}
		//#endif
	}
	
	/**
	 * Retrieves the border width.
	 * 
	 * @return the border for the left side in pixels
	 */
	protected int getBorderWidthLeft()
	{
		if (this.border != null) {
			return this.border.borderWidthLeft;
		}
		if (this.background != null) {
			return this.background.borderWidth;
		}
		return 0;
	}
	
	/**
	 * Retrieves the border width.
	 * 
	 * @return the border for the right side in pixels
	 */
	protected int getBorderWidthRight()
	{
		if (this.border != null) {
			return this.border.borderWidthRight;
		}
		if (this.background != null) {
			return this.background.borderWidth;
		}
		return 0;
	}
	
	/**
	 * Retrieves the border width.
	 * 
	 * @return the border for the top side in pixels
	 */
	protected int getBorderWidthTop()
	{
		if (this.border != null) {
			return this.border.borderWidthTop;
		}
		if (this.background != null) {
			return this.background.borderWidth;
		}
		return 0;
	}
	
	/**
	 * Retrieves the border width.
	 * 
	 * @return the border for the bottom side in pixels
	 */
	protected int getBorderWidthBottom()
	{
		if (this.border != null) {
			return this.border.borderWidthBottom;
		}
		if (this.background != null) {
			return this.background.borderWidth;
		}
		return 0;
	}



	/**
	 * Repaints the specified relative area of this item.
	 * The area is specified relative to the <code>Item's</code>
	 * content area.
	 * 
	 * @param relX horizontal start position relative to this item's content area
	 * @param relY vertical start position relative to this item's content area
	 * @param width the width of the area
	 * @param height the height of the area
	 * 
	 * @see #repaint()
	 * @see #repaintFully()
	 */
	protected void repaint( int relX, int relY, int width, int height ) {
		//System.out.println("repaint called by class " + getClass().getName() );
//		if (this.parent instanceof Container) {
//			((Container) this.parent).isInitialized = false;
//		}
		Screen scr = getScreen();
		// rickyn: Removed second test to correct dropped redraw requests for screens within a tabbedPane
		if (scr != null/* && scr == StyleSheet.currentScreen*/) {
			relX += getAbsoluteX(); // + this.contentX;
			relY += getAbsoluteY(); // + this.contentY;
			//System.out.println("item.repaint(" + relX + ", " + relY+ ", " +  width + ", " +  height + ")  for " + this );
			scr.requestRepaint( relX, relY, width, height + 1 );
		}
	}

	
	/**
	 * Requests that this item and all its parents are to be re-initialised, if the size of this item has been changed.
	 * All parents of this item are notified, too.
	 * This method should be called when an item changes its size more than usual.
	 */
	public void requestInit() {
		if (this.isInitialized) {
			setInitialized(false);
			Item p = this.parent; 
            while ( p != null) {
                p.setInitialized( false );
                p = p.parent;
            }
            Screen scr = getScreen();
            if (scr != null) {
                scr.requestInit();
            }
            if (this.isShown) {
                repaint();
            }
		}
	}
	
	/**
	 * Retrieves the screen to which this item belongs to.
	 * 
	 * @return either the corresponding screen or null when no screen could be found 
	 */
	public Screen getScreen() {
		Item p = this;
		while (p != null) {
			if (p.screen != null) {
				return p.screen;
			}
			p = p.parent;
		}
		return null;
	}

	/**
	 * Sets a listener for <code>Commands</code> to this <code>Item</code>,
	 * replacing any previous
	 * <code>ItemCommandListener</code>. A <code>null</code> reference
	 * is allowed and has the effect of removing any existing listener.
	 * 
	 * When no listener is registered, J2ME Polish notifies the 
	 * command-listener of the current screen, when an item command 
	 * has been selected.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param l the new listener, or null.
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setItemCommandListener( ItemCommandListener l)
	{
		this.itemCommandListener = l;
	}
	
	//#if polish.LibraryBuild
	/**
	 * Sets a listener for <code>Commands</code> to this <code>Item</code>,
	 * replacing any previous
	 * <code>ItemCommandListener</code>. A <code>null</code> reference
	 * is allowed and has the effect of removing any existing listener.
	 * 
	 * When no listener is registered, J2ME Polish notifies the 
	 * command-listener of the current screen, when an item command 
	 * has been selected.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param l the new listener, or null.
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setItemCommandListener( javax.microedition.lcdui.ItemCommandListener l)
	{
		// ignore
	}
	//#endif
	
	/**
	 * Gets the listener for <code>Commands</code> to this <code>Item</code>.
	 * 
	 * When no listener is registered, null is returned
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @return the ItemCommandListener associated with this item
	 */
	public ItemCommandListener getItemCommandListener()
	{
		return this.itemCommandListener;
	}
	
	/**
	 * Sets an ItemStateListener specifically for this item.
	 * Change events are forwarded to both this listener as well as a possibly set listener of the
	 * corresponding screen.
	 * 
	 * @param listener the listener which is set specifically for this item.
	 */
	public void setItemStateListener(ItemStateListener listener ) {
		this.itemStateListener = listener;
	}
	
	/**
	 * Gets an ItemStateListener specifically for this item.
	 * Change events are forwarded to both this listener as well as a possibly set listener of the
	 * corresponding screen.
	 * 
	 * @return the listener which has been set specifically for this item.
	 */
	public ItemStateListener getItemStateListener() {
		return this.itemStateListener;
	}

	/**
	 * Gets the preferred width of this <code>Item</code>.
	 * If the application has locked
	 * the width to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred height
	 * if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred width of the Item
	 * @see #getpreferredHeight()
	 * @see #setpreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getpreferredWidth()
	{
		return this.preferredWidth;
	}

	/**
	 * Gets the preferred height of this <code>Item</code>.
	 * If the application has locked
	 * the height to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred
	 * width if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred height of the Item
	 * @see #getpreferredWidth()
	 * @see #setpreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getpreferredHeight()
	{
		return this.preferredHeight;
	}

	/**
	 * Sets the preferred width and height for this <code>Item</code>.
	 * Values for width and height less than <code>-1</code> are illegal.
	 * If the width is between zero and the minimum width, inclusive,
	 * the minimum width is used instead.
	 * If the height is between zero and the minimum height, inclusive,
	 * the minimum height is used instead.
	 * 
	 * <p>Supplying a width or height value greater than the minimum width or
	 * height <em>locks</em> that dimension to the supplied
	 * value.  The implementation may silently enforce a maximum dimension for
	 * an <code>Item</code> based on factors such as the screen size.
	 * Supplying a value of
	 * <code>-1</code> for the width or height unlocks that dimension.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.</p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param width - the value to which the width should be locked, or -1 to unlock
	 * @param height - the value to which the height should be locked, or -1 to unlock
	 * @throws IllegalArgumentException - if width or height is less than -1
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getpreferredHeight()
	 * @see #getpreferredWidth()
	 * @since  MIDP 2.0
	 */
	public void setpreferredSize(int width, int height)
	{
		this.preferredHeight = height;
		this.preferredWidth = width;
	}

	/**
	 * Gets the minimum width for this <code>Item</code>.  This is a width
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum width of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumWidth()
	{
		return getMinimumWidth(100);
	}
	
	/**
	 * Gets the minimum width for this <code>Item</code>.  
	 *
	 * @param availWidth the available width for percentage calculations
	 * @return the minimum width of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumWidth(int availWidth) {
		if (this.minimumWidth != null) {
			return this.minimumWidth.getValue(availWidth);
		} else {
			return 0;
		}
	}

	/**
	 * Gets the minimum height for this <code>Item</code>.  This is a height
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumHeight()
	{
		return getMinimumHeight(100);
	}
	
	/**
	 * Gets the minimum height for this <code>Item</code>.  
	 * 
	 * @param availHeight the available height for percentage calculations
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumHeight(int availHeight)
	{
		if (this.minimumHeight != null) {
			return this.minimumHeight.getValue(availHeight);
		} else {
			return 0;
		}
	}
	

	
	//#if polish.css.max-width
	/**
	 * Gets the maximum width for this <code>Item</code>.  This is a height
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMaximumWidth()
	{
		return getMaximumWidth(100);
	}
	
	/**
	 * Gets the maximum width for this <code>Item</code>.  
	 * 
	 * @param availWidth the available height for percentage calculations
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMaximumWidth(int availWidth)
	{
		if (this.maximumWidth != null) {
			return this.maximumWidth.getValue(availWidth);
		} else {
			return 0;
		}
	}
	//#endif
	
	//#if polish.css.max-height
	/**
	 * Gets the maximum height for this <code>Item</code>.  This is a height
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMaximumHeight()
	{
		return getMaximumHeight(100);
	}
	
	/**
	 * Gets the maximum height for this <code>Item</code>.  
	 * 
	 * @param availHeight the available height for percentage calculations
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMaximumHeight(int availHeight)
	{
		if (this.maximumHeight != null) {
			return this.maximumHeight.getValue(availHeight);
		} else {
			return 0;
		}
	}
	//#endif

	/**
	 * Sets default <code>Command</code> for this <code>Item</code>.
	 * If the <code>Item</code> previously had a
	 * default <code>Command</code>, that <code>Command</code>
	 * is no longer the default, but it
	 * remains present on the <code>Item</code>.
	 * 
	 * <p>If not <code>null</code>, the <code>Command</code> object
	 * passed becomes the default <code>Command</code>
	 * for this <code>Item</code>.  If the <code>Command</code> object
	 * passed is not currently present
	 * on this <code>Item</code>, it is added as if <A HREF="../../../javax/microedition/lcdui/Item.html#addCommand(javax.microedition.lcdui.Command)"><CODE>addCommand(javax.microedition.lcdui.Command)</CODE></A>
	 * had been called
	 * before it is made the default <code>Command</code>, unless the &quot;polish.Item.suppressDefaultCommand&quot; preprocessing variable is set to &quot;true&quot;.</p>
	 * 
	 * <p>If <code>null</code> is passed, the <code>Item</code> is set to
	 * have no default <code>Command</code>.
	 * The previous default <code>Command</code>, if any, remains present
	 * on the <code>Item</code>.
	 * </p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be used as this Item's default Command, or null if there is to be no default command
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setDefaultCommand( Command cmd)
	{
		//#debug
		System.out.println("set default command " + cmd.getLabel() + " for " + this);
		//#if !polish.Item.suppressDefaultCommand
			if (this.defaultCommand != null && cmd != this.defaultCommand) {
				addCommand(this.defaultCommand);
			}
		//#endif		
		this.defaultCommand = cmd;
		//#if !polish.Item.suppressDefaultCommand
			if (cmd != null) {
				addCommand(cmd);
			}
		//#else
			if (cmd != null && this.appearanceMode == PLAIN) {
				this.appearanceMode = INTERACTIVE;
			}
		//#endif
		if (this.isFocused) 
		{
			Screen scr = getScreen();
			if(scr != null)
				scr.notifyDefaultCommand( cmd );
		}
	}
	
	//#if polish.LibraryBuild
	/**
	 * Sets default <code>Command</code> for this <code>Item</code>.
	 * @param cmd the command to be used as this Item's default Command, or null if there is to be no default command
	 */
	public void setDefaultCommand( javax.microedition.lcdui.Command cmd)
	{
		// ignore
	}
	//#endif

	/**
	 * Causes this <code>Item's</code> containing <code>Form</code> to notify
	 * the <code>Item's</code> <CODE>ItemStateListener</CODE>.
	 * The application calls this method to inform the
	 * listener on the <code>Item</code> that the <code>Item's</code>
	 * state has been changed in
	 * response to an action.  Even though this method simply causes a call
	 * to another part of the application, this mechanism is useful for
	 * decoupling the implementation of an <code>Item</code> (in particular, the
	 * implementation of a <code>CustomItem</code>, though this also applies to
	 * subclasses of other items) from the consumer of the item.
	 * 
	 * <p>If an edit was performed by invoking a separate screen, and the
	 * editor now wishes to &quot;return&quot; to the form which contained the
	 * selected <code>Item</code>, the preferred method is
	 * <code>Display.setCurrent(Item)</code>
	 * instead of <code>Display.setCurrent(Displayable)</code>,
	 * because it allows the
	 * <code>Form</code> to restore focus to the <code>Item</code>
	 * that initially invoked the editor.</p>
	 * 
	 * <p>In order to make sure that the documented behavior of
	 * <code>ItemStateListener</code> is maintained, it is up to the caller
	 * (application) to guarantee that this function is
	 * not called unless:</p>
	 * 
	 * <ul>
	 * <li>the <code>Item's</code> value has actually been changed, and</li>
	 * <li>the change was the result of a user action (an &quot;edit&quot;)
	 * and NOT as a result of state change via calls to
	 * <code>Item's</code> APIs </li>
	 * </ul>
	 * 
	 * <p>The call to <code>ItemStateListener.itemStateChanged</code>
	 * may be delayed in order to be serialized with the event stream.
	 * The <code>notifyStateChanged</code> method does not block awaiting
	 * the completion of the <code>itemStateChanged</code> method.</p>
	 * 
	 * @throws IllegalStateException if the Item is not owned by a Form
	 * @since  MIDP 2.0
	 */
	public void notifyStateChanged()
	{
		if (this.itemStateListener != null) {
			try {
				this.itemStateListener.itemStateChanged( this );
				return;
			} catch (Exception e) {
				//#debug error
				System.out.println("Unable to forward ItemStateChanged event to listener " + this.itemStateListener + e );
			}
		}
		Screen scr = StyleSheet.currentScreen;
		if (scr == null) {
			scr = getScreen();
		}
		if (scr != null) {
			scr.notifyStateListener(this);
		}
	}
	
	/**
	 * Notifies this item about a change event, e.g. when the text of a StringItem has been changed or similar.
	 * In contrast to notifyStateChanged() this method is also called when the change is not user initiated, i.e. when
	 * the application itself changes the value.
	 * The default implementation notfies native UI items about the change and fires an Event when either CSS animations are used 
	 * or when the preprocessing variable <code>polish.handleEvents</code> is set to <code>true</code>.
	 * @param newValue the changed value of this object
	 * @see #notifyStateChanged()
	 */
	protected void notifyValueChanged(Object newValue) {
		//#if polish.useNativeGui
			if (this.nativeItem != null) {
				this.nativeItem.notifyValueChanged(this, newValue);
			}
		//#endif
		//#if tmp.handleEvents
			EventManager.fireEvent( EventManager.EVENT_VALUE_CHANGE, this, newValue); 
		//#endif
	}

	
	void setAvailableDimensions(int leftBorder, int rightBorder)
	{
		int w = rightBorder - leftBorder;
		int h = 0;
		Item p = this.parent;
		if (p != null) {
			while (p != null && (w < 1 || h < 1)) {
				if (p.contentWidth != 0) {
					if (h < 1) {
						h = Math.min( p.contentHeight, p.availableHeight );
					}
					if (w < 1) {
						w = Math.min( p.contentWidth, p.availableWidth );
					}
				} else {
					if (h < 1) {
						h = p.availableHeight;
					}
					if (w < 1) {
						w = p.availableWidth;
					}
				}
				p = p.parent;
			}
		} else {
			Screen scr = getScreen();
			if (scr != null){
				h = scr.contentHeight;
				if (w < 1) {
					w = scr.contentWidth;
				}
			}
		}
		this.availableWidth = w;
		this.availableHeight = h;
	}
	
	/**
	 * Paints this item on the screen.
	 * This method should normally not be overriden. Override it
	 * only when you know what you are doing!
	 * 
	 * @param x the left start position of this item.
	 * @param y the top start position of this item.
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position,
	 * 		  rightBorder > x >= leftBorder
	 * @param g the Graphics on which this item should be painted.
	 */
	public void paint( int x, int y, int leftBorder, int rightBorder, Graphics g ) {
		//#if tmp.invisible
			if (this.isInvisible) {
				return;
			}
		//#endif
			

//			Item p = this.parent; xxx
//			String start = "";
//			while (p != null) {
//				start += " ";
//				p = p.parent;
//			}
//			System.out.println(start + "paint at x=" + x + ", contentX=" + this.contentX + ", leftBorder=" + leftBorder +", rightBorder=" + rightBorder + " of "  + this);
			
		//#debug ovidiu
		Benchmark.startSmartTimer("0");
			
		// initialise this item if necessary:
		if (!this.isInitialized) {
			if (this.availableWidth == 0) {
				setAvailableDimensions(leftBorder, rightBorder);
			}
			
			int previousItemWidth = this.itemWidth;
			int previousItemHeight = this.itemHeight;
			
			init(this.availableWidth, this.availableWidth, this.availableHeight);
			
            if (this.itemHeight < previousItemHeight && this.isLayoutVerticalExpand()) {
                setItemHeight( previousItemHeight );
            }
			
			if ((previousItemWidth != this.itemWidth || previousItemHeight != this.itemHeight) && this.parent != null)
			{
				this.parent.requestInit();
			}
		}
		
		//#if polish.css.x-adjust
			if (this.xAdjustment != null) {
				int value = this.xAdjustment.getValue(this.itemWidth);
				x += value;
				leftBorder += value;
				rightBorder += value;
			}
		//#endif
		//#if polish.css.y-adjust
			if (this.yAdjustment != null) {
				y += this.yAdjustment.getValue(this.itemHeight);
			}
		//#endif
		int origX = x;
		int origY = y;
			
		//#if polish.css.filter && polish.midp2
			if (this.isFiltersActive && this.filters != null && !this.filterPaintNormally) {

				RgbImage rgbImage = this.filterRgbImage;

                                // Do not use the cached item image.
                                // Used for real-time dynamic objects
                                // suct as ProcessingItem
                                if ( !this.cacheItemImage )
                                {
                                  rgbImage = null ;
                                }
                                
				if ( (rgbImage == null) ) {
					this.filterPaintNormally = true;
					int[] rgbData = UiAccess.getRgbData( this );
					rgbImage = new RgbImage( rgbData, this.itemWidth);
					this.filterRgbImage = rgbImage;
					this.filterPaintNormally = false;
				} 
				//System.out.println("painting RGB data for " + this  + ", pixel=" + Integer.toHexString( rgbData[ rgbData.length / 2 ]));		
				this.filterProcessedRgbImage = paintFilter(x, y, this.filters, rgbImage, this.layout, g);
                if ( (this.filterProcessedRgbImage.getWidth() != this.itemWidth ) || ( this.filterProcessedRgbImage.getHeight() != this.itemHeight) )
                {
                    repaint(0, 0, this.filterProcessedRgbImage.getWidth(), this.filterProcessedRgbImage.getHeight());
                }
//				for (int i=0; i<this.filters.length; i++) {
//					RgbFilter filter = this.filters[i];
//					rgbImage = filter.process(rgbImage);
//				}				
//				
//				int width = rgbImage.getWidth();
//				int height = rgbImage.getHeight();
//				int[] rgbData = rgbImage.getRgbData();
//				if (this.isLayoutRight) {
//					x = rightBorder - width;
//				} else if (this.isLayoutCenter) {
//					x =  leftBorder + ((rightBorder - leftBorder)/2) - (width/2);
//				}
//				DrawUtil.drawRgb(rgbData, x, y, width, height, true, g );
//				
				//#mdebug ovidiu
				Benchmark.pauseSmartTimer("0");
				Benchmark.incrementSmartTimer("1");
				Benchmark.check();
				//#enddebug
				//#if polish.Item.ShowCommandsOnHold
					if (this.isShowCommands) {
						paintCommands( origX, origY, g );
					}
				//#endif
				return;
			}
		//#endif

		//#if polish.css.opacity && polish.midp2
			if (this.opacity != 255 && !this.opacityPaintNormally) {
				if (this.opacity == 0) {
					return;
				}
				int[] rgbData = this.opacityRgbData;
				if ( rgbData == null || this.opacity != this.opacityAtGeneration ) {
					this.opacityPaintNormally = true;
					rgbData = UiAccess.getRgbData( this, this.opacity );
					this.opacityRgbData = rgbData;
					this.opacityPaintNormally = false;
					this.opacityAtGeneration = this.opacity;
				} 
				//System.out.println("painting RGB data for " + this  + ", pixel=" + Integer.toHexString( rgbData[ rgbData.length / 2 ]));
				DrawUtil.drawRgb(rgbData, x, y, this.itemWidth, this.itemHeight, true, g );
				//#if polish.Item.ShowCommandsOnHold
					if (this.isShowCommands) {
						paintCommands( origX, origY, g );
					}
				//#endif
				return;
			}
		//#endif
	
		
		//boolean isLayoutShrink = (this.layout & LAYOUT_SHRINK) == LAYOUT_SHRINK;

		// paint background and border when the label should be included in this:
		//#if polish.css.include-label
			if (this.includeLabel) {
				int width = this.itemWidth - this.marginLeft - this.marginRight;
				int height = this.itemHeight - this.marginTop - this.marginBottom;
				int bX = x + this.marginLeft;
				int bY = y + this.marginTop + this.backgroundYOffset;
				paintBackgroundAndBorder( bX, bY, width, height, g );
			}
		//#endif
		//#if polish.css.complete-background || polish.css.complete-border
			int cbPadding = this.completeBackground == null ? 0 : this.completeBackgroundPadding.getValue(this.availContentWidth);
			int width = this.itemWidth - this.marginLeft - this.marginRight + (cbPadding << 1);
			int height = this.itemHeight - this.marginTop - this.marginBottom + (cbPadding << 1);
			int bX = x + this.marginLeft - cbPadding;
			int bY = y + this.marginTop + this.backgroundYOffset - cbPadding;
			//#if polish.css.complete-background
				if (this.completeBackground != null) {
					this.completeBackground.paint(bX, bY, width, height, g);
				}
			//#endif
			//#if polish.css.complete-border
				if (this.completeBorder!= null) {
					this.completeBorder.paint(bX, bY, width, height, g);
				}
			//#endif
		//#endif
		
		// paint label:
		StringItem labelItem = this.label;
		if (labelItem != null) {
            int labelX = x + labelItem.relativeX;
            labelItem.paint(labelX, y + labelItem.relativeY, labelX, labelX + labelItem.itemWidth, g );
            if (this.useSingleRow) {
                leftBorder += labelItem.itemWidth;
            } else {
                y += labelItem.itemHeight;
            }
		}
		
		leftBorder += (this.marginLeft + getBorderWidthLeft() + this.paddingLeft);
		//#ifdef polish.css.before
			leftBorder += getBeforeWidthWithPadding();
		//#endif
		//System.out.println( this.style.name + ":  increasing leftBorder by " + (this.marginLeft + this.borderWidth + this.paddingLeft));
		rightBorder -= (this.marginRight + getBorderWidthRight() + this.paddingRight);
		//#ifdef polish.css.after
			rightBorder -= getAfterWidthWithPadding();
		//#endif
			
		//System.out.println( this.style.name + ":  decreasing rightBorder by " + (this.marginRight + this.borderWidth + this.paddingRight));
//		if ( this.isLayoutCenter  && availWidth > this.itemWidth) {
//			int difference = (availWidth - this.itemWidth) >> 1;
//			System.out.println("increasing x from " + x + " to " + (x + difference) + ", availableWidth=" + this.availableWidth + ", availWidth=" + availWidth + ", itemWidth=" + this.itemWidth);
//			x += difference;
//			if (!this.isLayoutExpand) {
//				leftBorder += difference;
//				rightBorder -= difference;
//				//System.out.println("item " + this + ": (center) shrinking left border to " + leftBorder + ", right border to " + rightBorder);
//			}
//		} else if ( this.isLayoutRight && availWidth > this.itemWidth) {
//			// adjust the x-position so that the item is painted up to
//			// the right border (when it starts at x):
//			x += availWidth - this.itemWidth;
//			if (!this.isLayoutExpand) {
//				leftBorder += availWidth - this.itemWidth;
//				//System.out.println("item " + this + ": (right) shrinking left border to " + leftBorder);
//			}
//		} else if (isLayoutShrink && availWidth > this.itemWidth) {
//			rightBorder -= availWidth - this.itemWidth;
//			//System.out.println("item " + this + ": (left) shrinking right border to " + rightBorder);
//		}
		
		
		x += this.marginLeft;
		y += this.marginTop;
		// paint background and border:
		//#if polish.css.include-label
			if (!this.includeLabel) {
		//#endif
				int backgroundX = x;
				if (labelItem != null && this.useSingleRow) { 
					backgroundX += labelItem.itemWidth;
				}
				paintBackgroundAndBorder(backgroundX, y, this.backgroundWidth, this.backgroundHeight, g);
		//#if polish.css.include-label
			}
		//#endif

		//#if polish.css.content-x-adjust
			if (this.contentXAdjustment != null) {
				x += this.contentXAdjustment.getValue(this.contentWidth);
			}
		//#endif
		//#if polish.css.content-y-adjust
			if (this.contentYAdjustment != null) {
				y += this.contentYAdjustment.getValue(this.contentHeight);
			}
		//#endif
		x += this.contentX - this.marginLeft; //getBorderWidthLeft() + this.paddingLeft;
		y += this.contentY - this.marginTop; //getBorderWidthTop() + this.paddingTop;
		if (labelItem != null && !this.useSingleRow) {
			y -= labelItem.itemHeight;
		}
		int originalContentY = y;
		
		// paint before element:
		//#if polish.css.before || polish.css.after || polish.css.min-height  || polish.css.max-height
			boolean isVerticalCenter = (this.layout & LAYOUT_VCENTER) == LAYOUT_VCENTER; 
			boolean isTop = !isVerticalCenter && (this.layout & LAYOUT_TOP) == LAYOUT_TOP; 
			boolean isBottom = !isVerticalCenter && (this.layout & LAYOUT_BOTTOM) == LAYOUT_BOTTOM;
		//#endif
		//#ifdef polish.css.before
			if (this.beforeImage != null) {
				int beforeX = origX + getBorderWidthLeft() + this.paddingLeft + this.marginLeft;
				if (labelItem != null && this.useSingleRow) {
					beforeX += labelItem.itemWidth;
				}
				int beforeY = y;
				int yAdjust = this.beforeHeight - this.contentHeight;
				if ( this.beforeHeight < this.contentHeight) {
					if (isTop) {
						//beforeY -= yAdjust;
					} else if (isBottom) {
						beforeY += yAdjust;
					} else {
						beforeY -= (yAdjust >> 1);
					}
				} else {
					if (isTop) {
						// keep contY
					} else if (isBottom) {
						y += yAdjust;
					} else {
						y += (yAdjust >> 1);
					}
					//contY += (this.beforeHeight - this.contentHeight) / 2;
				}
				
				if(this.isLayoutRight)
				{
					beforeX = rightBorder - (this.contentWidth + this.beforeWidth);
				}
				//System.out.println("drawing before at " + beforeX + ", contentX=" + this.contentX + ", this=" + this);
				g.drawImage(this.beforeImage, beforeX, beforeY, Graphics.TOP | Graphics.LEFT );
				x += getBeforeWidthWithPadding();
			}
		//#endif
		
		// paint after element:
		//#ifdef polish.css.after
			if (this.afterImage != null) {
				int afterY = originalContentY;
				int yAdjust = this.afterHeight - this.contentHeight;
				if ( this.afterHeight < this.contentHeight) {
					if (isTop) {
						afterY -= yAdjust;
					} else if (isBottom) {
						afterY += yAdjust;
					} else {
						afterY -= (yAdjust >> 1);
					}
					//afterY += (this.contentHeight - this.afterHeight) / 2;
				} else {
					//#ifdef polish.css.before
					if (this.afterHeight > this.beforeHeight) {
					//#endif
						if (isTop) {
							// keep contY
						} else if (isBottom) {
							y = originalContentY + yAdjust;
						} else {
							y = originalContentY + (yAdjust >> 1);
						}
						//contY = originalContentY + (this.afterHeight - this.contentHeight) / 2;
					//#ifdef polish.css.before
					}
					//#endif
				}
				g.drawImage(this.afterImage, rightBorder + this.paddingHorizontal, afterY, Graphics.TOP | Graphics.LEFT );
			}
		//#endif
		
		//#if polish.css.content-visible
			if (!this.isContentVisible) {
				this.contentWidth = 0;
				this.contentHeight = 0;
			} else {
		//#endif
			// paint content:
			//#ifdef polish.css.view-type
				if (this.view != null) {
					this.view.paintContent( this, x, y, leftBorder, rightBorder, g);
				} else {
			//#endif
					paintContent( x, y, leftBorder, rightBorder, g );
			//#ifdef polish.css.view-type
				}
			//#endif
		//#if polish.css.content-visible
			}
		//#endif
			
//		if (this.parent != null) {
//			g.setColor(0x00ff00);
//			g.drawRect( this.parent.getAbsoluteX()  + this.parent.contentX + this.relativeX, this.parent.getAbsoluteY() + this.parent.contentY + this.relativeY, this.itemWidth, this.itemHeight);
//		}
		//#if polish.Item.ShowCommandsOnHold
			if (this.isShowCommands) {
				paintCommands( origX, origY, g );
			}
		//#endif
			
//			g.setColor(0xff0000);
//			g.drawRect( origX + this.contentX, origY + this.contentY, this.contentWidth, this.contentHeight );
//			g.drawLine( origX + this.contentX, origY + this.contentY, origX + this.contentX + this.contentWidth, origY + this.contentY + this.contentHeight );
//			g.setColor(0xffFF00);
//			g.drawRect( getAbsoluteX() + 1, getAbsoluteY() + 1, this.itemWidth - 2, this.itemHeight - 2);

	}
	
	/**
	 * Paints the commands for this item after the user has pressed/clicked on an item for a long time.
	 * Note that the preproessing variable polish.Item.ShowCommandsOnHold needs to be set to true for this feature.
	 * 
	 * @param x horizontal left start position
	 * @param y vertical top start position
	 * @param g the graphics context
	 */
	protected void paintCommands(int x, int y, Graphics g) {
		//#if polish.Item.ShowCommandsOnHold
			if (this.commandsContainer == null) {
				//#style itemcommands?
				this.commandsContainer = new Container(true);
				this.commandsContainer.parent = this;
				//#if polish.css.commands-style
					if (this.style != null) {
						Style commandsStyle = (Style) this.style.getObjectProperty("commands-style");
						if (commandsStyle != null) {
							this.commandsContainer.setStyle( commandsStyle );
						}
					}
				//#endif
				//#if polish.css.child-style
					Style childStyle = null;
					if (this.commandsContainer.style != null) {
						childStyle = (Style) this.commandsContainer.style.getObjectProperty("child-style");
					}
				//#endif
				
				Object[] commandsArr = this.commands.getInternalArray();
				for (int i = 0; i < commandsArr.length; i++) {
					Command cmd = (Command) commandsArr[i];
					if (cmd == null) {
						break;
					}
					CommandItem item = new CommandItem( cmd, this
							//#if polish.css.child-style
								, childStyle
							//#endif
					);
					this.commandsContainer.add(item);
				}
				this.commandsContainer.init( this.availableWidth, this.availableWidth, this.availableHeight );
				int relX = 0;
				if (this.commandsContainer.isLayoutRight()) {
					relX = this.availableWidth - this.commandsContainer.itemWidth;
				} else if (this.commandsContainer.isLayoutCenter()) {
					relX = (this.availableWidth - this.commandsContainer.itemWidth)/2;
				}
				this.commandsContainer.relativeX = relX;
				int relY = this.itemHeight;
				if (this.commandsContainer.isLayoutTop()) {
					relY = - this.commandsContainer.itemHeight;
				} else if (this.commandsContainer.isLayoutVerticalCenter()) {
					relY = (this.itemHeight - this.commandsContainer.itemHeight)/2;
				}
				int absY = getAbsoluteY();
				Screen scr = getScreen();
				int contY = scr.getScreenContentY();
				if (absY + relY < contY) {
					relY = contY - absY;
				} else if (absY + relY + this.commandsContainer.itemHeight > contY + scr.getScreenContentHeight()) {
					relY = contY + scr.getScreenContentHeight() - absY - this.commandsContainer.itemHeight;
				}
				this.commandsContainer.relativeY = relY;
			}
			x += this.commandsContainer.relativeX;
			this.commandsContainer.paint(x, y + this.commandsContainer.relativeY, x, x + this.commandsContainer.itemWidth, g);
		//#endif
		
	}

	/**
	 * Paints the background and border of this item.
	 * The call is forwarded to paintBackground() and paintBorder().
	 * 
	 * @param x the horizontal start position
	 * @param y the vertical start position
	 * @param width the width
	 * @param height the height
	 * @param g graphics context
	 * @see #paintBackground(int, int, int, int, Graphics)
	 * @see #paintBorder(int, int, int, int, Graphics)
	 */
	protected void paintBackgroundAndBorder(int x, int y, int width, int height, Graphics g) {
		//#if polish.css.background-anchor && (polish.css.background-width || polish.css.background-height)
			if (this.backgroundAnchor != 0) {
				//#if polish.css.background-width
				if (width != this.originalBackgroundWidth) {
					if ((Graphics.HCENTER & this.backgroundAnchor) == Graphics.HCENTER) { 
						x += (this.originalBackgroundWidth - width) / 2;
					} else if ((Graphics.RIGHT & this.backgroundAnchor) == Graphics.RIGHT) {
						x += (this.originalBackgroundWidth - width);
					}
				}
				//#endif
				//#if polish.css.background-height
				if (height != this.originalBackgroundHeight) {
					if ((Graphics.VCENTER & this.backgroundAnchor) == Graphics.VCENTER) { 
						y += (this.originalBackgroundHeight - height) / 2;
					} else if ((Graphics.BOTTOM & this.backgroundAnchor) == Graphics.BOTTOM) {
						y += (this.originalBackgroundHeight - height);
					}					
				}
				//#endif
			}
		//#endif
		
		if ( this.background != null ) {
			int bWidthL = 0;
			int bWidthR = 0;
			int bWidthT = 0;
			int bWidthB = 0;
			if ( this.border != null ) {
				bWidthL = getBorderWidthLeft();
				bWidthR = getBorderWidthRight();
				bWidthT = getBorderWidthTop();
				bWidthB = getBorderWidthBottom();
				
				x += bWidthL;
				y += bWidthT;
				width -= bWidthL + bWidthR;
				height -= bWidthT + bWidthB;
			}
			paintBackground(x, y, width, height, g);
			if (this.border != null) {
				x -= bWidthL;
				y -= bWidthT;
				width += bWidthL + bWidthR;
				height += bWidthT + bWidthB;
			}
		}
		if ( this.border != null ) {
			paintBorder( x, y, width, height, g );
		}
	}
	
	/**
	 * Paints the border of this item.
	 * 
	 * @param x the horizontal start position
	 * @param y the vertical start position
	 * @param width the width
	 * @param height the height
	 * @param g graphics context
	 */
	protected void paintBorder(int x, int y, int width, int height, Graphics g)
	{
		//#if polish.css.border-adjust
			if (this.borderAdjust != null) {
				int adjust = this.borderAdjust.getValue(this.availableWidth);
				x += adjust;
				y += adjust;
				adjust <<= 1;
				width -= adjust;
				height -= adjust;
			}
		//#endif
		//#if polish.css.view-type
			if (this.view != null) {
				this.view.paintBorder( this.border, x, y, width, height, g );
			} else {
		//#endif
				this.border.paint(x, y, width, height, g);
		//#if polish.css.view-type
			}
		//#endif
	}

	/**
	 * Paints the background and - if defined - the bgborder of this item.
	 * 
	 * @param x the horizontal start position
	 * @param y the vertical start position
	 * @param width the width
	 * @param height the height
	 * @param g graphics context
	 */
	protected void paintBackground( int x, int y, int width, int height, Graphics g ) {
		//#if polish.css.bgborder
			if (this.bgBorder != null) {
				int bgX = x - this.bgBorder.borderWidthLeft;
				int bgW = width + this.bgBorder.borderWidthLeft + this.bgBorder.borderWidthRight;
				int bgY = y - this.bgBorder.borderWidthTop;
				int bgH = height + this.bgBorder.borderWidthTop + this.bgBorder.borderWidthBottom;
				//#if polish.css.view-type
					if (this.view != null) {
						this.view.paintBorder( this.bgBorder, bgX, bgY, bgW, bgH, g );
					} else {
				//#endif
						this.bgBorder.paint(bgX, bgY, bgW, bgH, g);
				//#if polish.css.view-type
					}
				//#endif
			}
		//#endif
		//#if polish.css.view-type
			if (this.view != null) {
				this.view.paintBackground( this.background, x, y, width, height, g );
			} else {
		//#endif
				this.background.paint(x, y, width, height, g);
		//#if polish.css.view-type
			}
		//#endif
	}
	
	/**
	 * Paints the given filters and retrieves the last processed RGB image.
	 * @param x horizontal paint position
	 * @param y vertical paint position
	 * @param partFilters the filters
	 * @param rgbImage the initial RGB image
	 * @param lo the layout for the processed RGB image
	 * @param g the graphics context
	 * @return the processed RGB image
	 */
	protected RgbImage paintFilter(int x, int y, RgbFilter[] partFilters, RgbImage rgbImage, int lo, Graphics g) {
		//System.out.println("painting RGB data for " + this  + ", pixel=" + Integer.toHexString( rgbData[ rgbData.length / 2 ]));
		int origWidth = rgbImage.getWidth();
		int origHeight = rgbImage.getHeight();
		for (int i=0; i<partFilters.length; i++) {
			RgbFilter filter = partFilters[i];
			rgbImage = filter.process(rgbImage);
		}
		int width = rgbImage.getWidth();
		int height = rgbImage.getHeight();
		//System.out.println("Changed dimension from " + this.imageWidth +"x" + this.imageHeight + " to " + width + "x" + height);
		int[] rgb = rgbImage.getRgbData();
		if (origWidth != width) {
			if ((lo & LAYOUT_CENTER) == LAYOUT_CENTER) {
				x -= (width - origWidth) / 2;
			} else if ((lo & LAYOUT_CENTER) == LAYOUT_RIGHT) {
				x -= (width - origWidth);
			}
		}
		if (origHeight != height) {
			if ((lo & LAYOUT_VCENTER) == LAYOUT_VCENTER) {
				y -= (height - origHeight) / 2; 
			} else if ((lo & LAYOUT_VCENTER) == LAYOUT_TOP) {
				y -= (height - origHeight);
			}
		}
		DrawUtil.drawRgb(rgb, x , y, width, height, true, g );
		return rgbImage;
	}

	/**
	 * Initialises this item.
	 * You should always call super.init( firstLineWidth, lineWidth) when overriding this method.
	 * This method call either ItemView.initContent() or Item.initContent() to initialize the actual content.
	 * A valid case for overriding would be if additional initialization needs to be done even when an
	 * ItemView is associated with this Item. Usually implementing initContent() should suffice.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param availWidth the maximum width of any following lines
	 * @param availHeight the maximum height that can be used without scrolling
	 * @see #initContent(int, int, int)
	 * @see ItemView#initContent(Item, int, int, int)
	 */
	protected void init( int firstLineWidth, int availWidth, int availHeight ) {
		//#debug
		System.out.println("initialising item " + this + " with availWidth " + firstLineWidth + "/" + availWidth + ", height " + availHeight + " (was: " + this.availableWidth + ", " + this.availableHeight + ")" );
		this.availableWidth = availWidth;
		this.availableHeight = availHeight;
		//#if tmp.invisible
			if (this.isInvisible) {
				//#debug 
				System.out.println("init: Aborting init due to invisibility for item " + this );
				this.itemWidth = 0;
				this.itemHeight = 0;
				return;
			}
 		//#endif
			
		if (this.style != null && !this.isStyleInitialised) {
			setStyle( this.style );
		}
		//#ifdef polish.useDynamicStyles
			else if (this.style == null) {
				initStyle();
			}
		//#else
			else if (this.style == null && !this.isStyleInitialised) {
				//#debug
				System.out.println("Setting default style for item " + getClass().getName() );
				setStyle( StyleSheet.defaultStyle );
			}
		//#endif
		
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.parentItem = this;
			}
		//#endif
		
		Style myStyle = this.style;
		if (myStyle != null) {
			initLayout(myStyle, availWidth);
		}
		
		int labelWidth = 0;
		int labelHeight = 0;
		Item labelItem = this.label;
		if (labelItem != null) {
			labelWidth = labelItem.getItemWidth( firstLineWidth, availWidth, availHeight );
			labelHeight = labelItem.itemHeight;
		}
		// calculate content width and content height:
		int noneContentWidth =  
			 	this.marginLeft + getBorderWidthLeft() + this.paddingLeft 
				+ this.paddingRight + getBorderWidthRight() + this.marginRight;
		//#ifdef polish.css.before
			noneContentWidth += getBeforeWidthWithPadding();
		//#endif
		//#ifdef polish.css.after
			noneContentWidth += getAfterWidthWithPadding();
		//#endif
		
		int firstLineContentWidth = firstLineWidth - noneContentWidth;
		int availableContentWidth = availWidth - noneContentWidth;
		
		//#ifdef polish.css.max-width
			if (this.maximumWidth != null ) {
				int maxWidth = this.maximumWidth.getValue(availableContentWidth);
				if(firstLineContentWidth > maxWidth) {
					firstLineContentWidth = maxWidth;
				}
				if(availableContentWidth > maxWidth) {
					availableContentWidth = maxWidth;
				}
			}
		//#endif
			
		//#ifdef polish.css.width
			int targetWidth = 0;
			if (this.cssWidth != null) {
				availableContentWidth = this.cssWidth.getValue(availWidth - noneContentWidth);
				firstLineContentWidth = availableContentWidth;
				targetWidth = availableContentWidth;
			}
		//#endif
		
		//#ifdef polish.css.max-item-width
			if (this.maximumItemWidth != null && this.isLayoutExpand) {
				int maxWidth = this.maximumItemWidth.getValue(availWidth);
				if (availableContentWidth + noneContentWidth > maxWidth ) {
					availableContentWidth = maxWidth - noneContentWidth;
					if (firstLineContentWidth > availableContentWidth) {
						firstLineContentWidth = availableContentWidth;
					}
				}
			}
		//#endif

		this.contentX = this.marginLeft + getBorderWidthLeft() + this.paddingLeft;
		//#ifdef polish.css.before
			this.contentX += getBeforeWidthWithPadding();
		//#endif
		
		int noneContentHeight = this.marginTop + getBorderWidthTop() + this.paddingTop;
		this.contentY = noneContentHeight; 
		noneContentHeight += this.paddingBottom + getBorderWidthBottom() + this.marginBottom;
			
		//#ifdef polish.css.height
			int targetHeight = 0;
			if(this.cssHeight != null) {
				// according to css specs the base for the height calculation is the available width
				targetHeight = this.cssHeight.getValue(
						//#if polish.Item.useHeightInsteadOfWidth
							//# availHeight
						//#else
							availWidth
						//#endif
						);
				availHeight = targetHeight;
			}
		//#endif
			
		// initialise content by subclass:
		//#if polish.css.content-visible
			if (!this.isContentVisible) {
				this.contentWidth = 0;
				this.contentHeight = 0;
			} else {
		//#endif
			availHeight -= noneContentHeight;
			this.availContentWidth = availableContentWidth;
			this.availContentHeight = availHeight;
			//#if polish.css.inline-label
				if (this.isInlineLabel && labelWidth < (90 * availWidth)/100) {
					firstLineContentWidth -= labelWidth;
					availableContentWidth -= labelWidth;
				}
			//#endif
			//#ifdef polish.css.view-type
				ItemView myView = this.view;
				if (myView != null) {
					myView.init(this, firstLineContentWidth, availableContentWidth, availHeight);
					this.contentWidth = myView.contentWidth;
					this.contentHeight = myView.contentHeight;
				} else {
			//#endif
					initContent( firstLineContentWidth, availableContentWidth, availHeight );
			//#ifdef polish.css.view-type
				}
			//#endif
			//#if polish.css.inline-label
				if (this.isInlineLabel && labelWidth < (90 * availWidth)/100) {
					availableContentWidth += labelWidth;
				}
			//#endif
			
		//#if polish.css.content-visible
			}
		//#endif
			
		int cWidth = this.contentWidth;
		int cHeight = this.contentHeight;

		if (cWidth == 0 && cHeight == 0) {
			this.itemWidth = labelWidth;
			this.itemHeight = labelHeight;
			this.backgroundHeight = 0;
			this.backgroundWidth = 0;
			setInitialized(true);
			return;
		}
		if (cWidth > availableContentWidth) {
			cWidth = availableContentWidth;
		}
		
		//#ifdef polish.css.width
			if(this.cssWidth != null) {
				setContentWidth( targetWidth );
				int diff = this.contentWidth - cWidth;
				if (isLayoutCenter()) {
					this.contentX += diff/2;
				} else if (isLayoutRight()) {
					this.contentX += diff;
				}
				cWidth = this.contentWidth;
			}
		//#endif
			
		//#ifdef polish.css.min-width
			if (this.minimumWidth != null) {
				int minWidth = this.minimumWidth.getValue(availWidth - noneContentWidth);
				if (cWidth < minWidth ) {
					setContentWidth( minWidth );
					int diff = this.contentWidth - cWidth;
					if (isLayoutCenter()) {
						this.contentX += diff/2;
					} else if (isLayoutRight()) {
						this.contentX += diff;
					}
					cWidth = this.contentWidth;
				}
			}
		//#endif
		//#ifdef polish.css.max-width
			if (this.maximumWidth != null) {
				int maxWidth = this.maximumWidth.getValue(availWidth - noneContentWidth);
				if (cWidth > maxWidth ) {
					setContentWidth( maxWidth );
					cWidth = this.contentWidth;
				}
			}
		//#endif
			
		this.itemWidth = noneContentWidth + cWidth;
		
		//#ifdef polish.css.min-item-width
			if (this.minimumItemWidth != null) {
				if (this.itemWidth < this.minimumItemWidth.getValue(availWidth) ) {
					int minWidth = this.minimumItemWidth.getValue(availWidth);
					if (minWidth > availWidth) {
						minWidth = availWidth;
					}
					int diff = minWidth - this.itemWidth;
					setItemWidth( this.itemWidth + diff );
					setContentWidth( this.contentWidth + diff );
					cWidth = this.contentWidth;
				}
			}
		//#endif
		//#ifdef polish.css.max-item-width
			if (this.maximumItemWidth != null) {
				int maxWidth = this.maximumItemWidth.getValue(availWidth);
				if (this.itemWidth > maxWidth ) {
					int diff = maxWidth - this.itemWidth;
					this.itemWidth += diff;
					setContentWidth( this.contentWidth + diff );
					cWidth = this.contentWidth;
				}
			}
		//#endif
		
		if ( this.isLayoutExpand ) {
			if (cWidth < availableContentWidth) {
				int iWidth = this.itemWidth;
				if (
					//#if polish.css.max-width
						this.maximumWidth == null && 
					//#endif
					this.itemWidth + labelWidth <= availWidth && (this.label == null || !(this.label.isLayoutNewlineAfter() || isLayoutNewlineBefore()))) 
				{
					iWidth += availableContentWidth - cWidth - labelWidth;
				} else {
					iWidth += availableContentWidth - cWidth;
				}
				setItemWidth( iWidth );
			}
		} else if (this.itemWidth > availWidth) {
			setItemWidth( availWidth );
		}
		if (this.itemWidth + labelWidth <= availWidth) {
			// label and content fit on one row:
			this.useSingleRow = true;
			if (this.label != null) {
				if ( (this.label.layout & LAYOUT_NEWLINE_AFTER) != 0 || ((this.layout & LAYOUT_NEWLINE_BEFORE) == LAYOUT_NEWLINE_BEFORE )) {
					this.useSingleRow = false;
					cHeight += labelHeight;
					this.contentY += labelHeight;
					if (this.itemWidth < labelWidth) {
						setItemWidth(labelWidth);
					}
				}
			}
			if (this.useSingleRow && labelWidth > 0) {
				this.itemWidth += labelWidth; //TODO: when calling setItemWidth() here it will affect center and right layout items within a Container, but setting the variable directly is also not cool... 
				this.contentX += labelWidth;
				if ( cHeight + noneContentHeight < labelHeight ) {
					cHeight = labelHeight - noneContentHeight;
				}
			}
		} else {
			this.useSingleRow = false;
			cHeight += labelHeight;
			this.contentY += labelHeight;
            if (labelWidth > 0) {
                int labelX = 0;
                if (isLayoutCenter()) {
                    labelX = (this.itemWidth - availWidth) / 2;
                 } else if (isLayoutRight()) {
                     labelX = this.itemWidth - availWidth;
                 }
                //#if polish.css.include-label
                 else if (this.includeLabel) {
                	 labelX += this.marginLeft;
                 }
                //#endif
                //#if polish.css.complete-background
                 else if (this.completeBackground != null) {
                	 labelX += this.marginLeft;
                 }
                //#endif
                //#if polish.css.complete-border
                 else if (this.completeBorder != null) {
                	 labelX += this.marginLeft;
                 }
                //#endif
                 if (this.label.isLayoutCenter()) {
                     labelX += (availWidth - labelWidth)/2;
                 } else if (this.label.isLayoutRight()) {
                     labelX += (availWidth - labelWidth);
                 }
                 this.label.relativeX = labelX;
            }
		}
		
		int originalContentHeight = cHeight;

		int heightRelativeValue = availWidth;
		//#if polish.Item.useHeightInsteadOfWidth
			 heightRelativeValue = availHeight;
		//#endif

		//#ifdef polish.css.height
			if(this.cssHeight != null) {
				setContentHeight( targetHeight );
				cHeight = this.contentHeight;
			}
		//#endif
			
		//#ifdef polish.css.min-height
			if (this.minimumHeight != null) {
				int minHeight = this.minimumHeight.getValue(heightRelativeValue);
				if (cHeight < minHeight ) {
					setContentHeight( minHeight );
					cHeight = this.contentHeight;
				}
			}
		//#endif
		//#ifdef polish.css.max-height
			if (this.maximumHeight != null) {
				int maxHeight = this.maximumHeight.getValue(heightRelativeValue);
				if (cHeight > maxHeight ) {
					setContentHeight( maxHeight );
					cHeight = this.contentHeight;
				}
			}
		//#endif
		
		//#if polish.css.min-item-height
			if (this.minimumItemHeight != null && cHeight + noneContentHeight < this.minimumItemHeight.getValue(heightRelativeValue)) {
				cHeight = this.minimumItemHeight.getValue(heightRelativeValue) - noneContentHeight;
			}
		//#endif
			
		//#if polish.css.max-item-height
			if (this.maximumItemHeight != null && cHeight + noneContentHeight > this.maximumItemHeight.getValue(heightRelativeValue)) {
				cHeight = this.maximumItemHeight.getValue(heightRelativeValue) - noneContentHeight;
			}
		//#endif
			
		if (cHeight > originalContentHeight) {
			int ch = cHeight;
			if (!this.useSingleRow) {
				ch -= labelHeight;
			}
			if (isLayoutVerticalCenter()) {
				this.contentY += ( (ch - originalContentHeight) >> 1);
			} else if (isLayoutBottom()) {
				this.contentY += ( ch - originalContentHeight );
			}
		}
		//#ifdef polish.css.before
			if (cHeight < this.beforeHeight) {
				cHeight = this.beforeHeight;
			}
		//#endif
		//#ifdef polish.css.after
			if (cHeight < this.afterHeight) {
				cHeight = this.afterHeight;
			}
		//#endif
		this.itemHeight = cHeight + noneContentHeight;
		
		if (this.useSingleRow) {
			this.backgroundWidth = this.itemWidth - this.marginLeft - this.marginRight - labelWidth;
			this.backgroundHeight = cHeight
							  + noneContentHeight
							  - this.marginTop
							  - this.marginBottom;
		} else {
			this.backgroundWidth = this.itemWidth - this.marginLeft - this.marginRight;
			this.backgroundHeight = cHeight
							  + noneContentHeight
							  - this.marginTop
							  - this.marginBottom
							  - labelHeight;
//			if (labelWidth > this.itemWidth) {
//				int diff = labelWidth - this.itemWidth;
//				if (isLayoutCenter()) {
//					this.contentX += diff/2;
//				} else if (isLayoutRight()) {
//					this.contentX += diff;
//				}
//				this.itemWidth = labelWidth;
//			}
		}
//		if (labelWidth > 0 && availableContentWidth > this.contentWidth) {
//			//int diff = availableContentWidth - this.contentWidth;
//			int contX = this.contentX;
//			if (isLayoutCenter()) {
//				contX = (availWidth - this.contentWidth)/2;
//			} else if (isLayoutRight()) {
//				contX = (availWidth - this.contentWidth);
//			}
//			if (contX > this.contentX) {
//				//System.out.println("init: changing contentX from " + contentX + " to " + contX);
//				//this.contentX = contX;
//				setItemWidth( availWidth );
//			}
//		}
		if (labelWidth > 0 && this.useSingleRow && labelHeight < this.itemHeight) {
			if (this.label.isLayoutVerticalCenter()) {
				this.label.relativeY = (this.itemHeight - labelHeight) / 2;
			} else if (this.label.isLayoutBottom()) {
				this.label.relativeY = (this.itemHeight - labelHeight);
			}
		}
		//#if polish.css.background-width
			this.originalBackgroundWidth = this.backgroundWidth;
			if (this.style != null) {
				Dimension bgWidth = (Dimension) this.style.getObjectProperty("background-width");
				if (bgWidth != null) {
					this.backgroundWidth = bgWidth.getValue(this.backgroundWidth);
				}
			}
		//#endif
		//#if polish.css.background-height
			this.originalBackgroundHeight = this.backgroundHeight;
			if (this.style != null) {
				Dimension bgHeight = (Dimension) this.style.getObjectProperty("background-height");
				if (bgHeight != null) {
					this.backgroundHeight = bgHeight.getValue(this.backgroundHeight);
				}
			}
		//#endif
		//#if tmp.invisible
			if (this.isInvisible) {
				this.itemWidth = 0;
				this.itemHeight = 0;
			}
		//#endif
		//#if polish.css.opacity && polish.midp2
			this.opacityRgbData = null;
		//#endif
		setInitialized(true);
		//#debug
		System.out.println("Item.init(): contentHeight=" + this.contentHeight + ", itemHeight=" + this.itemHeight + " for " + this);
		//#debug
		System.out.println("Item.init(): contentWidth=" + this.contentWidth + ", itemWidth=" + this.itemWidth + ", backgroundWidth=" + this.backgroundWidth);
	}
	
	//#if polish.css.before
	/**
	 * Gets the before width along plus the horizontal padding when there is an before element defined.
	 * @return the width of the before element plus the horizontal padding or 0.
	 */
	protected int getBeforeWidthWithPadding() {
		int w = this.beforeWidth;
		if (w != 0) {
			w += this.paddingHorizontal;
		}
		return w;
	}
	//#endif
	
	//#if polish.css.after
	/**
	 * Gets the after width along plus the horizontal padding when there is an after element defined.
	 * @return the width of the after element plus the horizontal padding or 0.
	 */
	protected int getAfterWidthWithPadding() {
		int w = this.afterWidth;
		if (w != 0) {
			w += this.paddingHorizontal;
		}
		return w;
	}
	//#endif

	/**
	 * Initializes paddings and margins.
	 * @param layoutStyle the style of this item
	 * @param availWidth the available width in case paddings or margins include relative values
	 */
	protected void initLayout(Style layoutStyle, int availWidth) {
		//#ifdef polish.css.view-type
		if (this.view != null) {
			this.view.initPadding(layoutStyle, availWidth);
		} else
		//#endif
		{
			initPadding(layoutStyle, availWidth);
		}
	
		//#ifdef polish.css.view-type
		if (this.view != null) {
			this.view.initMargin(layoutStyle, availWidth);
		} else
		//#endif
		{
			initMargin(layoutStyle, availWidth);
		}
	}

	/**
	 * Initializes the margin of this item
	 * Subclasses can override this (e.g. the container embedded in a screen)
	 * @param itemStyle the style
	 * @param availWidth the available width
	 */
	protected void initMargin(Style itemStyle, int availWidth) {
		this.marginLeft = itemStyle.getMarginLeft(availWidth);
		this.marginRight = itemStyle.getMarginRight(availWidth);
		this.marginTop = itemStyle.getMarginTop(availWidth);
		this.marginBottom = itemStyle.getMarginBottom(availWidth);
	}

	/**
	 * Initializes the padding of this item
	 * Subclasses can override this (e.g. the container embedded in a screen)
	 * @param itemStyle the style
	 * @param availWidth the available width
	 */
	protected void initPadding(Style itemStyle, int availWidth) {
		this.paddingLeft = itemStyle.getPaddingLeft(availWidth);
		this.paddingRight = itemStyle.getPaddingRight(availWidth);
		this.paddingTop = itemStyle.getPaddingTop(availWidth);
		this.paddingBottom = itemStyle.getPaddingBottom(availWidth);
		this.paddingVertical = itemStyle.getPaddingVertical(availWidth);
		this.paddingHorizontal = itemStyle.getPaddingHorizontal(availWidth);
	}
	
	/**
	 * Retrieves the right padding of this item.
	 * Note that the padding is only initialized AFTER init() or initContent() has been called.
	 * @return the padding in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getPaddingRight() {
		return this.paddingRight;
	}
	
	/**
	 * Retrieves the left padding of this item.
	 * Note that the padding is only initialized AFTER init() or initContent() has been called.
	 * @return the padding in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getPaddingLeft() {
		return this.paddingLeft;
	}
	
	/**
	 * Retrieves the rop padding of this item.
	 * Note that the padding is only initialized AFTER init() or initContent() has been called.
	 * @return the padding in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getPaddingTop() {
		return this.paddingTop;
	}
	
	/**
	 * Retrieves the bottom padding of this item.
	 * Note that the padding is only initialized AFTER init() or initContent() has been called.
	 * @return the padding in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getPaddingBottom() {
		return this.paddingBottom;
	}
	
	/**
	 * Retrieves the horizontal padding of this item.
	 * Note that the padding is only initialized AFTER init() or initContent() has been called.
	 * @return the padding in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getPaddingHorizontal() {
		return this.paddingHorizontal;
	}
	
	/**
	 * Retrieves the vertical padding of this item.
	 * Note that the padding is only initialized AFTER init() or initContent() has been called.
	 * @return the padding in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getPaddingVertical() {
		return this.paddingVertical;
	}
	
	
	/**
	 * Retrieves the right margin of this item.
	 * Note that the margin is only initialized AFTER init() or initContent() has been called.
	 * @return the margin in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getMarginRight() {
		return this.marginRight;
	}
	
	/**
	 * Retrieves the left margin of this item.
	 * Note that the margin is only initialized AFTER init() or initContent() has been called.
	 * @return the margin in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getMarginLeft() {
		return this.marginLeft;
	}
	
	/**
	 * Retrieves the rop margin of this item.
	 * Note that the margin is only initialized AFTER init() or initContent() has been called.
	 * @return the margin in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getMarginTop() {
		return this.marginTop;
	}
	
	/**
	 * Retrieves the bottom margin of this item.
	 * Note that the margin is only initialized AFTER init() or initContent() has been called.
	 * @return the margin in pixels.
	 * @see Item#init(int, int, int)
	 * @see Item#initContent(int, int, int)
	 */
	public int getMarginBottom() {
		return this.marginBottom;
	}
	

	/**
	 * Sets the content width of this item.
	 * Subclasses can override this to react to content width changes
	 * @param width the new content width in pixel
	 */
	protected void setContentWidth( int width ) {
		this.contentWidth = width;
		
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.setContentWidth( width );
			}
		//#endif
	}
	
	/**
	 * Sets the content height of this item.
	 * Subclasses can override this to react to content height changes
	 * @param height the new content height in pixel
	 */
	protected void setContentHeight( int height ) {
		this.contentHeight = height;
		
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.setContentHeight( height );
			}
		//#endif
	}
	
	//#ifdef polish.useDynamicStyles
	/**
	 * Initialises the appropriate style for this item.
	 */
	protected void initStyle() {
		//System.out.println("item [" + this.getClass().getName() + "/" + this.cssSelector + "/" + this.hashCode() + "] has been initalised: " + this.isStyleInitialised );
		if (this.screen == null) {
			if (this.parent != null) {
				this.screen = getScreen();
			} else {
				this.screen = StyleSheet.currentScreen;
			}
		}
		if (this.style == null) {
			this.cssSelector = createCssSelector();
			//#debug
			System.out.println("getting style for item [" + this.cssSelector + "].");
			Style myStyle = StyleSheet.getStyle( this );
			if (myStyle == null) {
				myStyle = StyleSheet.defaultStyle;
			}
			if (myStyle != null) {
				setStyle( myStyle );
			}
		} else {
			//System.out.println("item has already style [" + this.style.name + "].");
			this.cssSelector = this.style.name;
		}
		this.isStyleInitialised = true;
	}
	//#endif
	

	/**
	 * Initialises this item. 
	 * The implementation needs to calculate and set the contentWidth and 
	 * contentHeight fields. 
	 * The implementation should take the fields preferredWidth and preferredHeight
	 * into account.
	 * 
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param availWidth the available maximum width of this item in pixels
	 * @param availHeight the available maximum height  of this item in pixels
	 * @see #contentWidth
	 * @see #contentHeight
	 * @see #preferredWidth
	 * @see #preferredHeight
	 */
	protected abstract void initContent(int firstLineWidth, int availWidth, int availHeight);
	
	
	/**
	 * Paints the content of this item.
	 * The background has already been painted and the border will be added after
	 * this method returns.
	 * 
	 * @param x the left start position
	 * @param y the upper start position
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position
	 * @param g the Graphics on which this item should be painted.
	 */
	protected abstract void paintContent( int x, int y, int leftBorder, int rightBorder, Graphics g );
	
	//#ifdef polish.useDynamicStyles	
	/**
	 * Retrieves the CSS selector for this item.
	 * The CSS selector is used for the dynamic assignment of styles -
	 * that is the styles are assigned by the usage of the item and
	 * not by a predefined style-name.
	 * With the #style preprocessing command styles are set fix, this method
	 * yields in a faster GUI and is recommended. When in a style-sheet
	 * dynamic styles are used, e.g. "Form>p", than the selector of the
	 * item is needed.
	 * <br/>
	 * This abstract method needs only be implemented, when dynamic styles
	 * are used: #ifdef polish.useDynamicStyles
	 * <br/>
	 * The returned selector needs to be in lower case. 
	 * 
	 * @return the appropriate CSS selector for this item.
	 * 			The selector needs to be in lower case.
	 */
	protected abstract String createCssSelector();	
	//#endif

	/**
	 * Handles the key-pressed event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default implementation just handles the FIRE game-action
	 * when a default-command and an item-command-listener have been
	 * registered.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 */
	protected boolean handleKeyPressed( int keyCode, int gameAction ) {
		//#debug
		System.out.println("item " + this + ": handling keyPressed for keyCode=" + keyCode + ", gameAction=" + gameAction);
		Screen scr = getScreen();
		if ( this.appearanceMode != PLAIN && null != scr && scr.isGameActionFire(keyCode, gameAction) )
		{
			return notifyItemPressedStart();
		}
		
		//#ifdef polish.css.view-type
			if(this.view != null) {
				return this.view.handleKeyPressed(keyCode, gameAction);
			}
		//#endif
		
		return false;
	}
	
	/**
	 * Handles the key-repeated event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default implementation forwards the event to the handleKeyPressed method.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 * @see #handleKeyPressed(int, int)
	 */
	protected boolean handleKeyRepeated( int keyCode, int gameAction ) {
		boolean handled = handleKeyPressed(keyCode, gameAction);
		
		//#ifdef polish.css.view-type
			if(!handled && this.view != null) {
				handled = this.view.handleKeyPressed(keyCode, gameAction);
			}
		//#endif
		
		return handled;
	}
	
	/**
	 * Handles the key-released event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default implementation invokes the default command if one is present
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 * @see #handleKeyPressed(int, int)
	 */
	protected boolean handleKeyReleased( int keyCode, int gameAction ) {
		//#debug
		System.out.println("handleKeyReleased(" + keyCode + ", " + gameAction + ") for " + this + ", isPressed=" + this.isPressed );
		Screen scr = getScreen();
		if (this.appearanceMode != PLAIN && this.isPressed && scr != null && scr.isGameActionFire(keyCode, gameAction) )
		{
			notifyItemPressedEnd();
			Item item = this;
			if (this.defaultCommand == null && this.parent != null) {
				item = this.parent;
			}
			if (item.defaultCommand != null) {
				if (!item.defaultCommand.commandAction(this, scr)) {
					if (item.itemCommandListener != null) {
						//#if polish.executeCommandsAsynchrone
							AsynchronousMultipleCommandListener.getInstance().commandAction(item.itemCommandListener, item.defaultCommand, this);
						//#else
							item.itemCommandListener.commandAction(item.defaultCommand, this);
						//#endif
					} else {			
						scr.callCommandListener(item.defaultCommand);
					}
				}
				//#if polish.css.visited-style
					notifyVisited();
				//#endif
				return true;
			}
		}
		int clearKey =
		//#if polish.key.ClearKey:defined
			//#= ${polish.key.ClearKey};
		//#else
			-8;
		//#endif
		if (keyCode == clearKey && this.commands != null) {
			Command deleteCommand = null;
			Object[] cmds = this.commands.getInternalArray();
			for (int i = 0; i < cmds.length; i++)
			{
				Command cmd = (Command) cmds[i];
				if (cmd == null) {
					break;
				}
				if (cmd.getCommandType() == Command.CANCEL && (deleteCommand == null || deleteCommand.getPriority() > cmd.getPriority()) ) {
					deleteCommand = cmd;
				}
			}
			if (deleteCommand != null) {
				if (this.itemCommandListener != null) {
					this.itemCommandListener.commandAction(deleteCommand, this);
				} else if (scr != null ) {
					scr.callCommandListener(deleteCommand);
				}				
			}
		}
		
		//#ifdef polish.css.view-type
			if(this.view != null) {
				return this.view.handleKeyReleased(keyCode, gameAction);
			}
		//#endif

		return false;
	}

	/**
	 * Is called when this item has been visited.
	 */
	public void notifyVisited() {
		//#if polish.css.visited-style
			if (this.style != null && !this.hasBeenVisited) {
				if (this.isPressed) {
					notifyItemPressedEnd();
				}
				Style visitedStyle = (Style) this.style.getObjectProperty("visited-style");
				if (visitedStyle != null) {
					this.hasBeenVisited = true;
					//#debug
					System.out.println("found visited style " + visitedStyle.name + " in " + this.style.name);
					setStyle( visitedStyle );
				} 
				if (this.parent instanceof Container) {
					Container cont = (Container) this.parent;
					visitedStyle = (Style) cont.itemStyle.getObjectProperty("visited-style");
					if (visitedStyle != null) {
						//#debug
						System.out.println("found visited style " + visitedStyle.name + " in " + cont.itemStyle.name);								
						cont.itemStyle = visitedStyle;
					}
				}
			}
		//#endif
		//#if tmp.handleEvents
			EventManager.fireEvent( EventManager.EVENT_VISIT, this, null); 
		//#endif

	}
	
	/**
	 * Is called when the visited state of this item should be reset.
	 */
	public void notifyUnvisited() {
		//#if polish.css.visited-style
			if (this.style != null && this.hasBeenVisited) {
				if (this.isPressed) {
					notifyItemPressedEnd();
				}
				this.hasBeenVisited = false;
				Style[] styles = (Style[]) Arrays.toArray(StyleSheet.getStyles().elements(), new Style[ StyleSheet.getStyles().size()] );
				Container cont = null;
				if (this.parent instanceof Container) {
					cont = (Container) this.parent;
				}
				boolean oneLeft = false;
				for (int i = 0; i < styles.length; i++) {
					Style aStyle = styles[i];
					Style visitedStyle = (Style) aStyle.getObjectProperty("visited-style");
					if (visitedStyle == this.style) {
						setStyle( aStyle );
						if (oneLeft) {
							break;
						} else {
							oneLeft = true;
						}
					}
					else if (cont != null && cont.itemStyle == visitedStyle) {
						cont.itemStyle = aStyle;
						if (!oneLeft) {
							Style focStyle = (Style) aStyle.getObjectProperty("focused-style");
							if (focStyle != null) {
								setStyle( focStyle );
							}
						}
						break;
					}
				}
			}
		//#endif	
		//#if tmp.handleEvents
			EventManager.fireEvent( EventManager.EVENT_UNVISIT, this, null); 
		//#endif
	}

	/**
	 * Is called when an item is pressed using the FIRE game action
	 * 
	 * @return true when the item requests a repaint after this action
	 */
	public boolean notifyItemPressedStart() {
		//try { throw new RuntimeException(); } catch (Exception e) { e.printStackTrace(); }
		if (this.isPressed) {
			return false;
		}
		//#debug
		System.out.println("notifyItemPressedStart for " + this);
		this.isPressed = true;
		boolean handled = false;
		//#if polish.css.pressed-style
			//System.out.println("notifyItemPressedStart for " + this + ", pressedStyle=" + (this.pressedStyle != null ? this.pressedStyle.name : "<null>") );
			if (this.pressedStyle != null && this.style != this.pressedStyle) {
				this.normalStyle = this.style;
				setStyle( this.pressedStyle );
				handled = true;
			}
		//#endif
		//#if tmp.handleEvents
			EventManager.fireEvent( EventManager.EVENT_PRESS, this, null);
		//#endif
		return handled;
	}
	
	/**
	 * Determines whether this item is currently pressed.
	 * @return true when this item is pressed
	 */
	public boolean isPressed() {
		return this.isPressed;
	}
	
	/**
	 * Determines whether this item is currently focused.
	 * @return true when this item is focused
	 */
	public boolean isFocused() {
		return this.isFocused;
	}
	
	/**
	 * Is called when an item is pressed
	 */
	public void notifyItemPressedEnd() {
		if (!this.isPressed) {
			return;
		}
		//#debug
		System.out.println("notifyItemPressedEnd for " + this + ", normalStyle=" + (this.normalStyle == null ? "<none>" : this.normalStyle.name ) + ", current=" + (this.style == null ? "<none>" : this.style.name) );
		this.isPressed = false;
		//#if polish.css.pressed-style
			Style previousStyle = this.normalStyle;
			if (previousStyle != null && this.style != previousStyle) {
				//#ifdef polish.css.view-type
					boolean removeViewType = ( this.style.getObjectProperty("view-type") != null  && previousStyle.getObjectProperty( "view-type") == null); 
				//#endif
				setStyle( previousStyle );
				repaint();
				this.normalStyle = null;
				//#ifdef polish.css.view-type
					if (removeViewType) {
						this.view = null;
					}
				//#endif
			}
		//#endif
		//#if tmp.handleEvents
			EventManager.fireEvent( EventManager.EVENT_UNPRESS, this, null); 
		//#endif
		if (this.parent != null) {
			this.parent.notifyItemPressedEnd();
		}
	}


	/**
	 * Determines whether the given relative x/y position is inside of this item's (visible) content area.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method or possibly the getContentX(), getContentY() methods.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left position
	 * @param relY the y position relative to this item's top position
	 * @return true when the relX/relY coordinate is within this item's content area.
	 * @see #initContent(int, int, int)
	 */
	public boolean isInContentArea( int relX, int relY ) {
		int contTop = this.contentY;
		int contLeft = this.contentX;
		int contW = this.contentWidth;
		if (contW > this.availContentWidth) {
			contW = this.availContentWidth;
		}
		if ( relY < contTop || relX < contLeft || relY > contTop + this.contentHeight || relX > contLeft + contW) {
			//#debug
			System.out.println("isInContentArea(" + relX + "," + relY + ") = false: contentY=" + this.contentY + ", contentY + contentHeight=" + (contTop + this.contentHeight) + " (" + this +")");
			//#debug
			System.out.println("isInContentArea(" + relX + "," + relY + ") = false: contentX=" + this.contentX + ", contentX + contentWidth=" + (contLeft + contW) + " (" + this +")");
			return false;
		}
		//#debug
		System.out.println("isInContentArea(" + relX + "," + relY + ") = true: contentX=" + this.contentX + ", contentX + contentWidth=" + (contLeft + contW) + ", contentY=" + this.contentY + ", contentY + contentHeight=" + (contTop + this.contentHeight) + " (" + this +")");
		return true;
	}
	
	/**
	 * Determines whether the given relative x/y position is inside of this item's content area.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method or possibly the getContentX(), getContentY() methods.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left position
	 * @param relY the y position relative to this item's top position
	 * @return true when the relX/relY coordinate is within this item's content + padding area.
	 * @see #initContent(int, int, int)
	 */
	public boolean isInContentWithPaddingArea( int relX, int relY ) {
		int contTop = this.contentY - this.paddingTop;
		if ( relY < contTop || relY > contTop + this.contentHeight + this.paddingTop + this.paddingBottom ) {
			//#debug
			System.out.println("isInContentWithPaddingArea(" + relX + "," + relY + ") = false: contentY=" + this.contentY + ", contentY + contentHeight=" + (contTop + this.contentHeight) + " (" + this +")");
			return false;
		}
		int contLeft = this.contentX - this.paddingLeft;
		if (relX < contLeft || relX > contLeft + this.contentWidth + this.paddingLeft + this.paddingRight) {
			//#debug
			System.out.println("isInContentWithPaddingArea(" + relX + "," + relY + ") = false: contentX=" + this.contentX + ", contentX + contentWidth=" + (contLeft + this.contentWidth) + " (" + this +")");
			return false;
		}
		//#debug
		System.out.println("isInContentWithPaddingArea(" + relX + "," + relY + ") = true: contentX=" + this.contentX + ", contentX + contentWidth=" + (contLeft + this.contentWidth) + ", contentY=" + this.contentY + ", contentY + contentHeight=" + (contTop + this.contentHeight) + " (" + this +")");
		return true;
	}

	/**
	 * Determines whether the given relative x/y position is inside of this item's area including paddings, margins and label.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left position
	 * @param relY the y position relative to this item's top position
	 * @return true when the relX/relY coordinate is within this item's area.
	 * @see #initContent(int, int, int)
	 */
	public boolean isInItemArea( int relX, int relY ) {
		if (relY < 0 || relY > this.itemHeight || relX < 0 || relX > this.itemWidth) { //Math.max(this.itemWidth, this.contentX + this.contentWidth)) {
			//#debug
			System.out.println("isInItemArea(" + relX + "," + relY + ") = false: itemWidth=" + this.itemWidth + ", itemHeight=" + this.itemHeight + " (" + this + ")");
			return false;
		}
		//#debug
		System.out.println("isInItemArea(" + relX + "," + relY + ") = true: itemWidth=" + this.itemWidth + ", itemHeight=" + this.itemHeight + " (" + this + ")");
		return true;
	}
	
	/**
	 * Determines whether the given relative x/y position is inside of the specified child item's area including paddings, margins and label.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left content position
	 * @param relY the y position relative to this item's top content position
	 * @param child the child
	 * @return true when the relX/relY coordinate is within the child item's area.
	 */
	public boolean isInItemArea( int relX, int relY, Item child ) {
		if (child != null) {
			return child.isInItemArea(relX - child.relativeX, relY - child.relativeY);
		}
		return false;
		
	}
	
	/**
	 * Handles the event when a pointer has been pressed at the specified position.
	 * The default method discards this event when relX/relY is outside of the item's area.
	 * When the event took place inside of the content area, the pointer-event is translated into an artificial
	 * FIRE game-action keyPressed event, which is subsequently handled
	 * by the handleKeyPressed(-1, Canvas.FIRE) method.
	 * This method needs should be overwritten only when the "polish.hasPointerEvents"
	 * preprocessing symbol is defined: "//#ifdef polish.hasPointerEvents".
	 *    
	 * @param relX the x position of the pointer pressing relative to this item's left position
	 * @param relY the y position of the pointer pressing relative to this item's top position
	 * @return true when the pressing of the pointer was actually handled by this item.
	 * @see #isInItemArea(int, int) this method is used for determining whether the event belongs to this item
	 * @see #isInContentArea(int, int) for a helper method for determining whether the event took place into the actual content area
	 * @see #handleKeyPressed(int, int) 
	 * @see #contentX for calculating the horizontal position relative to the content (relX - contentX)
	 * @see #contentY for calculating the vertical position relative to the content (relY - contentY)
	 */
	protected boolean handlePointerPressed( int relX, int relY ) {
		//#ifdef polish.hasPointerEvents
			//#if polish.Item.ShowCommandsOnHold
				if (this.isShowCommands) {
					Container cmdCont = this.commandsContainer;
					if (cmdCont != null && cmdCont.handlePointerPressed(relX - cmdCont.relativeX, relY - cmdCont.relativeY)) {
						return true;
					}
				}
			//#endif
			//#ifdef polish.css.view-type
				if (this.view != null && this.view.handlePointerPressed(relX, relY)) {
					return true;
				}
			//#endif
			if ( isInItemArea(relX, relY) ) {
				//#if tmp.supportTouchGestures
					this.gestureStartTime = System.currentTimeMillis();
					this.gestureStartX = relX;
					this.gestureStartY = relY;
				//#endif
				return handleKeyPressed( 0, Canvas.FIRE );
			}
			//#if polish.Item.ShowCommandsOnHold
				else {
					this.gestureStartTime = 0;
					if (this.isShowCommands) {
						this.isShowCommands = false;
						return true;
					}
				}
			//#endif			
		//#endif
		
			
		//#ifdef polish.css.view-type
			if(this.view != null) {
				return this.view.handlePointerPressed(relX, relY);
			}
		//#endif
		
		return false;
	}
	
	/**
	 * Handles the event when a pointer has been released at the specified position.
	 * The default method discards this event when relX/relY is outside of the item's area.
	 * When the event took place inside of the content area, the pointer-event is translated into an artificial
	 * FIRE game-action keyReleased event, which is subsequently handled
	 * bu the handleKeyPressed(-1, Canvas.FIRE) method.
	 * This method needs should be overwritten only when the "polish.hasPointerEvents"
	 * preprocessing symbol is defined: "//#ifdef polish.hasPointerEvents".
	 *    
	 * @param relX the x position of the pointer pressing relative to this item's left position
	 * @param relY the y position of the pointer pressing relative to this item's top position
	 * @return true when the pressing of the pointer was actually handled by this item.
	 * @see #isInItemArea(int, int) this method is used for determining whether the event belongs to this item
	 * @see #isInContentArea(int, int) for a helper method for determining whether the event took place into the actual content area
	 * @see #handleKeyPressed(int, int) 
	 * @see #contentX for calculating the horizontal position relative to the content (relX - contentX)
	 * @see #contentY for calculating the vertical position relative to the content (relY - contentY)
	 */
	protected boolean handlePointerReleased( int relX, int relY ) {
		//#ifdef polish.hasPointerEvents
			//#debug
			System.out.println("handlePointerReleased " + relX + ", " + relY + " for item " + this + " isPressed=" + this.isPressed);
			// handle keyboard behaviour only if this not a container,
			// its handled in the overwritten version
			if (this.isJustFocused) {
				this.isJustFocused = false;
				handleOnFocusSoftKeyboardDisplayBehavior();
			}
			//#if tmp.supportTouchGestures
				if (this.isIgnorePointerReleaseForGesture) {
					this.isIgnorePointerReleaseForGesture = false;
					return true;
				}
			//#endif
			//#if polish.Item.ShowCommandsOnHold
				if (this.isShowCommands) {
					this.commandsContainer.handlePointerReleased(relX - this.commandsContainer.relativeX, relY - this.commandsContainer.relativeY);
					this.isShowCommands = false;
					notifyItemPressedEnd();
					return true;
				}
			//#endif
			//#if tmp.supportTouchGestures
				int verticalDiff = Math.abs( relY - this.gestureStartY );
				if (verticalDiff < 20) {
					int horizontalDiff = relX - this.gestureStartX;
					if (horizontalDiff > this.itemWidth/2) {
						if (handleGesture(GestureEvent.GESTURE_SWIPE_RIGHT, relX, relY)) {
							return true;
						}
					} else if (horizontalDiff < -this.itemWidth/2) {
						if (handleGesture(GestureEvent.GESTURE_SWIPE_LEFT, relX, relY)) {
							return true;
						}						
					}
				}
			//#endif
			//#ifdef polish.css.view-type
				if (this.view != null && this.view.handlePointerReleased(relX, relY)) {
					return true;
				}
			//#endif
			if ( isInItemArea(relX, relY) ) {
				return handleKeyReleased( 0, Canvas.FIRE );
			} else if (this.isPressed) {
				notifyItemPressedEnd();
				return true;
			}
		//#endif
		
		//#ifdef polish.css.view-type
			if(this.view != null) {
				return this.view.handlePointerReleased(relX, relY);
			}
		//#endif
			
		return false;
	}
	
	/**
	 * Handles the dragging/movement of a pointer.
	 * This method should be overwritten only when the polish.hasPointerEvents 
	 * preprocessing symbol is defined.
	 * The default implementation returns false.
	 *  
	 * @param relX the x position of the pointer pressing relative to this item's left position
	 * @param relY the y position of the pointer pressing relative to this item's top position
	 * @return true when the dragging of the pointer was actually handled by this item.
	 */
	protected boolean handlePointerDragged(int relX, int relY, ClippingRegion repaintRegion) 
	{
		boolean handled = false;
		//#ifdef polish.hasPointerEvents
			//#if tmp.supportTouchGestures
				if (this.gestureStartTime != 0 && Math.abs( relX - this.gestureStartX) > 30 || Math.abs( relY - this.gestureStartY) > 30) {
					// abort (hold) gesture after moving out for too much:
					this.gestureStartTime = 0;
				}
			//#endif
			//#if polish.Item.ShowCommandsOnHold
				if (this.isShowCommands && this.commandsContainer.handlePointerDragged(relX - this.commandsContainer.relativeX, relY - this.commandsContainer.relativeY, repaintRegion)) {
					handled = true;
				}
			//#endif
			//#ifdef polish.css.view-type
				if (this.view != null && this.view.handlePointerDragged(relX, relY, repaintRegion)) {
					handled = true;
				}
			//#endif
		//#endif
		if (handlePointerDragged(relX, relY)) {
			addRepaintArea(repaintRegion);
			handled = true;
		}
		return handled;
	}

	/**
	 * Handles the dragging/movement of a pointer.
	 * This method should be overwritten only when the polish.hasPointerEvents 
	 * preprocessing symbol is defined.
	 * The default implementation returns false.
	 *  
	 * @param relX the x position of the pointer pressing relative to this item's left position
	 * @param relY the y position of the pointer pressing relative to this item's top position
	 * @return true when the dragging of the pointer was actually handled by this item.
	 */
	protected boolean handlePointerDragged(int relX, int relY)
	{
		return false;
	}
	
	/**
	 * Handles a touch down/press event. 
	 * This is similar to a pointerPressed event, however it is only available on devices with screens that differentiate
	 * between press and touch events (read: BlackBerry Storm).
	 * 
	 * @param x the horizontal pixel position of the touch event relative to this item's left position
	 * @param y  the vertical pixel position of the touch event relative to this item's top position
	 * @return true when the event was handled
	 */
	public boolean handlePointerTouchDown( int x, int y ) {
		//#if polish.hasTouchEvents && polish.css.view-type
			if (this.view != null && this.view.handlePointerTouchDown(x, y)) {
				return true;
			}
		//#endif
		return false;
	}
	

	/**
	 * Handles a touch up/release event. 
	 * This is similar to a pointerReleased event, however it is only available on devices with screens that differentiate
	 * between press and touch events (read: BlackBerry Storm).
	 * 
	 * @param x the horizontal pixel position of the touch event relative to this item's left position
	 * @param y  the vertical pixel position of the touch event relative to this item's top position
	 * @return true when the event was handled
	 */
	public boolean handlePointerTouchUp( int x, int y ) {
		//#if polish.hasTouchEvents && polish.css.view-type
			if (this.view != null && this.view.handlePointerTouchUp(x, y)) {
				return true;
			}
		//#endif
		return false;
	}
	
	/**
	 * Handles a touch gestures.
	 * Note that touch gesture support needs to be activated using the preprocessing variable polish.supportGestures.
	 * The default implementation calls handleGestureHold() in case GESTURE_HOLD is specified.
	 * @param gesture the gesture identifier, e.g. GESTURE_HOLD
	 * @return true when this gesture was handled
	 * @see #handleGestureHold(int, int)
	 */
	protected boolean handleGesture(int gesture, int x, int y) {
		boolean handled = false;
		switch (gesture) {
		case GestureEvent.GESTURE_HOLD:
			handled = handleGestureHold(x, y);
			break;
		case GestureEvent.GESTURE_SWIPE_LEFT:
			handled = handleGestureSwipeLeft(x, y);
			break;
		case GestureEvent.GESTURE_SWIPE_RIGHT:
			handled = handleGestureSwipeRight(x, y);
		}
		if (!handled) {
			GestureEvent event = GestureEvent.getInstance();
			event.reset( gesture, x, y );
			UiEventListener listener = getUiEventListener();
			if (listener != null) {
				listener.handleUiEvent(event, this);
				handled = event.isHandled();
			}
			//#if tmp.handleEvents
				if (!handled) {
					EventManager.fireEvent(event.getGestureName(), this, event );
					handled = event.isHandled();
				}
			//#endif			
		}
		return handled;
	}

	/**
	 * Handles the hold touch gestures.
	 * Note that touch gesture support needs to be activated using the preprocessing variable polish.supportGestures
	 * The default implementation shows the commands of this item, but only when the preprocessing variable
	 * polish.Item.ShowCommandsOnHold is set to true.
	 * 
	 * @return true when this gesture was handled
	 */
	protected boolean handleGestureHold(int x, int y) {
		//#if polish.Item.ShowCommandsOnHold
			if (this.commands != null && !this.isShowCommands && this.commands.size() > 1) {
				this.isShowCommands = true;
				if (this.commandsContainer != null) {
					this.commandsContainer.focusChild(-1);
				}
				return true;
			}
		//#endif
		return false;
	}
	
	/**
	 * Handles the swipe left gesture.
	 * @return true when the gesture was handled
	 */
	protected boolean handleGestureSwipeLeft(int x, int y) {
		return false;
	}
	
	/**
	 * Handles the swipe right gesture.
	 * @return true when the gesture was handled
	 */
	protected boolean handleGestureSwipeRight(int x, int y) {
		return false;
	}


	/**
	 * Adds a repaint request for this item's space.
	 * @param repaintRegion the clipping rectangle to which the repaint area should be added
	 */
	public void addRepaintArea( ClippingRegion repaintRegion ) {
		int absX = getAbsoluteX();
		int absY = getAbsoluteY();
		int w = this.itemWidth;
		int h = this.itemHeight + 1;
		//#if polish.css.filter
			RgbImage img = this.filterProcessedRgbImage;
			if (img != null && (img.getHeight() > h || img.getWidth() > w)) {
				int lo = this.layout;
				int wFilter = img.getWidth();
				int hFilter = img.getHeight();
				int horDiff = wFilter - w;
				int verDiff = hFilter - h;
				if ((lo & LAYOUT_CENTER) == LAYOUT_CENTER) {
					absX -= horDiff / 2;
					w += horDiff;
				} else if ((lo & LAYOUT_CENTER) == LAYOUT_RIGHT) {
					absX -= horDiff;
				} else {
					w += horDiff;
				}
				if ((lo & LAYOUT_VCENTER) == LAYOUT_VCENTER) {
					absY -= verDiff / 2;
					h += verDiff;
				} else if ((lo & LAYOUT_VCENTER) == LAYOUT_TOP) {
					absY -= verDiff; 
				} else {
					h += verDiff;
				}
			}
		//#endif
		//System.out.println("adding repaint area x=" + getAbsoluteX() + ", width=" + this.itemWidth + ", y=" + getAbsoluteY() + " for " + this);
		repaintRegion.addRegion(
				absX,
				absY,
				w, 
				h );
	}
	
	/**
	 * Adds a region relative to this item's content x/y start position.
	 * @param repaintRegion the clipping region
	 * @param x horizontal start relative to this item's content position
	 * @param y vertical start relative to this item's content position
	 * @param width width
	 * @param height height
	 * @see #getContentWidth()
	 * @see #getContentHeight()
	 */
	public void addRelativeToContentRegion(ClippingRegion repaintRegion, int x, int y, int width, int height) {
		repaintRegion.addRegion( 
				getAbsoluteX() + this.contentX + x, 
				getAbsoluteY() + this.contentY + y,
				width,
				height 
				);
	}
	
	/**
	 * Adds a region relative to this item's background x/y start position.
	 * @param repaintRegion the clipping region
	 * @param x horizontal start relative to this item's background position
	 * @param y vertical start relative to this item's background position
	 * @param width width
	 * @param height height
	 * @see #getBackgroundWidth()
	 * @see #getBackgroundHeight()
	 */
	public void addRelativeToBackgroundRegion( ClippingRegion repaintRegion, int x, int y, int width, int height) {
		repaintRegion.addRegion( 
				getAbsoluteX() + getBackgroundX() + x - 1, 
				getAbsoluteY() + getBackgroundY() + y - 1,
				width + 2,
				height + 2
				);
	}
	
	/**
	 * Adds a region relative to this item's background x/y start position.
	 * 
	 * @param animatedBackground the background that requests the repaint (could be a complete-background), can be null
	 * @param animatedBorder the border that requests the repaint (could be a complete-border), can be null
	 * @param repaintRegion the clipping region
	 * @param x horizontal start relative to this item's background position
	 * @param y vertical start relative to this item's background position
	 * @param width width
	 * @param height height
	 * @see #getBackgroundWidth()
	 * @see #getBackgroundHeight()
	 */
	public void addRelativeToBackgroundRegion( Background animatedBackground, Border animatedBorder,  ClippingRegion repaintRegion, int x, int y, int width, int height) {
		//#if polish.css.complete-background || polish.css.complete-border
			boolean addAbsolute = false;
			//#if polish.css.complete-background
				addAbsolute = (this.completeBackground != null && animatedBackground == this.completeBackground);
			//#endif
			//#if polish.css.complete-border
				addAbsolute |= (this.completeBorder != null && animatedBorder == this.completeBorder);
			//#endif
			if (addAbsolute) {
				//System.out.println("adding absolute repaint: bgX=" + getBackgroundX() + ", bgY=" + getBackgroundY() + ", itemHeight-bgHeight=" + (this.itemHeight - this.backgroundHeight) + ", itemWidth-bgWidth=" + (this.itemWidth - this.backgroundWidth));
				int padding = this.completeBackgroundPadding.getValue(this.availContentWidth);
				repaintRegion.addRegion( 
					getAbsoluteX() + x - 1 - padding, 
					getAbsoluteY() + y - 1 - padding,
					width + 2 + (padding << 1),
					height + 2 + (this.itemHeight - this.backgroundHeight) + (padding << 1)
					);
			} else {
		//#endif
				repaintRegion.addRegion( 
					getAbsoluteX() + getBackgroundX() + x - 1, 
					getAbsoluteY() + getBackgroundY() + y - 1,
					width + 2,
					height + 2
					);
		//#if polish.css.complete-background || polish.css.complete-border
			}
		//#endif
	}

	
	/**
	 * Animates this item.
	 * Subclasses can override this method to create animations.
	 * The default implementation animates the background and the item view if present.
	 * 
	 * @param currentTime the current time in milliseconds
	 * @param repaintRegion the repaint area that needs to be updated when this item is animated
	 * @see #addRelativeToContentRegion(ClippingRegion, int, int, int, int)
	 */
	public void animate( long currentTime, ClippingRegion repaintRegion) {

		if (this.label != null) {
			this.label.animate( currentTime, repaintRegion );
		}
		if (this.background != null) {
			this.background.animate( this.screen, this, currentTime, repaintRegion );
		}
		if (this.border != null) {
			this.border.animate( this.screen, this, currentTime, repaintRegion );
		}
		//#if polish.css.complete-background
			if (this.completeBackground != null) {
				this.completeBackground.animate( this.screen, this, currentTime, repaintRegion );
			}
		//#endif
		//#if polish.css.complete-border
			if (this.completeBorder != null) {
				this.completeBorder.animate( this.screen, this, currentTime, repaintRegion );
			}
		//#endif
		if (animate()) {
			addRepaintArea(repaintRegion);
		}
		//#if polish.css.view-type
			if (this.view != null) {
				this.view.animate(currentTime, repaintRegion);
			}
		//#endif
		//#if tmp.supportTouchGestures
			if (this.isPressed && (this.gestureStartTime != 0) && (currentTime - this.gestureStartTime > 500)) {
				boolean handled = handleGesture( GestureEvent.GESTURE_HOLD, this.gestureStartX, this.gestureStartY );
				if (handled) {
					this.isIgnorePointerReleaseForGesture = true;
					notifyItemPressedEnd();
					this.gestureStartTime = 0;					
					Screen scr = getScreen();
					repaintRegion.addRegion( scr.contentX, scr.contentY, scr.contentWidth, scr.contentHeight );
				} else {
					this.gestureStartTime = 0;
				}
			}
		//#endif
		//#if polish.Item.ShowCommandsOnHold
			if (this.isShowCommands && this.commandsContainer != null) {
				this.commandsContainer.animate(currentTime, repaintRegion);
			}
		//#endif
	}
	

	/**
	 * Animates this item.
	 * Subclasses can override this method to create animations.
	 * The default implementation returns false
	 * 
	 * @return true when this item has been animated.
	 * @see #animate(long, ClippingRegion)
	 */
	public boolean animate() {
		return false;
	}
	
	/**
	 * Retrieves the approriate style for focusing this item.
	 * This is either a item specific one or one inherit by its parents.
	 * When no parent has a specific focus style, the StyleSheet.focusedStyle is used.
	 * 
	 * @return the style used for focussing this item.
	 */
	public Style getFocusedStyle() {
		if (!this.isStyleInitialised) {
			if (this.style != null) {
				setStyle( this.style );
			}
			//#ifdef polish.useDynamicStyles
			else {
				initStyle();
			}
			//#endif
		}
		Style focStyle;
		if (this.focusedStyle != null) {
			focStyle = this.focusedStyle;
		} else if (this.parent != null) {
			focStyle = this.parent.getFocusedStyle();
		} else {
			focStyle= StyleSheet.focusedStyle;
		}
		//#if polish.css.visited-style
			if (this.hasBeenVisited && focStyle != null) {
				Style visitedStyle = (Style) focStyle.getObjectProperty("visited-style");
				//#debug
				System.out.println("found visited style " + (visitedStyle != null ? visitedStyle.name : "<none>") + " in " + focStyle.name);
				if (visitedStyle != null) {
					focStyle = visitedStyle;
				}
			}
		//#endif
		return focStyle;
	}
	

	//#if polish.hasPointerEvents
	/**
	 * Handles the behavior of the virtual keyboard when the item is focused.
	 * By default, the virtual keyboard is hidden. Components which need to have the virtual keyboard
	 * shown when they are focused can override this method.
	 */
	public void handleOnFocusSoftKeyboardDisplayBehavior() {
		DeviceControl.hideSoftKeyboard();
	}
	//#endif

	/**
	 * Focuses this item.
	 * 
	 * @param newStyle the style which is used to indicate the focused state
	 * @param direction the direction from which this item is focused,
	 *        either Canvas.UP, Canvas.DOWN, Canvas.LEFT, Canvas.RIGHT or 0.
	 *        When 0 is given, the direction is unknown.
	 * @return the current style of this item
	 */
	protected Style focus( Style newStyle, int direction ) {
		//#debug
		System.out.println("focus " + this);
		
		Style oldStyle = this.style;
		
		if ((!this.isFocused) || (newStyle != this.style && newStyle != null)) {
			if (!this.isStyleInitialised && oldStyle != null) {
				setStyle( oldStyle );
			}
			if (newStyle == null) {
				newStyle = getFocusedStyle();
			}
			//#if polish.css.view-type
				this.preserveViewType = true;
			//#endif
				
			this.isFocused = true;
			this.isJustFocused = true;
			setStyle( newStyle );
			
			//#if polish.css.pressed-style
				if (this.isPressed) {
					this.normalStyle = newStyle;
				}
			//#endif
			//#if polish.css.view-type
				this.preserveViewType = false;
			//#endif
			// now set any commands of this item:
			if (this.commands != null) {
				showCommands();
			}
			if (oldStyle == null) {
				oldStyle = StyleSheet.defaultStyle;
			}
			//#if polish.android
			if (this._androidView != null) {
				this._androidView.requestFocus();
			}
			//#endif
			//#if tmp.handleEvents
				EventManager.fireEvent( EventManager.EVENT_FOCUS, this, new Integer(direction));
			//#endif
		}
		
		return oldStyle;
	}
	

	/**
	 * Removes the focus from this item.
	 * 
	 * @param originalStyle the original style which will be restored.
	 */
	protected void defocus( Style originalStyle ) {
		//#debug
		System.out.println("defocus " + this + " with style " + (originalStyle != null ? originalStyle.name : "<no style>"));
		if (this.isPressed) {
			notifyItemPressedEnd();
		}
		this.backgroundYOffset = 0;
		this.isFocused = false;
		if (originalStyle != null) {
			setStyle( originalStyle );
			if (this.label != null) {
				Style prevLabelStyle = this.label.style;
				//#if polish.css.label-style
					prevLabelStyle = (Style) originalStyle.getObjectProperty("label-style");
					if (prevLabelStyle == null) {
						prevLabelStyle = this.label.style;
					}
				//#endif
				this.label.defocus(prevLabelStyle);
			}
		} else {
			this.background = null;
			this.border = null;
			this.style = null;
		}
		// now remove any commands which are associated with this item:
		if (this.commands != null) {
			Screen scr = getScreen();
			if (scr != null) {
				scr.removeItemCommands(this);
			}
		}
		//#if polish.Item.ShowCommandsOnHold
			this.isShowCommands = false;
		//#endif
		//#if tmp.handleEvents
			EventManager.fireEvent( EventManager.EVENT_DEFOCUS, this, null); 
		//#endif
	}

	

	/**
	 * Shows the commands on the screen.
	 */
	public void showCommands() {
		COMMANDS.clear();
		addCommands( COMMANDS );
		Screen scr = getScreen();
		if (scr != null) {
			scr.setItemCommands( COMMANDS, this );
		}			
	}
	
//	/**
//	 * Shows the commands on the screen.
//	 * 
//	 * @param commandsList an ArrayList with the commands from this item.
//	 */
//	protected void showCommands(ArrayList commandsList) {
//		addCommands(commandsList);
//		if (this.commands != null) {
//			commandsList.addAll( this.commands );
//		}
//		if (this.parent != null) {
//			this.parent.showCommands(commandsList);
//		} else {
//			Screen scr = getScreen();
//			if (scr != null) {
//				scr.setItemCommands( commandsList, this );
//			}			
//		}
//	}
	
	/**
	 * Adds all commands to the specified list.
	 * 
	 * @param commandsList an ArrayList into which the commands from this item should be added.
	 */
	protected void addCommands( ArrayList commandsList) {
		if (this.commands != null) {
			commandsList.addAll( this.commands );
		}
		if (this.parent != null) {
			this.parent.addCommands(commandsList);
		}		
	}
	
	/**
	 * Tries to handle the specified command.
	 * The item checks if the command belongs to this item and if it has an associated ItemCommandListener.
	 * Only then it handles the command.
	 * @param cmd the command
	 * @return true when the command has been handled by this item
	 */
	protected boolean handleCommand( Command cmd ) {
		if (cmd == this.defaultCommand) {
			notifyVisited();
		}
		if (cmd.commandAction(this, null)) {
			return true;
		}
		ItemCommandListener listener = this.itemCommandListener;
		if (this.commands == null || listener == null || !this.commands.contains(cmd) ) {
			//#if polish.Item.suppressDefaultCommand
			if (listener == null || cmd != this.defaultCommand) {
			//#endif
				return false;
			//#if polish.Item.suppressDefaultCommand
			}
			//#endif
		}
		try {
			listener.commandAction( cmd, this );
			return true;
		} catch (Exception e) {
			//#debug error
			System.out.println("Unable to handle command " + cmd.getLabel() + e );
		}
		return false;
	}
	
	
	//#if polish.LibraryBuild
		/**
		 * Tries to handle the specified command.
		 * The item checks if the command belongs to this item and if it has an associated ItemCommandListener.
		 * Only then it handles the command.
		 * @param cmd the command
		 * @return true when the command has been handled by this item
		 */
		protected boolean handleCommand( javax.microedition.lcdui.Command cmd ) {
			return false;
		}
	//#endif


	/**
	 * Called by the system to notify the item that it is now at least
	 * partially visible, when it previously had been completely invisible.
	 * The item may receive <code>paint()</code> calls after
	 * <code>showNotify()</code> has been called.
	 * 
	 * <p>The default implementation of this method sets the isShown field to true and calls showNotify on style elements.</p>
	 */
	protected void showNotify()
	{
		if (!this.isStyleInitialised && this.style != null) {
			setStyle( this.style );
		}
		this.isShown = true;
		if (this.label != null) {
			this.label.showNotify();
		}
		if (this.background != null) {
			this.background.showNotify();
		}
		if (this.border != null) {
			this.border.showNotify();
		}
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.showNotify();
			}
		//#endif
		//#if polish.css.complete-background
			if (this.completeBackground != null) {
				this.completeBackground.showNotify();
			}
		//#endif
		//#if polish.css.complete-border
			if (this.completeBorder != null) {
				this.completeBorder.showNotify();
			}
		//#endif
		//#if polish.blackberry
			if (this.isFocused  && this._bbField != null) {
				Display.getInstance().notifyFocusSet(this);
			}
		//#endif
		//#if polish.android
			if (this._androidView != null) {
				AndroidDisplay.getInstance().onShow(this._androidView, this);
			}
		//#endif
		//#if tmp.handleEvents
			//System.out.println("triggering event 'show' for " + this + " with style " + (this.style != null ? this.style.name : "<null>") + ", animations=" + (this.style != null ? "" + this.style.getAnimations() : "<null>"));
			if (!this.hasBeenShownBefore) {
				EventManager.fireEvent( EventManager.EVENT_SHOW_FIRST_TIME,  this, null );
				this.hasBeenShownBefore = true;
			}
			EventManager.fireEvent( EventManager.EVENT_SHOW,  this, null );
		//#endif
	}

	/**
	 * Called by the system to notify the item that it is now completely
	 * invisible, when it previously had been at least partially visible.  No
	 * further <code>paint()</code> calls will be made on this item
	 * until after a <code>showNotify()</code> has been called again.
	 * 
	 * <p>The default implementation of this method sets the isShown field to false and calls hideNotify on style elements.</p>
	 */
	protected void hideNotify()
	{
		this.isShown = false;
		if (this.label != null) {
			this.label.hideNotify();
		}
		if (this.background != null) {
			this.background.hideNotify();
		}
		if (this.border != null) {
			this.border.hideNotify();
		}
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.hideNotify();
			}
		//#endif
		//#if polish.css.complete-background
			if (this.completeBackground != null) {
				this.completeBackground.hideNotify();
			}
		//#endif
		//#if polish.css.complete-border
			if (this.completeBorder != null) {
				this.completeBorder.hideNotify();
			}
		//#endif
		if (this.isPressed) {
			notifyItemPressedEnd();
		}
		//#if polish.android
			if (this._androidView != null) {
				AndroidDisplay.getInstance().onHide(this._androidView, this);
			}
		//#endif
		//#if tmp.handleEvents
			EventManager.fireEvent( EventManager.EVENT_HIDE, this, null );
		//#endif
	}
	
	/**
	 * Shows the screen to which item belongs to and focusses this item.
	 * This method is the equivalent to display.setCurrentItem( item ).
	 * 
	 * @param display the display of the MIDlet.
	 */
	public void show( Display display ) {
		Screen myScreen = getScreen();
		if ( myScreen == null ) {
			//#debug warn
			System.out.println("Unable to show this item, since the screen is not known.");
			return;
		}
		//#if !polish.android
			myScreen.focus( this );
		//#endif
		display.setCurrent( myScreen );
		//#if polish.android
			myScreen.focus( this );
		//#endif
	}
	
	/**
	 * Releases all (memory intensive) resources such as images or RGB arrays of this item.
	 * The default implementation releases any background resources.
	 */
	public void releaseResources() {
		if (this.background != null) {
			this.background.releaseResources();
		}
		//#ifdef polish.css.view-type
			if (this.view != null) {
				this.view.releaseResources();
			}
		//#endif
		//#if polish.css.filter && polish.midp2
			if (this.filters != null) {
				for (int i=0; i<this.filters.length; i++) {
					RgbFilter filter = this.filters[i];
					filter.releaseResources();
				}
			}
		//#endif
	}
	
	/**
	 * Destroy the item by removing all references to parent, screen, listeners etc.
	 * and calling releaseResources()
	 */
	public void destroy() {
		releaseResources();
		
		AnimationThread.removeAnimationItem(this);
		
		if(null != this.itemCommandListener)
			this.itemCommandListener = null;
		if(null != this.itemStateListener)
			this.itemStateListener = null;
		if(null != this.parent)
			this.parent = null;
		if(null != this.screen)
			this.screen = null;
		
		//#ifdef polish.css.view-type
		if (this.view != null) {
			this.view.destroy();
			this.view = null;
		}
		//#endif
	}

	/**
	 * Sets an arbitrary attribute for this item.
	 * 
	 * @param key the key for the attribute
	 * @param value the attribute value
	 */
	public void setAttribute( Object key, Object value ) {
		if (this.attributes == null) {
			this.attributes = new HashMap();
		}
		this.attributes.put( key, value );
	}
	
	/**
	 * Gets an previously added attribute of this item.
	 * 
	 * @param key the key of the attribute
	 * @return the attribute value, null if none has been registered under the given key before
	 */
	public Object getAttribute( Object key ) {
		if (this.attributes == null) {
			return null;
		}
		return this.attributes.get( key );
	}
	
	/**
	 * Removes an previously added attribute of this item.
	 * 
	 * @param key the key of the attribute
	 * @return the attribute value, null if none has been registered under the given key before
	 */
	public Object removeAttribute(Object key)
	{
		if (this.attributes == null) {
			return null;
		}
		return this.attributes.remove( key );
	}


  
	/**
	* Returns a HashMap object with all registered attributes.
	* 
	* @return a HashMap object with all attribute key/value pairs, null if no attribute was stored before.
	*/
	public HashMap getAttributes() {
		return this.attributes;
	}
	
	/**
	 * Determines if this item or one of it's children is within the specified point.
	 * The default implementation returns this item or this item's label when the position fits.
	 * 
	 * @param relX the x position of the point relative to this item's left position
	 * @param relY the y position of the point relative to this item's top position
	 * @return this item or one of it's children, when the position fits, otherwise null is returned 
	 */
	public Item getItemAt( int relX, int relY ) {
		if ( isInItemArea(relX, relY) ) {
			if (this.label != null) {
				Item item = this.label.getItemAt(relX, relY);
				if (item != null) {
					return item;
				}
			}
			return this;
		}
		return null;
	}
	
	/**
	 * Retrieves this item's current absolute horizontal position
	 * 
	 * @return the absolute x position of this item in pixel.
	 */
	public int getAbsoluteX() {
		int absX = this.relativeX;
//		if (this.label != null && this.useSingleRow && !this.isLayoutCenter && !this.isLayoutRight) {
//			// hack for left align with additional label:
//			absX += this.contentX;
//		}
		Item item = this.parent;
		if (item != null && item.label == this && item.useSingleRow) {
			// this is the label of another item
			absX -= item.contentX;
		}
		//#if polish.css.x-adjust
			if (this.xAdjustment != null) {
				int value = this.xAdjustment.getValue(this.itemWidth);
				absX += value;
			}
		//#endif

		while (item != null) {
			absX += item.relativeX + item.contentX;
			item = item.parent;
		}
		return absX;
	}
	
	/**
	 * Retrieves this item's current absolute vertical position
	 * 
	 * @return the absolute y position of this item in pixel.
	 */
	public int getAbsoluteY() {
		int absY = this.relativeY; // + this.contentY; in that case no label is included anymore
		Item item = this.parent;
		if (item != null && item.label == this) {
			absY -= item.contentY;
		}
		//#if polish.css.y-adjust
			if (this.yAdjustment != null) {
				absY += this.yAdjustment.getValue(this.itemHeight);
			}
		//#endif
		while (item != null) {
			absY += item.relativeY + item.contentY;
			if (item instanceof Container) {
				absY += ((Container)item).yOffset;
			}
			item = item.parent;
		}
		return absY;
	}
	
	/**
	 * Sets the absolute vertical position of this item.
	 * Note that results may vary depending on the view-type of the root container.
	 * 
	 * @param absY the absolute y position of this item in pixel.
	 */
	public void setAbsoluteY(int absY) {
		// find out vertical offset for root container:
		int currentAbsY = getAbsoluteY();
		int diff = absY - currentAbsY;
		//System.out.println("setting absY to " + absY + ", current=" + currentAbsY + ", diff=" + diff + " for item " + this);
		Item item = this;
		while (item.parent != null) {
			item = item.parent;
		}
		if (item instanceof Container) {
			Container container = (Container)item;
			int offset = container.getScrollYOffset() + diff;
			//System.out.println("resulting in scrollOffset=" + offset + ", currentScrollOffset=" + container.getScrollYOffset());
			container.setScrollYOffset(offset, false);
		}
		//System.out.println("after setAbsoluteY=" + getAbsoluteY() + ", should be=" + absY);
	}
	
	/**
	 * Retrieves the start of the content relative to this item's absolute x position.
	 * @return the horizontal start of the content
	 * @see #getAbsoluteX()
	 */
	public int getContentX() {
		return this.contentX;
	}
	
	/**
	 * Retrieves the start of the content relative to this item's absolute y position.
	 * @return the vertical start of the content
	 * @see #getAbsoluteY()
	 */
	public int getContentY() {
		return this.contentY;
	}
	
	/**
	 * Retrieves the width of the content.
	 * @return the content width in pixels
	 */
	public int getContentWidth()
	{
		return this.contentWidth;
	}
	
	/**
	 * Retrieves the height of the content.
	 * @return the content height in pixels
	 */
	public int getContentHeight()
	{
		return this.contentHeight;
	}
	
	/**
	 * Retrieves the width of the content.
	 * @return the content width in pixels
	 */
	public int getAvailableContentWidth()
	{
		return this.availContentWidth;
	}
	
	/**
	 * Retrieves the height of the content.
	 * @return the content height in pixels
	 */
	public int getAvailableContentHeight()
	{
		return this.availContentHeight;
	}
	
	/**
	 * Retrieves the height of the area that this item covers.
	 * This can be different from the original itemHeight for items that have popups such as the POPUP ChoiceGroup
	 * @return the height of the item's area in pixel
	 */
	public int getItemAreaHeight()
	{
		return Math.max( this.itemHeight, this.marginTop + this.backgroundHeight + this.marginBottom );
	}
	
	
	/**
	 * Retrieves the start of the background relative to this item's origin.
	 * 
	 * @return the horizontal background start in pixels.
	 */
	public int getBackgroundX() {
		//#if polish.css.include-label
			if (this.includeLabel) {
				return this.marginLeft;
			} else {
		//#endif
				return this.contentX - this.paddingLeft;
		//#if polish.css.include-label
			} 
		//#endif
	}
	
	/**
	 * Retrieves the start of the background relative to this item's origin.
	 * 
	 * @return the horizontal background start in pixels.
	 */
	public int getBackgroundY() {
		//#if polish.css.include-label
			if (this.includeLabel) {
				return this.marginTop;
			} else {
		//#endif
				return this.contentY - this.paddingTop;
		//#if polish.css.include-label
			} 
		//#endif
	}
	
	/**
	 * Retrieves the width of this item's background.
	 * @return the width in pixels
	 */
	public int getBackgroundWidth() {
		return this.backgroundWidth;
	}


	/**
	 * Retrieves the height of this item's background.
	 * @return the height in pixels
	 */
	public int getBackgroundHeight() {
		return this.backgroundHeight;
	}

	/**
	 * Retrieves the parent of this item.
	 * 
	 * @return this item's parent.
	 */
	public Item getParent() {
		return this.parent;
	}
	
	/**
	 * Retrieves the parent root of this item.
	 * 
	 * @return this item's super parent, either this item itself or it's last known ancestor.
	 */
	public Item getParentRoot() {
		Item p = this;
		while (p.parent != null) {
			p = p.parent;
		}
		return p;
	}

	
	/**
	 * Sets a parent for this item.
	 * @param parent the parent of this item
	 */
	public void setParent(Item  parent)
	{
		this.parent = parent;
	}
	
	//#if polish.midp
	/**
	 * Sets a parent for this item.
	 * @param parent the parent of this item
	 */
	public void setParent(javax.microedition.lcdui.Item  parent)
	{
		// ignore
	}
	//#endif

	
	/**
	 * Sets the visible status of this item.
	 * Invisible items occupy no space on the UI screen and cannot be focused/traversed. 
	 * Note that you can call this method ONLY when the preprocessing variable polish.supportInvisibleItems is true or when you use the CSS attribute 'visible' in your polish.css file.
	 * @param visible true when this item should become visible.
	 */
	public void setVisible( boolean visible ) {
		//#if tmp.invisible
		boolean invisible = !visible;
		if (invisible == this.isInvisible) {
			return;
		}
//		if (visible) {
//			System.out.println("+++ SETTING VISIBLE: " + this );
//		} else {
//			System.out.println("--- SETTING INVISIBLE: " + this );
//		}
		if (this.parent instanceof Container) {
			Container parentContainer = (Container) this.parent;
			if (invisible && this.isFocused) {
				//System.out.println("making focused item invisible: " + this);
				// remove any item commands:
				Screen scr = getScreen();
				if (scr != null) {
					scr.removeItemCommands(this);
				}
				int itemIndex = parentContainer.indexOf( this );
				boolean isFocusSet = parentContainer.focusClosestItemAbove( itemIndex );
				this.isFocused = false;
				//System.out.println("new focus set: " + isFocusSet + ", new index=" + parentContainer.focusedIndex + ", this.index=" + itemIndex );
				if (isFocusSet) {
					if (parentContainer.focusedIndex > itemIndex ) {
						// focused has moved downwards, since the above item is now invisible,
						// adjust the scrolling accordingly:
						int offset = parentContainer.yOffset + this.itemHeight + parentContainer.paddingVertical;
						if (offset > 0) {
							offset = 0;
						}
						//System.out.println("setting parent scroll offset to " + offset );
						parentContainer.setScrollYOffset( offset, false );
					} else {
						parentContainer.scroll( 0, parentContainer.focusedItem, true);
					}
				} else {
					parentContainer.focusChild(-1);
				}
				if (this instanceof Container) {
					((Container)this).focusChild(-1);
				}
			} else if (!this.isFocused && parentContainer.focusedIndex > parentContainer.indexOf(this)) {
				// adjust scrolling so that the focused element of the parent container stays in the current position:
				int offset;
				if (invisible) {
					 offset = parentContainer.getScrollYOffset() + this.itemHeight;
					 if (offset > 0) {
						 offset = 0;
					 }
					//System.out.println("invisible: adjusting yScrollOffset with itemHeight=" + this.itemHeight + " to " + (offset > 0 ? 0 : offset) );
					parentContainer.setScrollYOffset( offset, false );
				} else {
					int height = this.invisibleItemHeight;
					if (height == 0 && this.parent != null) {
						//System.out.println("visible getting height for available width of " + this.parent.contentWidth );
						this.isInvisible = false;
						setInitialized(false);
						height = getItemHeight( this.parent.contentWidth, this.parent.contentWidth, this.parent.contentHeight );
					} else {
						this.itemHeight = height;
					}
					offset = parentContainer.getScrollYOffset() - height;
					//System.out.println("visible: adjusting yScrollOffset with height=" + height + " to " + offset );					
					parentContainer.setScrollYOffset( offset, false );						
				}
				// adjust the internal Y position:
				Item parentItem = this;
				while (parentItem != null) {
					if (parentItem.internalX != NO_POSITION_SET) {
						if (invisible) {
							parentItem.internalY -= this.itemHeight;
						} else {
							parentItem.internalY += this.itemHeight;
						}
					}
					parentItem = parentItem.parent;
				}
			} else if (parentContainer.focusedIndex == -1)
			{
				if(visible)
				{
					//No other container is set to focused
					//so it is ASSUMED that this is the only
					//visisble item
					this.relativeY = 0;
					parentContainer.setScrollYOffset(0);
					parentContainer.focusChild(parentContainer.indexOf(this));
				}
			}
		}
		if ( invisible ) {
			this.invisibleAppearanceModeCache = this.appearanceMode;
			this.invisibleItemHeight = this.itemHeight;
			this.appearanceMode = PLAIN;
		} else {
			this.appearanceMode = this.invisibleAppearanceModeCache;
		}
		this.isInvisible = invisible;
		requestInit();
		//#endif
	}
	/**
	 * Gets the visible status of this item.
	 * Invisible items occupy no space on the UI screen and cannot be focused/traversed. 
	 * Note that you can call this method ONLY when the preprocessing variable polish.supportInvisibleItems is true or when you use the 'visible' CSS attribute.
	 * @return true when this item is visible.
	 */
	public boolean isVisible() {
		boolean result;
		//#if !tmp.invisible
			result = false;
		//#else
			result = !this.isInvisible;
		//#endif
		return result;
	}

	//#if polish.debug.error || polish.keepToString
	/**
	 * Generates a String representation of this item.
	 * This method is only implemented when the logging framework is active or the preprocessing variable 
	 * "polish.keepToString" is set to true.
	 * @return a String representation of this item.
	 */
	public String toString() {
		StringBuffer buffer = new StringBuffer();
		if (this.label != null && this.label.text != null) {
			buffer.append( '"' ).append( this.label.text ).append("\""); 
		}
		if (this.style != null) {
			buffer.append(" [").append(this.style.name).append("]");
		}
		buffer.append(": ");
		buffer.append( super.toString() );
		return buffer.toString();
	}
	//#endif

	/**
	 * Determines whether this item contains the given command.
	 * 
	 * @param command the command
	 * @return true when this item contains this command
	 */
	public boolean containsCommand(Command command) {
		return this.commands != null && this.commands.contains(command);
	}

	/**
	 * @return the default command
	 */
	public Command getDefaultCommand() {
		return this.defaultCommand;
	}

	/**
	 * @return the commands associated with this item in an arraylist - might be null!
	 */
	public ArrayList getItemCommands() {
		return this.commands;
	}
	
	/**
	 * Sets the initialized state of this item.
	 * @param initialized true when this item is deemed to be initialized, otherwise false. When setting to 'false' the item will run its init() and initContent() methods at the next option.
	 */
	public void setInitialized(boolean initialized)
	{
		this.isInitialized = initialized;
	}

	/**
	 * Determines the initialization state of this item
	 * @return true when it is initialized, false otherwise
	 */
	public boolean isInitialized()
	{
		return this.isInitialized;
	}
	
	/**
	 * Sets the item's complete height
	 * @param height the height in pixel
	 */
	public void setItemHeight( int height ) {
		int diff = height - this.itemHeight;
		//#debug
		System.out.println("setting item height " + height + ", diff=" + diff + ", vcenter=" +isLayoutVerticalCenter() + " for " + this );
		this.itemHeight = height;
		this.backgroundHeight += diff;
		if (isLayoutVerticalCenter()) {
			this.contentY += diff/2;
		} else if (isLayoutBottom()) {
			this.contentY += diff;
		}
	}
	
	/**
	 * Sets the item's complete width
	 * @param width the width in pixel
	 */
	public void setItemWidth( int width ) {
		int diff = width - this.itemWidth;
		//#debug
		System.out.println("setting item width " + width + ", diff=" + diff + ", hcenter=" +isLayoutCenter() + " for " + this );
		this.itemWidth = width;
		this.backgroundWidth += diff;
		if (isLayoutCenter()) {
			this.contentX += diff/2;
		} else if (isLayoutRight()) {
			this.contentX += diff;
		}
	}

	
	/**
	 * Retrieves the internal area's horizontal start relative to this item's content area
	 * @return the horizontal start in pixels, -1 if it not set
	 */
	public int getInternalX() {
		if (this.internalX == NO_POSITION_SET) {
			return -1;
		}
		return this.internalX;
	}

	/**
	 * Retrieves the internal area's vertical start relative to this item's content area
	 * @return the vertical start in pixels, -1 if it not set
	 */
	public int getInternalY() {
		if (this.internalX == NO_POSITION_SET) {
			return -1;
		}
		return this.internalY;
	}

	/**
	 * Retrieves the internal area's vertical width
	 * @return the vertical width in pixels, -1 if it not set
	 */
	public int getInternalWidth() {
		if (this.internalX == NO_POSITION_SET) {
			return -1;
		}
		return this.internalWidth;
	}


	/**
	 * Retrieves the internal area's vertical height
	 * @return the vertical height in pixels, -1 if it not set
	 */
	public int getInternalHeight() {
		if (this.internalX == NO_POSITION_SET) {
			return -1;
		}
		return this.internalHeight;
	}
	
	/**
	 * Fires an event for this item as well as its subitems like its label.
	 * 
	 * @param eventName the name of the event
	 * @param eventData the event data
	 * @see EventManager#fireEvent(String, Object, Object)
	 */
	public void fireEvent( String eventName, Object eventData ) {
		if (this.label != null) {
			EventManager.fireEvent(eventName, this.label, eventData);
		}
		EventManager.fireEvent(eventName, this, eventData);
	}

	/**
	 * Updates the internal area on BB and similar platforms that contain native fields.
	 */
	public void updateInternalArea() {
		// subclasses may override this.
	}

	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a right layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */
	public boolean isLayoutRight()
	{
		return this.isLayoutRight;
	}

	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a left layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */
	public boolean isLayoutLeft()
	{
		return !(this.isLayoutRight | this.isLayoutCenter);
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a center layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */
	public boolean isLayoutCenter()
	{
		return this.isLayoutCenter;
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a top layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */
	public boolean isLayoutTop()
	{
		return (this.layout & LAYOUT_BOTTOM) == 0;
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a bottom layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */
	public boolean isLayoutBottom()
	{
		return ((this.layout & LAYOUT_VCENTER) == LAYOUT_BOTTOM);
	}

	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a vcenter layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */
	public boolean isLayoutVerticalCenter()
	{
		return ((this.layout & LAYOUT_VCENTER) == LAYOUT_VCENTER);
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a vshrink layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */	
	public boolean isLayoutVerticalShrink() {
		return ((this.layout & LAYOUT_VSHRINK) == LAYOUT_VSHRINK);
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a vexpand layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */	
	public boolean isLayoutVerticalExpand() {
		return ((this.layout & LAYOUT_VEXPAND) == LAYOUT_VEXPAND);
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a horizontal expand layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */	
	public boolean isLayoutExpand() {
		return ((this.layout & LAYOUT_EXPAND) == LAYOUT_EXPAND);
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a horizontal shrink layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */	
	public boolean isLayoutShrink() {
		return ((this.layout & LAYOUT_SHRINK) == LAYOUT_SHRINK);
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a newwline-after layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */	
	public boolean isLayoutNewlineAfter() {
		return ((this.layout & LAYOUT_NEWLINE_AFTER) == LAYOUT_NEWLINE_AFTER);
	}
	
	/**
	 * Determines the layout of this item.
	 * Note that either setLayout() or init() has to be called before this method returns valid values.
	 * 
	 * @return true when the item has a newwline-after layout.
	 * @see #setLayout(int)
	 * @see #init(int,int,int)
	 */	
	public boolean isLayoutNewlineBefore() {
		return ((this.layout & LAYOUT_NEWLINE_BEFORE) == LAYOUT_NEWLINE_BEFORE);
	}
	public void setItemTransition( ItemTransition transition ) {
		this.itemTransition = transition;
	}

	public Image toImage() {
		Image img;
		//#if polish.midp2
			int[] pixels = new int[ this.itemWidth * this.itemHeight ];
			img = Image.createRGBImage( pixels, this.itemWidth, this.itemHeight, true );
		//#else
			img = Image.createImage( this.itemWidth, this.itemHeight );
		//#endif
		Graphics g = img.getGraphics();
		ItemTransition t = this.itemTransition;
		this.itemTransition = null;
		paint( 0, 0, 0, this.itemWidth, g );
		this.itemTransition = t;
		return img;
	}
	
	public RgbImage toRgbImage() {
		return new RgbImage( toImage(), true );
	}
	
	/**
	 * Determines whether this item is interactive and thus can be selected.
	 * @return true when this item is deemed to be interactive
	 */
	public boolean isInteractive() {
		return this.appearanceMode != PLAIN;
	}
	
	/**
	 * Resets the style of this item and all its children (if any).
	 * This is useful when you have applied changes to this Item's style or one of its elements.
	 * @param recursive true when all subelements of this Item should reset their style as well.
	 * @see Screen#resetStyle(boolean)
	 * @see UiAccess#resetStyle(Screen,boolean)
	 * @see UiAccess#resetStyle(Item,boolean)
	 */
	public void resetStyle(boolean recursive) {
		if (this.style != null) {
			setStyle(this.style);
		}
		if (recursive) {
			if (this.label != null) {
				this.label.resetStyle(recursive);
			}
		}
	}

	
	/**
	 * Notifies this item about a new screen size.
	 * The default implementation just checks if the design should switch to portrait or landscape-style (if those CSS attributes are used).
	 * The item will be re-initialized with its available dimensions using init(int,int,int) soon.
	 * @param screenWidth the screen width
	 * @param screenHeight the screen height
	 */
	public void onScreenSizeChanged( int screenWidth, int screenHeight ) {
		//#debug
		System.out.println("onScreenSizeChanged to " + screenWidth + ", " + screenHeight + " for " + this);
		if (this.label != null) {
			this.label.onScreenSizeChanged(screenWidth, screenHeight);
		}
		//#ifdef polish.css.view-type
		if (this.view != null) {
			this.view.onScreenSizeChanged(screenWidth, screenHeight);
		}
		//#endif
		//#if polish.css.portrait-style || polish.css.landscape-style
			if (!this.isStyleInitialised && this.style != null) {
				setStyle( this.style );
			}
			Style newStyle = null;
			if (screenWidth > screenHeight) {
				if (this.landscapeStyle != null && this.style != this.landscapeStyle) {
					newStyle = this.landscapeStyle;
				}
			} else if (this.portraitStyle != null && this.style != this.portraitStyle){
				newStyle = this.portraitStyle;
			}
			Style oldStyle = null;
			if (newStyle != null) {
				//#debug
				System.out.println("onScreenSizeChanged(): setting new style " + newStyle.name + " for " + this);
				oldStyle = this.style; 
				setStyle( newStyle );
				//#if polish.css.pressed-style
					if (this.isPressed) {
						this.normalStyle = newStyle;
					}
				//#endif
				if (this.isFocused) {
					if (this.parent instanceof Container) {
						Container cont = (Container)this.parent;
						cont.itemStyle = newStyle;
						setStyle( getFocusedStyle() );
					}
				} else if (oldStyle != null && this.parent instanceof Container) {
					Container cont = (Container)this.parent;
					if (cont.itemStyle == oldStyle) {
						cont.itemStyle = newStyle;
					}
				}
			}
		//#endif
	}
	
	/**
	 * Retrieves the available width for this item.
	 * @return the available width in pixel, can be 0 when this item has not yet been initialized
	 */
	public int getAvailableWidth() {
		return this.availableWidth;
	}
	
	/**
	 * Retrieves the available height for this item.
	 * @return the available height in pixel, can be 0 when this item has not yet been initialized
	 */
	public int getAvailableHeight() {
		return this.availableHeight;
	}

	/**
	 * Sets an UiEventListener for the this item and its children.
	 * @param listener the listener, use null to remove a listener
	 */
	public void setUiEventListener(UiEventListener listener) {
		this.uiEventListener = listener;
	}
	
	/**
	 * Retrieves the UiEventListener for this item or for one of its parents.
	 * @return the listener or null, if none has been registered
	 */
	public UiEventListener getUiEventListener() {
		UiEventListener listener = this.uiEventListener;
		if (listener == null) {
			Item parentItem = this.parent;
			while (parentItem != null && listener == null) {
				listener = parentItem.uiEventListener;
				parentItem = parentItem.parent;
			}
			if (listener == null) {
				listener = getScreen().getUiEventListener();
			}
		}
		return listener;
	}
	
	/**
	 * Retrieves the RGB data of this item.
	 * This method only works on MIDP 2.0+ devices.
	 * 
	 * @return the RGB data as an int array.
	 */
	public int[] getRgbData() {
		return getRgbData( true, 255 );
	}
	
	/**
	 * Retrieves the RGB data of this item.
	 * This method only works on MIDP 2.0+ devices.
	 * 
	 * @param supportTranslucency true when not only transparent but also translucent parts of the item should be rendered correctly 
	 * @param rgbOpacity The opacity of the item between 0 (fully transparent) and 255 (fully opaque)
	 * @return the RGB data as an int array.
	 */
	public int[] getRgbData( boolean supportTranslucency, int rgbOpacity ) {
		int[] result = new int[0];
		//#if polish.midp2
			if (this.itemWidth < 1 || this.itemHeight < 1) {
				//#debug error
				System.out.println("Unable to retrieve RGB data for item with a dimension of " + this.itemWidth + "x" + this.itemHeight + " for " + this );
				return new int[0];
			}
			Image image = Image.createImage( this.itemWidth, this.itemHeight );
			if (supportTranslucency) {
				// we use a two-pass painting for determing translucent pixels as well:
				// in the first run we paint it on a black background (dataBlack),
				// in the second we use a white background (dataWhite). 
				// We then compare the pixels in dataBlack and dataWhite:
				//  a) when a pixel is black in dataBlack and white and dataWhite it is fully transparent
				//  b) when a pixel has the same value in dataBlack and in dataWhite it is fully opaque
				//  c) when the pixel has different values it contains translucency - we can extract the original value from the difference between data1 and data2.
				//     The solution is based on this formula for determining the final green component value when adding a pixel with alpha value on another opaque pixel:
				//     final_green_value = ( pixel1_green * alpha + pixel2_green * ( 255 - alpha ) ) / 255
				//     When can work our way backwards to determine the original green and alpha  values.
				
				Graphics g = image.getGraphics();
				int bgColorBlack = 0x0;
				g.setColor(bgColorBlack);
				g.fillRect(0, 0, this.itemWidth, this.itemHeight );
				int[] transparentColorRgb = new int[1];
				image.getRGB(transparentColorRgb, 0, 1, 0, 0, 1, 1 );
				bgColorBlack = transparentColorRgb[0];
				this.paint( 0, 0, 0, this.itemWidth, g );
				int[] dataBlack = new int[  this.itemWidth * this.itemHeight ];
				image.getRGB(dataBlack, 0, this.itemWidth, 0, 0, this.itemWidth, this.itemHeight );
				int bgColorWhite = 0xffffff;
				g.setColor(bgColorWhite);
				g.fillRect(0, 0, this.itemWidth, this.itemHeight );
				image.getRGB(transparentColorRgb, 0, 1, 0, 0, 1, 1 );
				bgColorWhite = transparentColorRgb[0];
				this.paint( 0, 0, 0, this.itemWidth, g );
				int[] dataWhite = new int[  this.itemWidth * this.itemHeight ];
				image.getRGB(dataWhite, 0, this.itemWidth, 0, 0, this.itemWidth, this.itemHeight );

				rgbOpacity = (rgbOpacity << 24) | (0x00ffffff);
				result = new int[ dataBlack.length ];
				int lastPixelWhite = 0;
				int lastPixelBlack = 0;
				int lastPixelResult = 0;
				// ensure transparent parts are indeed transparent
				for (int i = 0; i < dataBlack.length; i++) {
					int pixelBlack = dataBlack[i];
					int pixelWhite = dataWhite[i];
					if (pixelBlack == pixelWhite) {
						result[i] = pixelBlack & rgbOpacity;
					} else if (pixelBlack != bgColorBlack || pixelWhite != bgColorWhite ) {
						if (pixelBlack == lastPixelBlack && pixelWhite == lastPixelWhite) {
							result[i] = lastPixelResult;
						} else {
							// this pixel contains translucency:
							int redBlack = (pixelBlack & 0xff0000) >> 16;
							int greenBlack = (pixelBlack & 0xff00) >> 8;
							int blueBlack = (pixelBlack & 0xff);
							int redWhite = (pixelWhite & 0xff0000) >> 16;
							int greenWhite = (pixelWhite & 0xff00) >> 8;
							int blueWhite = (pixelWhite & 0xff);
							
							
							int originalAlpha = 0;
							int originalRed;
							if (redBlack == 0 && redWhite == 255) {
								originalRed = 0;
							} else {
								if (redBlack == 0) {
									redBlack = 1;
								} else if (redWhite == 255) {
									redWhite = 254;
								}
								originalRed = (255 * redBlack) / (redBlack - redWhite + 255);
								originalAlpha = redBlack - redWhite + 255;
							}
							int originalGreen;
							if (greenBlack == 0 && greenWhite == 255) {
								originalGreen = 0;
							} else {
								if (greenBlack == 0) {
									greenBlack = 1;
								} else if (greenWhite == 255) {
									greenWhite = 254;
								}
								originalGreen = (255 * greenBlack) / (greenBlack - greenWhite + 255);
								originalAlpha = greenBlack - greenWhite + 255;
							}
							int originalBlue;
							if (blueBlack == 0 && blueWhite == 255) {
								originalBlue = 0;
							} else {
								if (blueBlack == 0) {
									blueBlack = 1;
								} else if (blueWhite == 255) {
									blueWhite = 254;
								}
								originalBlue = (255 * blueBlack) / (blueBlack - blueWhite + 255);
								originalAlpha = blueBlack - blueWhite + 255;
							}
							if ( originalAlpha > 255 ) {
								originalAlpha = 255;
							}
							lastPixelWhite = pixelWhite;
							lastPixelBlack = pixelBlack;
							lastPixelResult = ((originalAlpha << 24) | (originalRed << 16) | (originalGreen << 8) | originalBlue) & rgbOpacity; 
							result[i] = lastPixelResult; 
						}
					} 
				}

			} else {
				int transparentColor = 0x12345678;
				Graphics g = image.getGraphics();
				g.setColor(transparentColor);
				g.fillRect(0, 0, this.itemWidth, this.itemHeight );
				int[] transparentColorRgb = new int[1];
				image.getRGB(transparentColorRgb, 0, 1, 0, 0, 1, 1 );
				transparentColor = transparentColorRgb[0];
				this.paint( 0, 0, 0, this.itemWidth, g );
				int[] itemRgbData = new int[  this.itemWidth * this.itemHeight ];
				image.getRGB(itemRgbData, 0, this.itemWidth, 0, 0, this.itemWidth, this.itemHeight );
				boolean addOpacity = (rgbOpacity != 255);
				rgbOpacity = (rgbOpacity << 24) | (0x00ffffff);
				// ensure transparent parts are indeed transparent
				for (int i = 0; i < itemRgbData.length; i++) {
					int data = itemRgbData[i];
					if( data == transparentColor ) {
						itemRgbData[i] = 0;
					} else if (addOpacity) {
						itemRgbData[i] = data & rgbOpacity;
					}
				}
			}
		//#endif
		return result;
	}
	
	/**
	 * Fires a cycle event.
	 * The default implementation forwards the event to the  cycle listener if one is registered, otherwise it will be forwarded to the parent item.
	 * When there is neither a parent item or a cycle listener, this method will return true.
	 * 
	 * @param direction the direction, e.g. CycleListener.DIRECTION_BOTTOM_TO_TOP
	 * @return true when the cycling process can continue, false when the cycle event should be aborted
	 * @see CycleListener#DIRECTION_BOTTOM_TO_TOP
	 * @see CycleListener#DIRECTION_TOP_TO_BOTTOM
	 * @see CycleListener#DIRECTION_LEFT_TO_RIGHT
	 * @see CycleListener#DIRECTION_RIGHT_TO_LEFT
	 * @see #setCycleListener(CycleListener)
	 * @see #getCycleListener()
	 */
	public boolean fireContinueCycle( int direction ) {
		if (this.cycleListener != null) {
			return this.cycleListener.onCycle(this, direction);
		}
		if (this.parent != null) {
			return this.parent.fireContinueCycle(direction);
		}
		return true;
	}
	
	/**
	 * Allows to specify a cycle listener
	 * @param listener the listener, use null to deregister the listener
	 * @see #getCycleListener()
	 */
	public void setCycleListener( CycleListener listener ) {
		this.cycleListener = listener;
	}
	
	/**
	 * Retrieves the cycle listener
	 * @return the currently registered cycle listener
	 * @see #setCycleListener(CycleListener)
	 */
	public CycleListener getCycleListener() {
		return this.cycleListener;
	}

	
	//#if polish.useNativeGui
		/**
		 * Species a native implementation for this item.
		 * This method is only available when the preprocessing variable polish.useNativeGui is set to true.
		 * @param nativeItem the native implementation
		 */
		public void setNativeItem( NativeItem nativeItem ) {
			this.nativeItem = nativeItem;
		}
	//#endif

	//#if polish.useNativeGui
		/**
		 * Species a native implementation for this item.
		 * This method is only available when the preprocessing variable polish.useNativeGui is set to true.
		 * @return the native implementation, can be null
		 */
		public NativeItem getNativeItem() {
			return this.nativeItem;
		}
	//#endif



//#ifdef polish.Item.additionalMethods:defined
	//#include ${polish.Item.additionalMethods}
//#endif

}
