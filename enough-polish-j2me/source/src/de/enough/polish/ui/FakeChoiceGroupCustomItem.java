//#condition polish.usePolishGui && polish.LibraryBuild
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2004-2005 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.ui;

import javax.microedition.lcdui.Canvas;

import javax.microedition.lcdui.Font;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;

import de.enough.polish.util.ArrayList;
import de.enough.polish.util.Locale;

/**
 * A <code>ChoiceGroup</code> is a group of selectable elements intended to be
 * placed within a <CODE>Form</CODE>. The group may be created with a mode that requires a
 * single choice to be made or that allows multiple choices. The
 * implementation is responsible for providing the graphical representation of
 * these modes and must provide visually different graphics for different
 * modes. For example, it might use &quot;radio buttons&quot; for the
 * single choice
 * mode and &quot;check boxes&quot; for the multiple choice mode.
 * 
 * <p> <strong>Note:</strong> most of the essential methods have been
 * specified in the <CODE>Choice</CODE> interface.</p>
 * <HR>
 * 
 * @author Robert Virkus, robert@enough.de
 * @since MIDP 1.0
 */
public class FakeChoiceGroupCustomItem 
extends FakeContainerCustomItem 
implements Choice
//#if polish.ChoiceGroup.suppressMarkCommands == true
	//#define tmp.suppressMarkCommands
//#else
	//#define tmp.allowMarkCommands
//#endif
//#if polish.ChoiceGroup.suppressSelectCommand == true
	//#define tmp.suppressSelectCommand
//#else
	//#define tmp.allowSelectCommand
//#endif

//#if tmp.suppressMarkCommands && tmp.suppressSelectCommand
	//#define tmp.suppressAllCommands
//#else
	, ItemCommandListener
//#endif
{
	//#ifndef tmp.suppressMarkCommands
	//#ifdef polish.i18n.useDynamicTranslations
		public static Command MARK_COMMAND = new Command( Locale.get("polish.command.mark"), Command.ITEM, 9 );
	//#elifdef polish.command.mark:defined
		//#= public static final Command MARK_COMMAND = new Command("${polish.command.mark}", Command.ITEM, 9 );
	//#else
		//# public static final Command MARK_COMMAND = new Command( "Mark", Command.ITEM, 9 );
	//#endif
	//#ifdef polish.i18n.useDynamicTranslations
		public static Command UNMARK_COMMAND = new Command( Locale.get("polish.command.unmark"), Command.ITEM, 9 );
	//#elifdef polish.command.mark:defined
		//#= public static final Command UNMARK_COMMAND = new Command("${polish.command.unmark}", Command.ITEM, 10 );
	//#else
		//# public static final Command UNMARK_COMMAND = new Command( "Unmark", Command.ITEM, 10 );
	//#endif
//#endif
private int selectedIndex;
//private boolean isExclusive;
private boolean isMultiple;
protected int choiceType;
private boolean isImplicit;
private Command selectCommand;
//#ifdef polish.usePopupItem
	private static Image popupImage;
	private boolean isPopup;
	private int popupColor = 0;
	private int popupBackgroundColor = 0xFFFFFF;
	private IconItem popupItem;
	private boolean isPopupClosed;
	//#ifdef polish.css.popup-roundtrip
		private boolean popupRoundTrip;
	//#endif
	//private int popupOpenY;
	private int popupParentOpenY;
	private int originalContentWidth;
	private int originalContentHeight;
	private int originalBackgroundHeight;
	private boolean closePopupOnKeyRelease;
//#endif
//#ifndef tmp.suppressAllCommands
	private ItemCommandListener additionalItemCommandListener;
//#endif
//#if polish.css.view-type || polish.css.columns
	//#define tmp.supportViewType 
//#endif	
//#if ! tmp.suppressSelectCommand && tmp.supportViewType
	private boolean isSelectCommandAdded;
//#endif
//#ifdef polish.hasPointerEvents
	private boolean isPointerReleaseShouldTriggerKeyRelease;
//#endif


/**
 * Creates a new, empty <code>ChoiceGroup</code>, specifying its
 * title and its type.
 * The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>. The
 * <code>IMPLICIT</code>
 * choice type is not allowed within a <code>ChoiceGroup</code>.
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE,  or POPUP
 * @throws IllegalArgumentException - if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
 * @see Choice#EXCLUSIVE 
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType)
{
	this( label, choiceType, new String[0], null, null, false );
}

/**
 * Creates a new, empty <code>ChoiceGroup</code>, specifying its
 * title and its type.
 * The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>. The
 * <code>IMPLICIT</code>
 * choice type is not allowed within a <code>ChoiceGroup</code>.
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE,  or POPUP
 * @param style the CSS style for this item
 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType, Style style)
{
	this( label, choiceType, new String[0], null, style, false );
}

/**
 * Creates a new <code>ChoiceGroup</code>, specifying its title,
 * the type of the
 * <code>ChoiceGroup</code>, and an array of <code>Strings</code>
 * and <code>Images</code> to be used as its
 * initial contents.
 * 
 * <p>The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
 * <code>IMPLICIT</code>
 * type is not allowed for <code>ChoiceGroup</code>.</p>
 * 
 * <p>The <code>stringElements</code> array must be non-null and
 * every array element
 * must also be non-null.  The length of the
 * <code>stringElements</code> array
 * determines the number of elements in the <code>ChoiceGroup</code>.  The
 * <code>imageElements</code> array
 * may be <code>null</code> to indicate that the
 * <code>ChoiceGroup</code> elements have no images.
 * If the
 * <code>imageElements</code> array is non-null, it must be the
 * same length as the
 * <code>stringElements</code> array.  Individual elements of the
 * <code>imageElements</code> array
 * may be <code>null</code> in order to indicate the absence of an
 * image for the
 * corresponding <code>ChoiceGroup</code> element.  Non-null elements
 * of the
 * <code>imageElements</code> array may refer to mutable or
 * immutable images.</p>
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
 *   			 or  if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType, String[] stringElements, Image[] imageElements)
{
	this( label, choiceType, stringElements, imageElements, null, false );
}

/**
 * Creates a new <code>ChoiceGroup</code>, specifying its title,
 * the type of the
 * <code>ChoiceGroup</code>, and an array of <code>Strings</code>
 * and <code>Images</code> to be used as its
 * initial contents.
 * 
 * <p>The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
 * <code>IMPLICIT</code>
 * type is not allowed for <code>ChoiceGroup</code>.</p>
 * 
 * <p>The <code>stringElements</code> array must be non-null and
 * every array element
 * must also be non-null.  The length of the
 * <code>stringElements</code> array
 * determines the number of elements in the <code>ChoiceGroup</code>.  The
 * <code>imageElements</code> array
 * may be <code>null</code> to indicate that the
 * <code>ChoiceGroup</code> elements have no images.
 * If the
 * <code>imageElements</code> array is non-null, it must be the
 * same length as the
 * <code>stringElements</code> array.  Individual elements of the
 * <code>imageElements</code> array
 * may be <code>null</code> in order to indicate the absence of an
 * image for the
 * corresponding <code>ChoiceGroup</code> element.  Non-null elements
 * of the
 * <code>imageElements</code> array may refer to mutable or
 * immutable images.</p>
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
 * @param style The CSS style for this item
 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
 *   			 or  if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType, String[] stringElements, Image[] imageElements, Style style )
{
	this( label, choiceType, stringElements, imageElements, style, false );
}

/**
 * Creates a new <code>ChoiceGroup</code>, specifying its title,
 * the type of the
 * <code>ChoiceGroup</code>, and an array of <code>Strings</code>
 * and <code>Images</code> to be used as its
 * initial contents.
 * 
 * <p>The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
 * <code>IMPLICIT</code>
 * type is not allowed for <code>ChoiceGroup</code>.</p>
 * 
 * <p>The <code>stringElements</code> array must be non-null and
 * every array element
 * must also be non-null.  The length of the
 * <code>stringElements</code> array
 * determines the number of elements in the <code>ChoiceGroup</code>.  The
 * <code>imageElements</code> array
 * may be <code>null</code> to indicate that the
 * <code>ChoiceGroup</code> elements have no images.
 * If the
 * <code>imageElements</code> array is non-null, it must be the
 * same length as the
 * <code>stringElements</code> array.  Individual elements of the
 * <code>imageElements</code> array
 * may be <code>null</code> in order to indicate the absence of an
 * image for the
 * corresponding <code>ChoiceGroup</code> element.  Non-null elements
 * of the
 * <code>imageElements</code> array may refer to mutable or
 * immutable images.</p>
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
 * @param style The CSS style for this item
 * @param allowImplicit true when the Choice.IMPLICIT choiceType is also allowed
 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
 *   			 or  if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType, String[] stringElements, Image[] imageElements, Style style, boolean allowImplicit )
{
	this( label, choiceType, 
			buildChoiceItems(stringElements, imageElements, choiceType, style),
			style, allowImplicit );
}

/**
 * Creates a new <code>ChoiceGroup</code>, specifying its title,
 * the type of the
 * <code>ChoiceGroup</code>, and an array of <code>ChoiceItem</code>s
 * to be used as its initial contents.
 * 
 * <p>The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
 * <code>IMPLICIT</code>
 * type is not allowed for <code>ChoiceGroup</code>.</p>
 * 
 * <p>The <code>items</code>s array must be non-null and
 * every <code>ChoiceItem</code> must have its text be a non-null
 * <code>String</code>.
 * The length of the <code>items</code> array
 * determines the number of elements in the <code>ChoiceGroup</code>.</p>
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
 * @param items set of <code>ChoiceItem</code>s specifying the ChoiceGroup elements
 * @throws NullPointerException if <code>items</code> is null 
 *         or if getText() for one of the <code>ChoiceItem</code> in the array 
 *         retuns a null <code>String</code>.
 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType, ChoiceItem[] items)
{
	this( label, choiceType, items, null, false );
}

/**
 * Creates a new <code>ChoiceGroup</code>, specifying its title,
 * the type of the
 * <code>ChoiceGroup</code>, and an array of <code>ChoiceItem</code>s
 * to be used as its initial contents.
 * 
 * <p>The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
 * <code>IMPLICIT</code>
 * type is not allowed for <code>ChoiceGroup</code>.</p>
 * 
 * <p>The <code>items</code>s array must be non-null and
 * every <code>ChoiceItem</code> must have its text be a non-null
 * <code>String</code>.
 * The length of the <code>items</code> array
 * determines the number of elements in the <code>ChoiceGroup</code>.</p>
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
 * @param items set of <code>ChoiceItem</code>s specifying the ChoiceGroup elements
 * @param style The CSS style for this item
 * @throws NullPointerException if <code>items</code> is null 
 *         or if getText() for one of the <code>ChoiceItem</code> in the array 
 *         retuns a null <code>String</code>.
 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType, ChoiceItem[] items, Style style )
{
	this( label, choiceType, items, style, false );
}

/**
 * Creates a new <code>ChoiceGroup</code>, specifying its title,
 * the type of the
 * <code>ChoiceGroup</code>, and an array of <code>ChoiceItem</code>s
 * to be used as its initial contents.
 * 
 * <p>The type must be one of <code>EXCLUSIVE</code>,
 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
 * <code>IMPLICIT</code>
 * type is not allowed for <code>ChoiceGroup</code>.</p>
 * 
 * <p>The <code>items</code>s array must be non-null and
 * every <code>ChoiceItem</code> must have its text be a non-null
 * <code>String</code>.
 * The length of the <code>items</code> array
 * determines the number of elements in the <code>ChoiceGroup</code>.</p>
 * 
 * @param label the item's label (see Item)
 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
 * @param items set of <code>ChoiceItem</code>s specifying the ChoiceGroup elements
 * @param style The CSS style for this item
 * @param allowImplicit true when the Choice.IMPLICIT choiceType is also allowed
 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
public FakeChoiceGroupCustomItem( String label, int choiceType, ChoiceItem[] items, Style style, boolean allowImplicit )
{
	super( label, false, style, -1 );
	if (choiceType == Choice.EXCLUSIVE) {
		//this.isExclusive = true;
	} else if (choiceType == Choice.MULTIPLE) {
		this.isMultiple = true;
	//#ifdef polish.usePopupItem
	} else if (choiceType == Choice.POPUP) {
		this.isPopup = true;
		this.isPopupClosed = true;
		this.popupItem = new IconItem( null, null, style );
		this.popupItem.setImageAlign( Graphics.RIGHT );
		this.popupItem.setAppearanceMode( BUTTON );
	//#endif
	} else if (choiceType == Choice.IMPLICIT && allowImplicit ) {
		this.isImplicit = true;
		this.autoFocusEnabled = true;
	} else {
		throw new IllegalArgumentException(
		//#ifdef polish.verboseDebug
			"invalid choiceType [" + choiceType + "] - IMPLICIT=" + Choice.IMPLICIT + "."
		//#endif
		);
	}
	this.choiceType = choiceType;
	if (items != null) {
		for (int i = 0; i < items.length; i++) {
			ChoiceItem item = items[i];
			append( item );
		}
	}
}

/**
 * Builds an array of <code>ChoiceItems</code> out of
 * an array of <code>String</code>s and <code>Image</code>s,
 * specifying the <code>choiceType</code> and <code>style</code>
 * common to any <code>ChoiceItem</code> in the resulting array.
 * 
 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
 * @param style The CSS style for this item
 * @return an aray of choice items
 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
 * @see Choice#EXCLUSIVE
 * @see Choice#MULTIPLE
 * @see Choice#IMPLICIT
 * @see Choice#POPUP
 */
protected static ChoiceItem[] buildChoiceItems(String[] stringElements, Image[] imageElements, int choiceType, Style style)
{
	//#ifndef polish.skipArgumentCheck
		if (imageElements != null && imageElements.length != stringElements.length) {
			//#ifdef polish.verboseDebug
				throw new IllegalArgumentException("imageElements need to have the same length as the stringElements.");
			//#else
				//# throw new IllegalArgumentException();
			//#endif
		}
	//#endif
	ChoiceItem[] items = new ChoiceItem[stringElements.length];
	for (int i = 0; i < stringElements.length; ++i) {
		Image img = null;
		if (imageElements != null) {
			img = imageElements[i];
		}
		items[i] = new ChoiceItem( stringElements[i], img, choiceType, style );
	}
	return items;
}

//#ifdef polish.usePopupItem
/**
 * Creates or returns the default image for popup groups.
 * 
 * @return the default popup image
 */
protected Image createPopupImage() {
	if (popupImage == null) {
		popupImage = Image.createImage( 9, 12 );
		Graphics g = popupImage.getGraphics();
		g.setColor( this.popupBackgroundColor );
		g.fillRect(0, 0, 10, 13 );
		g.setColor( this.popupColor );
		g.drawLine(0, 0, 9, 0 );
		g.drawLine( 3, 3, 3, 9 );
		g.drawLine( 4, 3, 4, 10 );
		g.drawLine( 5, 3, 5, 9 );
		g.drawLine( 2, 8, 6, 8 );	
		g.drawLine( 1, 7, 7, 7 );	
	}
	return popupImage;
}
//#endif

/**
 * Gets the <code>String</code> part of the element referenced by
 * <code>elementNum</code>.
 * 
 * @param elementNum the index of the element to be queried
 * @return the string part of the element
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @see Choice#getString(int) in interface Choice
 * @see #getImage(int)
 */
public String getString(int elementNum)
{
	ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
	return item.getText();
}

/**
 * Gets the <code>Image</code> part of the element referenced by
 * <code>elementNum</code>.
 * 
 * @param elementNum the number of the element to be queried
 * @return the image part of the element, or null if there is no image
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @see Choice#getImage(int) in interface Choice
 * @see #getString(int)
 */
public Image getImage(int elementNum)
{
	ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
	return item.getImage();
}

/**
 * Gets the <code>ChoiceItem</code> of the element referenced by
 * <code>elementNum</code>.
 *
 * @param elementNum the number of the element to be queried
 * @return the ChoiceItem of the element
 * @throws IndexOutOfBoundsException if elementNum is invalid
 */
public ChoiceItem getItem( int elementNum )
{
	return (ChoiceItem)this.itemsList.get( elementNum );
}

/**
 * Appends an element to the <code>ChoiceGroup</code>.
 * 
 * @param stringPart the string part of the element to be added
 * @param imagePart the image part of the element to be added, or null if there is no image part
 * @return the assigned index of the element
 * @throws NullPointerException if stringPart is null
 * @see Choice#append( String, Image) in interface Choice
 */
public int append( String stringPart, Image imagePart)
{
	return append( stringPart, imagePart, null );
}

/**
 * Appends an element to the <code>ChoiceGroup</code>.
 * 
 * @param stringPart the string part of the element to be added
 * @param imagePart the image part of the element to be added, or null if there is no image part
 * @param elementStyle the style for the appended ChoiceItem
 * @return the assigned index of the element
 * @throws NullPointerException if stringPart is null
 * @see Choice#append( String, Image) in interface Choice
 */
public int append( String stringPart, Image imagePart, Style elementStyle )
{
	ChoiceItem item = new ChoiceItem( stringPart, imagePart, this.choiceType, elementStyle );
	return append( item, elementStyle );
}

/**
 * Appends a ChoiceItem to this choice group.
 * 
 * @param item the item
 * @return the assigned index of the element
 */
public int append( ChoiceItem item ) {
	return append( item, null );
}
/**
 * Appends a ChoiceItem to this choice group.
 * 
 * @param item the item
 * @param elementStyle the style of the item, ignored when null
 * @return the assigned index of the element
 */
public int append( ChoiceItem item, Style elementStyle ) {
	add( item );
	if ( elementStyle != null ) {
		item.setStyle( elementStyle );
	}
	int itemIndex = this.itemsList.size() - 1;
	if (this.choiceType == Choice.EXCLUSIVE && item.isSelected) {
		if (this.selectedIndex != -1) {
			((ChoiceItem)get( this.selectedIndex )).select( false );
		}
		this.selectedIndex = itemIndex;
	}
	//#if ! tmp.suppressMarkCommands
		if (this.isMultiple) {
			selectChoiceItem(item, item.isSelected);
			item.setItemCommandListener( this );
		}
	//#endif
	//#ifdef polish.usePopupItem
		if (this.isPopup && this.isPopupClosed && this.selectedIndex == -1) {
			this.popupItem.setText( item.text );
			this.selectedIndex = 0;
		}
	//#endif
	return itemIndex;
}

/**
 * Inserts an element into the <code>ChoiceGroup</code> just prior to
 * the element specified.
 * 
 * @param elementNum the index of the element where insertion is to occur
 * @param stringPart the string part of the element to be inserted
 * @param imagePart the image part of the element to be inserted, or null if there is no image part
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @throws NullPointerException if stringPart is null
 * @see Choice#insert(int, String, Image)  in interface Choice
 */
public void insert(int elementNum, String stringPart, Image imagePart)
{
	insert( elementNum, stringPart, imagePart, null );
}

/**
 * Inserts an element into the <code>ChoiceGroup</code> just prior to
 * the element specified.
 * 
 * @param elementNum the index of the element where insertion is to occur
 * @param stringPart the string part of the element to be inserted
 * @param imagePart the image part of the element to be inserted, or null if there is no image part
 * @param elementStyle the style for the inserted ChoiceItem
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @throws NullPointerException if stringPart is null
 * @see Choice#insert(int, String, Image)  in interface Choice
 */
public void insert(int elementNum, String stringPart, Image imagePart, Style elementStyle)
{
	ChoiceItem item = new ChoiceItem( stringPart, imagePart, this.choiceType, elementStyle );
	add(elementNum, item);
}

/**
 * Inserts an element into the <code>ChoiceGroup</code> just prior to
 * the element specified.
 * 
 * @param elementNum the index of the element where insertion is to occur
 * @param item ChoiceItem of the element to be inserted
 * @throws IndexOutOfBoundsException if elementNum is invalid
 */
public void insert(int elementNum, ChoiceItem item)
{
	add(elementNum, item);
}

/**
 * Inserts an element into the <code>ChoiceGroup</code> just prior to
 * the element specified.
 * 
 * @param elementNum the index of the element where insertion is to occur
 * @param item ChoiceItem of the element to be inserted
 * @param elementStyle the style for the inserted ChoiceItem
 * @throws IndexOutOfBoundsException if elementNum is invalid
 */
public void insert(int elementNum, ChoiceItem item, Style elementStyle)
{
	if (elementStyle != null) {
		item.setStyle(elementStyle);
	}
	add(elementNum, item);
}

/**
 * Sets the <code>String</code> and <code>Image</code> parts of the
 * element referenced by <code>elementNum</code>,
 * replacing the previous contents of the element.
 * 
 * @param elementNum - the index of the element to be set
 * @param stringPart - the string part of the new element
 * @param imagePart - the image part of the element, or null if there is no image part
 * @throws IndexOutOfBoundsException - if elementNum is invalid
 * @throws NullPointerException - if stringPart is null
 * @see Choice#set(int, String, Image) in interface Choice
 */
public void set(int elementNum, String stringPart, Image imagePart)
{
	set( elementNum, stringPart, imagePart, null );
}

/**
 * Sets the <code>String</code> and <code>Image</code> parts of the
 * element referenced by <code>elementNum</code>,
 * replacing the previous contents of the element.
 * 
 * @param elementNum the index of the element to be set
 * @param stringPart the string part of the new element
 * @param imagePart the image part of the element, or null if there is no image part
 * @param elementStyle the style for the new list element.
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @throws NullPointerException if stringPart is null
 * @see Choice#set(int, String, Image) in interface Choice
 */
public void set(int elementNum, String stringPart, Image imagePart, Style elementStyle )
{
	ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
	item.setText( stringPart );
	if (imagePart != null) {
		item.setImage(imagePart);
	}
	if (elementStyle != null) {
		item.setStyle(elementStyle);
	}

	if (isInitialized()) {
		isInitialized = false;
		repaint();
	}
}

///**
// * Sets the <code>ChoiceItem</code> of the
// * element referenced by <code>elementNum</code>,
// * replacing the previous one.
// * 
// * @param elementNum the index of the element to be set
// * @param item the ChoiceItem of the new element
// * @throws IndexOutOfBoundsException if elementNum is invalid
// */
//public void set(int elementNum, ChoiceItem item )
//{
//	super.set(elementNum, item);
//	if (this.isInitialized) {
//		this.isInitialized = false;
//		repaint();
//	}
//}

///**
// * Sets the <code>ChoiceItem</code> of the
// * element referenced by <code>elementNum</code>,
// * replacing the previous one.
// * 
// * @param elementNum the index of the element to be set
// * @param item the ChoiceItem of the new element
// * @param elementStyle the style for the new list element.
// * @throws IndexOutOfBoundsException if elementNum is invalid
// */
//public void set(int elementNum, ChoiceItem item, Style elementStyle )
//{
//	if (elementStyle != null) {
//		item.setStyle(elementStyle);
//	}
//	delete( elementNum );
//	add( elementNum, item );
//	if (this.isInitialized) {
//		this.isInitialized = false;
//		repaint();
//	}
//}

/**
 * Deletes the element referenced by <code>elementNum</code>.
 * 
 * @param elementNum the index of the element to be deleted
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @see Choice#delete(int) in interface Choice
 */
public void delete(int elementNum)
{
	remove(elementNum);
	//#ifdef polish.usePopupItem
		if (this.isPopup) {
			if (this.selectedIndex == elementNum ) {
				if (this.itemsList.size() > 0) {
					this.selectedIndex = -1;
					if (this.isPopupClosed) {
						setSelectedIndex( 0, true );
					}
				} else {
					this.selectedIndex = -1;
				}
			} else if ( elementNum < this.selectedIndex ) {
				this.selectedIndex--;
			}
		} else {
	//#endif
		if (this.selectedIndex == elementNum ) {
			this.selectedIndex = -1;
		} else if (elementNum < this.selectedIndex) {
			this.selectedIndex--;
		}
	//#ifdef polish.usePopupItem
		}
	//#endif
}

/**
 * Deletes all elements from this <code>ChoiceGroup</code>.
 * 
 * @see Choice#deleteAll() in interface Choice
 */
public void deleteAll()
{
	clear();
	this.selectedIndex = -1;
}


/**
 * Gets a boolean value indicating whether this element is selected.
 * 
 * @param elementNum the index of the element to be queried
 * @return selection state of the element
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @see Choice#isSelected(int) in interface Choice
 */
public boolean isSelected(int elementNum)
{
	ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
	return item.isSelected;
}

/**
 * Returns the index number of an element in the
 * <code>ChoiceGroup</code> that is
 * selected. For <code>ChoiceGroup</code> objects of type
 * <code>EXCLUSIVE</code> and <code>POPUP</code>
 * there is at most one element selected, so
 * this method is useful for determining the user's choice.
 * Returns <code>-1</code> if
 * there are no elements in the <code>ChoiceGroup</code>.
 * 
 * <p>For <code>ChoiceGroup</code> objects of type
 * <code>MULTIPLE</code>, this always
 * returns <code>-1</code> because no
 * single value can in general represent the state of such a
 * <code>ChoiceGroup</code>.
 * To get the complete state of a <code>MULTIPLE</code>
 * <code>Choice</code>, see <A HREF="../../../javax/microedition/lcdui/ChoiceGroup.html#getSelectedFlags(boolean[])"><CODE>getSelectedFlags</CODE></A>.</p>
 * 
 * @return index of selected element, or -1 if none
 * @see Choice#getSelectedIndex() in interface Choice
 * @see #setSelectedIndex(int, boolean)
 */
public int getSelectedIndex()
{
	if (this.isMultiple || this.itemsList.size() == 0) {
		return -1;
	} else if (!this.isImplicit || this.focusedIndex == -1) {
		return this.selectedIndex;
	} else {
		// this is an implicit/focused choice:
		return this.focusedIndex;
	}
}

/**
 * Queries the state of a <code>ChoiceGroup</code> and returns the state of
 * all elements in the
 * boolean array
 * <code>selectedArray_return</code>. <strong>Note:</strong> this
 * is a result parameter.
 * It must be at least as long as the size
 * of the <code>ChoiceGroup</code> as returned by <code>size()</code>.
 * If the array is longer, the extra
 * elements are set to <code>false</code>.
 * 
 * <p>For <code>ChoiceGroup</code> objects of type
 * <code>MULTIPLE</code>, any
 * number of elements may be selected and set to true in the result
 * array.  For <code>ChoiceGroup</code> objects of type
 * <code>EXCLUSIVE</code> and <code>POPUP</code>
 * exactly one element will be selected, unless there are
 * zero elements in the <code>ChoiceGroup</code>. </p>
 * 
 * @param selectedArray_return array to contain the results
 * @return the number of selected elements in the ChoiceGroup
 * @throws IllegalArgumentException if selectedArray_return is shorter than the size of the ChoiceGroup
 * @throws NullPointerException if selectedArray_return is null
 * @see Choice#getSelectedFlags(boolean[]) in interface Choice
 * @see #setSelectedFlags(boolean[])
 */
public int getSelectedFlags(boolean[] selectedArray_return)
{
	//#ifndef polish.skipArgumentCheck
		if (selectedArray_return.length < this.itemsList.size()) {
			//#ifdef polish.verboseDebug
				throw new IllegalArgumentException("length of selectedArray is too small");
			//#else
				//# throw new IllegalArgumentException();
			//#endif
		}
	//#endif
	ChoiceItem[] myItems = (ChoiceItem[]) this.itemsList.toArray( new ChoiceItem[ this.itemsList.size() ] );
	int selectedItems = 0;
	for (int i = 0; i < myItems.length; i++) {
		ChoiceItem item = myItems[i];
		if (item.isSelected || (this.isImplicit && i == this.focusedIndex) ) {
			selectedArray_return[i] = true;
			selectedItems++;
		} else {
			selectedArray_return[i] = false;
		}
	}
	return selectedItems;
}

/**
 * For <code>ChoiceGroup</code> objects of type
 * <code>MULTIPLE</code>, this simply sets an
 * individual element's selected state.
 * 
 * <P>For <code>ChoiceGroup</code> objects of type
 * <code>EXCLUSIVE</code> and <code>POPUP</code>, this can be used only to
 * select an element.  That is, the <code> selected </code> parameter must
 * be <code> true </code>. When an element is selected, the previously
 * selected element is deselected. If <code> selected </code> is <code>
 * false </code>, this call is ignored.</P>
 * 
 * <p>For both list types, the <code>elementNum</code> parameter
 * must be within
 * the range
 * <code>[0..size()-1]</code>, inclusive. </p>
 * 
 * @param elementNum the number of the element. Indexing of the elements is zero-based
 * @param selected the new state of the element true=selected, false=not selected
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @see Choice#setSelectedIndex(int, boolean) in interface Choice
 * @see #getSelectedIndex()
 */
public void setSelectedIndex(int elementNum, boolean selected)
{
	//#debug
	System.out.println("setSelectedIndex: index="  + elementNum + ", selected=" + selected + ", current selectedIndex=" + this.selectedIndex) ;
	if (this.isMultiple) {
		ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
		selectChoiceItem(item, selected);
	} else {
		if (!selected) {
			return; // ignore this call
		}
		if (this.selectedIndex != -1) {
			ChoiceItem oldSelected = (ChoiceItem) this.itemsList.get( this.selectedIndex );
			oldSelected.select( false );
		}
		
		if(elementNum != -1)
		{
			ChoiceItem newSelected = (ChoiceItem) this.itemsList.get( elementNum );
			newSelected.select( true );
			
			if (this.isFocused) {
				if ( this.isInitialized) {
					focusChild( elementNum, newSelected, 0, true);
				} else {
					this.autoFocusEnabled = true;
					this.autoFocusIndex = elementNum;
				}
			}
			//#ifdef polish.usePopupItem
				if (this.isPopup) {
					this.popupItem.setText( newSelected.getText() );
				}
			//#endif
		}		
		
		this.selectedIndex = elementNum;
	}
	if (this.isInitialized) {
		this.isInitialized = false;
		repaint();
	}
}

/**
 * Attempts to set the selected state of every element in the
 * <code>ChoiceGroup</code>. The array
 * must be at least as long as the size of the
 * <code>ChoiceGroup</code>. If the array is
 * longer, the additional values are ignored. <p>
 * 
 * For <code>ChoiceGroup</code> objects of type
 * <code>MULTIPLE</code>, this sets the selected
 * state of every
 * element in the <code>Choice</code>. An arbitrary number of
 * elements may be selected.
 * <p>
 * 
 * For <code>ChoiceGroup</code> objects of type
 * <code>EXCLUSIVE</code> and <code>POPUP</code>, exactly one array
 * element must have the value <code>true</code>. If no element is
 * <code>true</code>,
 * the first element
 * in the <code>Choice</code> will be selected. If two or more
 * elements are <code>true</code>, the
 * implementation will choose the first <code>true</code> element
 * and select it. <p>
 * 
 * @param selectedArray an array in which the method collect the selection status
 * @throws IllegalArgumentException if selectedArray is shorter than the size of the ChoiceGroup
 * @throws NullPointerException if the selectedArray is null
 * @see Choice#setSelectedFlags(boolean[]) in interface Choice
 * @see #getSelectedFlags(boolean[])
 */
public void setSelectedFlags(boolean[] selectedArray)
{
	if (selectedArray == null || selectedArray.length == 0) {
		// ignore these flags
		return;
	}
	//#ifndef polish.skipArgumentCheck
		if (selectedArray.length < this.itemsList.size()) {
			//#ifdef polish.verboseDebug
				throw new IllegalArgumentException("length of selectedArray is too small");
			//#else
				//# throw new IllegalArgumentException();
			//#endif
		}
	//#endif
	if (this.isMultiple) {
		ChoiceItem[] myItems = (ChoiceItem[]) this.itemsList.toArray( new ChoiceItem[ this.itemsList.size() ] );
		for (int i = 0; i < myItems.length; i++) {
			ChoiceItem item = myItems[i];
			boolean isSelected = selectedArray[i];
			selectChoiceItem(item, isSelected);
		}
	} else {
		int index = 0;
		for (int i = 0; i < selectedArray.length; i++) {
			if (selectedArray[i]) {
				index = i;
				break;
			}
		}
		if (index > this.itemsList.size()) {
			index = 0;
		}
		setSelectedIndex( index, true );
	}
	if (this.isInitialized) {
		this.isInitialized = false;
		repaint();
	}
}

/**
 * Sets the application's preferred policy for fitting
 * <code>Choice</code> element contents to the available screen space. The set policy applies for all
 * elements of the <code>Choice</code> object.  Valid values are
 * <CODE>Choice.TEXT_WRAP_DEFAULT</CODE>, 
 * <CODE>Choice.TEXT_WRAP_ON</CODE>,
 * and <CODE>Choice.TEXT_WRAP_OFF</CODE>. 
 * Fit policy is a hint, and the
 * implementation may disregard the application's preferred policy.
 * The J2ME Polish implementation always uses the TEXT_WRAP_ON policy.
 * 
 * @param fitPolicy preferred content fit policy for choice elements
 * @see Choice#setFitPolicy(int) in interface Choice
 * @see #getFitPolicy()
 * @since  MIDP 2.0
 */
public void setFitPolicy(int fitPolicy)
{
	//this.fitPolicy = fitPolicy;
	// ignore hint
}

/**
 * Gets the application's preferred policy for fitting
 * <code>Choice</code> element contents to the available screen space.  The value returned is the
 * policy that had been set by the application, even if that value had
 * been disregarded by the implementation.
 * 
 * @return always Choice.TEXT_WRAP_ON
 * @see Choice#getFitPolicy() in interface Choice
 * @see #setFitPolicy(int)
 * @since  MIDP 2.0
 */
public int getFitPolicy()
{
	return Choice.TEXT_WRAP_ON;
}

/**
 * Sets the application's preferred font for
 * rendering the specified element of this <code>Choice</code>.
 * An element's font is a hint, and the implementation may disregard
 * the application's preferred font.
 * The J2ME Polish implementation uses the font defined by the appropriate
 * CSS style and ignores the font which is set here.
 * 
 * @param elementNum the index of the element, starting from zero
 * @param font the preferred font to use to render the element
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @see Choice#setFont(int, Font) in interface Choice
 * @see #getFont(int)
 * @since  MIDP 2.0
 */
public void setFont(int elementNum, Font font)
{
	ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
	item.setPreferredFont( font );
}

/**
 * Gets the application's preferred font for
 * rendering the specified element of this <code>Choice</code>. The
 * value returned is the font that had been set by the application,
 * even if that value had been disregarded by the implementation.
 * If no font had been set by the application, or if the application
 * explicitly set the font to <code>null</code>, the value is the default
 * font chosen by the implementation.
 * 
 * <p> The <code>elementNum</code> parameter must be within the range
 * <code>[0..size()-1]</code>, inclusive.</p>
 * 
 * @param elementNum the index of the element, starting from zero
 * @return the preferred font to use to render the element
 * @throws IndexOutOfBoundsException if elementNum is invalid
 * @see Choice#getFont(int) in interface Choice
 * @see #setFont(int elementNum, Font font)
 * @since  MIDP 2.0
 */
public Font getFont(int elementNum)
{
	ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
	Font font = item.preferredFont;
	if (font == null) {
		font = item.font;
	}
	return font;
}
//#ifdef polish.usePopupItem
protected void hideNotify() {
	if (this.isPopup && !this.isPopupClosed) {
		closePopup();
	}
}
//#endif

//#ifdef polish.usePopupItem
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#paint(int, int, javax.microedition.lcdui.Graphics)
 */
public void paintContent(int x, int y, int leftBorder, int rightBorder, Graphics g) {
	//#if tmp.supportViewType
		if (this.containerView != null) {
			super.paintContent(x, y, leftBorder, rightBorder, g);
			return;
		}
	//#endif
	if (this.isPopup && this.isPopupClosed) {
		int availWidth = rightBorder - leftBorder;
		if (availWidth < this.popupItem.contentWidth) {
			this.popupItem.init(availWidth, availWidth, this.availableHeight);
		}
		this.popupItem.paintContent(x, y, leftBorder, rightBorder, g);
	} else {
		//System.out.println("painting popup content at y=" + y + ", yScrollOffse=" + this.yOffset + ", clipY=" + g.getClipY() + ", clipHeight=" + g.getClipHeight());
		super.paintContent(x, y, leftBorder, rightBorder, g );
	}
}
//#endif

//#ifdef polish.usePopupItem
protected void init( int firstLineWidth, int availWidth, int availHeight ) {
	super.init(firstLineWidth, availWidth, availHeight);
	//#if tmp.supportViewType
		if (this.containerView != null) {
			return;
		}
	//#endif
	if (this.isPopup && !this.isPopupClosed) {
		this.backgroundWidth += (this.originalContentWidth - this.contentWidth); 
		this.backgroundHeight += (this.originalContentHeight - this.contentHeight); 
	}
}
//#endif


//#ifdef polish.usePopupItem
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#initItem()
 */
protected void initContent(int firstLineWidth, int availWidth, int availHeight) {
	super.initContent(firstLineWidth, availWidth, availHeight);
	//#if tmp.supportViewType
		if (this.containerView != null) {
			return;
		}
	//#endif
	if (this.isPopup) {
		//System.out.println("initContent of POPUP " + this + ", isClosed=" + this.isPopupClosed );
		if (this.popupItem.image == null) {
			this.popupItem.setImage( createPopupImage() );
		}
		if (this.isPopupClosed) {
			if (this.popupItem.getText() == null && this.itemsList.size() > 0) {
				ChoiceItem selectedItem = (ChoiceItem) this.itemsList.get( 0 );
				this.popupItem.setText( selectedItem.getText() );
			}
			if (!this.popupItem.isInitialized) {
				int noneContentWidth = this.marginLeft + this.paddingLeft
							+ this.marginRight +  this.paddingRight;
				this.popupItem.init(firstLineWidth + noneContentWidth, availWidth + noneContentWidth, availHeight);
			}
			this.internalX = NO_POSITION_SET;
		} else {
			this.originalContentWidth = this.contentWidth;
			this.originalContentHeight = this.contentHeight;
		}
		this.originalBackgroundHeight = this.contentHeight + this.marginTop + this.marginBottom;
		if (!this.useSingleRow && this.label != null) {
			this.originalBackgroundHeight += this.label.itemHeight + this.paddingVertical;
		}
		//this.contentWidth = this.popupItem.contentWidth;			
		this.contentHeight = this.popupItem.contentHeight;
	}
}
//#endif

//#ifdef polish.useDynamicStyles
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#getCssSelector()
 */
protected String createCssSelector() {
	return "choicegroup";
}
//#endif
	
//#ifdef polish.usePopupItem
private void closePopup() {
	this.isPopupClosed = true;
	if (this.parent instanceof Container) {
		//#debug
		System.out.println("closing popup and adjusting scroll y offset to " + this.popupParentOpenY);
		((Container)this.parent).setScrollYOffset( this.popupParentOpenY );
		this.internalX = NO_POSITION_SET;
	}
	this.isInitialized = false;
}
//#endif

//#ifdef polish.usePopupItem
private void openPopup() {
	if (!this.isPopupClosed) {
		return;
	}
	//this.popupOpenY = this.yTopPos; 
	if (this.parent instanceof Container) {
		this.popupParentOpenY = ((Container)this.parent).getScrollYOffset();
		//#debug
		System.out.println("opening popup and storing scroll y offset of " + this.popupParentOpenY);
	}
	//System.out.println("openPopup: backgroundHeight=" + this.originalBackgroundHeight + ", itemHeight=" + this.itemHeight);
	this.isPopupClosed = false;
	focusChild( this.selectedIndex );
	// recalculate the internal positions of the selected choice:
	if (this.selectedIndex != -1) {
		Item item = (Item) this.itemsList.get( this.selectedIndex );
		//System.out.println("selectedIndex=" + this.selectedIndex + ", isInitialized=" + item.isInitialized);
		this.internalY = item.relativeY;
		this.internalHeight = item.itemHeight;
		this.internalX = item.relativeX;
		this.internalWidth = item.itemWidth;
	}
	this.isInitialized = false;
	this.backgroundHeight = this.originalBackgroundHeight;
}
//#endif

/**
 * Checks if the popup window is currently closed for a POPUP ChoiceGroup.
 * @return true when this is a POPUP ChoiceGroup and the popup is closed
 */
public boolean isPopupClosed()
{
	boolean result = false;
	//#ifdef polish.usePopupItem
		result = this.isPopupClosed;
	//#endif
	return result;
}

/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#handleKeyPressed(int, int)
 */
protected boolean handleKeyPressed(int keyCode, int gameAction) {
	if (this.itemsList.size() == 0) {
		//#debug
		System.out.println("itemsList.size()==0, aborting handleKeyPressed");
		return super.handleKeyPressed(keyCode, gameAction);
	}
	//#debug
	System.out.println("handleKeyPressed( " + keyCode + ", " + gameAction + " ) for " + this);
	boolean gameActionIsFire = getScreen().isGameActionFire(keyCode, gameAction); 
	
	//#if polish.ChoiceGroup.handleDefaultCommandFirst == true
		if (gameActionIsFire) {
			//#ifdef polish.usePopupItem
				if (!this.isPopup || this.isPopupClosed) {
			//#endif
					ItemCommandListener listener = this.itemCommandListener;
					//#ifndef tmp.suppressAllCommands
						listener = this.additionalItemCommandListener;
					//#endif
					if (this.defaultCommand != null && listener != null) {
						notifyItemPressedStart();
						return true;
					}
			//#ifdef polish.usePopupItem
			}
			//#endif
		}
	//#endif
	boolean processed = false;
	//#ifdef polish.usePopupItem
		if (!(this.isPopup && this.isPopupClosed)) {
			processed = super.handleKeyPressed(keyCode, gameAction);
			//#ifdef polish.css.popup-roundtrip
				if (!processed && this.popupRoundTrip && this.isPopup && !this.isPopupClosed && this.itemsList.size() > 1) {
					int nextFocusedIndex = -1;
					if (gameAction == Canvas.DOWN && keyCode != Canvas.KEY_NUM8 ) {
						// focus the first item of the opened POPUP choice:
						for (int i= 0; i < this.itemsList.size(); i++ ) {
							Item item = (Item) this.itemsList.get(i);
							if (item.appearanceMode != PLAIN) {
								nextFocusedIndex = i;
								break;
							}
						}
					} else if ( gameAction == Canvas.UP && keyCode != Canvas.KEY_NUM2) {							
						for (int i= this.itemsList.size()-1; i >= 0; i-- ) {
							Item item = (Item) this.itemsList.get(i);
							if (item.appearanceMode != PLAIN) {
								nextFocusedIndex = i;
								break;
							}
						}
					}
					if (nextFocusedIndex != -1) {
						focusChild(nextFocusedIndex);
						processed = true;
					}
				}
			//#endif
		}
	//#else
		processed = super.handleKeyPressed(keyCode, gameAction);
	//#endif
	//#debug
	System.out.println("ChoiceGroup: container handled keyPressEvent: " + processed);
	if (!processed) {
		ChoiceItem choiceItem = (ChoiceItem) this.focusedItem;
		//#ifdef polish.usePopupItem
			if (this.isPopup && this.isPopupClosed && gameActionIsFire) {
				notifyItemPressedStart(); // open popup in handleKeyReleased()
				return true;
			} else
		//#endif
		if (gameActionIsFire && choiceItem != null) {
			choiceItem.notifyItemPressedStart();
			return true;
		} else {
			//#if polish.Container.dontUseNumberKeys != true
				if (keyCode >= Canvas.KEY_NUM1 && keyCode <= Canvas.KEY_NUM9) {
					int index = keyCode - Canvas.KEY_NUM1;
					if (index < this.itemsList.size()) {
						Item item = getItem(index);
						if (
						//#ifdef polish.usePopupItem
								(!this.isPopup || !this.isPopupClosed) && 
						//#endif
								(item.appearanceMode != PLAIN) ) 
						{
							// either this is not a POPUP or the POPUP is opened:
							setSelectedIndex( index, true );
							//#ifdef polish.usePopupItem
								if (this.isPopup) {
									closePopup();
								}
							//#endif
							if (this.isImplicit) {
								// call command listener:
								Screen scr = getScreen();
								if (scr != null) {
									Command selectCmd = this.selectCommand;
									if (selectCmd == null) {
										selectCmd = List.SELECT_COMMAND;
									}
									scr.callCommandListener( selectCmd );
								}
							} else {
								notifyStateChanged();
							}
							notifyItemPressedStart();
							return true;
						}
					}
				}
			//#endif
			//#ifdef polish.usePopupItem
				if (this.isPopup && !this.isPopupClosed) {
					this.closePopupOnKeyRelease = true;
					return true;
				}
			//#endif
		}
	}
//	//#else
//	// no popup item is used by this application:
//	processed = super.handleKeyPressed(keyCode, gameAction);
//	if (!processed) {
//		if (gameAction == Canvas.FIRE && keyCode != Canvas.KEY_NUM5 && this.focusedIndex != -1 ) {
//			ChoiceItem item = (ChoiceItem) this.focusedItem;
//			item.notifyItemPressedStart();
//			if (this.isMultiple) {
//				item.toggleSelect();
//			} else {
//				setSelectedIndex(this.focusedIndex, true);
//			}
//			if ( this.choiceType != IMPLICIT ) 
//			{
//				notifyStateChanged();
//			}
//			return true;
//		//#if polish.Container.dontUseNumberKeys != true
//		} else if ( (keyCode >= Canvas.KEY_NUM1) && (keyCode <= Canvas.KEY_NUM9) ) {
//			int index = keyCode - Canvas.KEY_NUM1;
//			if (index < this.itemsList.size()) {
//				Item item = getItem(index);
//				if (item.appearanceMode != PLAIN) {
//					setSelectedIndex( index, true );
//					if (this.isImplicit) {
//						// call command listener:
//						Screen scr = getScreen();
//						if (scr != null) {
//							Command selectCmd = this.selectCommand;
//							if (selectCmd == null) {
//								selectCmd = List.SELECT_COMMAND;
//							}
//							scr.callCommandListener( selectCmd );
//						}
//					} else {
//						notifyStateChanged();
//					}
//				}
//				return true;
//			}
//		//#endif
//		}
//	}
//	//#endif
	return processed;
}



//#ifdef polish.usePopupItem
protected boolean handleNavigate(int keyCode, int gameAction) {
	if (this.isPopup && this.isPopupClosed) {
		return false;
	}
	return super.handleNavigate(keyCode, gameAction);
}
//#endif

/**
 * Selects a choice item.
 * @param item the item
 * @param isSelected true when it should be marked as selected
 */
protected void selectChoiceItem(ChoiceItem item, boolean isSelected)
{
	item.select(isSelected);
	//#if !tmp.suppressMarkCommands
		if (this.isMultiple) {
			if (isSelected) {
				item.removeCommand(ChoiceGroup.MARK_COMMAND);
				item.setDefaultCommand(ChoiceGroup.UNMARK_COMMAND);
			} else {
				item.removeCommand(ChoiceGroup.UNMARK_COMMAND);
				item.setDefaultCommand(ChoiceGroup.MARK_COMMAND);
			}
		}
	//#endif
}

/* (non-Javadoc)
 * @see de.enough.polish.ui.Container#handleKeyReleased(int, int)
 */
protected boolean handleKeyReleased(int keyCode, int gameAction) {
	//#debug
	System.out.println("handleKeyReleased( " + keyCode + ", " + gameAction + " ) for " + this + ", isPressed="+ this.isPressed );
	// note: this was a rough fix for selecting an entry on a popup choice group when the "Select" command button
	// was pressed - that worked for few cases and additionally required a Nokia layout, so it's outcommented for now
//	if ((gameAction == Canvas.FIRE && keyCode != Canvas.KEY_NUM5) 
//			|| (
//			//#if polish.key.LeftSoftKey:defined
//				//#= keyCode == ${polish.key.LeftSoftKey} 
//			//#else
//				keyCode == -6
//			//#endif	
//			&& this.isPopup && !this.isPopupClosed
//			)
//		) {
	boolean gameActionIsFire =	getScreen().isGameActionFire(keyCode, gameAction); 
	if (gameActionIsFire) {
		ChoiceItem choiceItem = (ChoiceItem) this.focusedItem;
		if (choiceItem != null
				//#ifdef polish.usePopupItem
					&& !(this.isPopup && this.isPopupClosed)
				//#endif
				) 
		{
			if (this.isMultiple) {
				selectChoiceItem( choiceItem, !choiceItem.isSelected);
			} else {
				setSelectedIndex(this.focusedIndex, true);
			}
			if ( this.choiceType != Choice.IMPLICIT ) 
			{
				notifyStateChanged();
			}
			if (choiceItem.isPressed) {
				choiceItem.notifyItemPressedEnd();
				if (this.isImplicit) {
					// call command listener:
					Screen scr = getScreen();
					if (scr != null) {
						Command selectCmd = this.selectCommand;
						if (selectCmd == null) {
							selectCmd = List.SELECT_COMMAND;
						}
						scr.callCommandListener( selectCmd );
					}
				}
			}
		}
		//#ifdef polish.usePopupItem
		if (this.isPopup) {
			if (this.isPopupClosed) {
				notifyItemPressedEnd();
				openPopup();
			} else {
				closePopup();
			}
		}
		//#endif
		return true;
	}
	//#ifdef polish.usePopupItem
		if (this.closePopupOnKeyRelease) {
			this.closePopupOnKeyRelease = false;
			closePopup();
			return true;
		}
	//#endif
	return super.handleKeyReleased(keyCode, gameAction);
}

//#ifdef polish.hasPointerEvents
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#handlePointerPressed(int, int)
 */
protected boolean handlePointerPressed(int relX, int relY) {
	//#debug
	System.out.println("ChoiceGroup.handlePointerPressed(" + relX + ", " + relY + ") for " + this );
	int index = this.focusedIndex;
	boolean handled = super.handlePointerPressed(relX, relY); // focuses the appropriate item, might change this.focusedIndex...
	relY -= this.yOffset + this.contentY;
	relX -= this.contentX;
	boolean triggerKey = (    
			(handled || isInItemArea(relX, relY, this.focusedItem))
			//#if polish.css.view-type
			&& (index == this.focusedIndex || this.containerView == null || this.containerView.allowsDirectSelectionByPointerEvent) 
			//#endif
	);
	//#debug
	System.out.println("triggerKey=" + triggerKey + ", handled=" + handled + ", index=" + index + ", focusedIndex=" + this.focusedIndex + ", focusedItem=" + this.focusedItem  + ", isInItemArea(relX, relY, this.focusedItem)=" + isInItemArea(relX, relY, this.focusedItem));
	relY += this.yOffset;
	if (  triggerKey )  
	{
		this.isPointerReleaseShouldTriggerKeyRelease = true;
		handled |= handleKeyPressed( 0, Canvas.FIRE );
	}
	return handled;
}
//#endif

//#ifdef polish.hasPointerEvents
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#handlePointerReleased(int, int)
 */
protected boolean handlePointerReleased(int relX, int relY) {
	//#debug
	System.out.println("ChoiceGroup.handlePointerReleased(" + relX + ", " + relY + ") for " + this );
	//#ifdef polish.usePopupItem
		if (this.isPopup && this.isPopupClosed) {
			if (isInItemArea(relX, relY)) {
				openPopup();
				return true;
			} else {
				return false;
			}
		}
	//#endif
	if (   this.isPointerReleaseShouldTriggerKeyRelease ) { 
		this.isPointerReleaseShouldTriggerKeyRelease = false;
		
		boolean handled = handlePointerScrollReleased(relX, relY);
		if (!handled) {
			handled = handleKeyReleased( 0, Canvas.FIRE );
		}
		if (handled) {
			return true;
		}
	}
	boolean handled = super.handlePointerReleased(relX, relY);
	//#ifdef polish.usePopupItem
		if (!handled && this.isPopup && !this.isPopupClosed) {
			closePopup();
			handled = true;
		}
	//#endif
	return handled;
}
//#endif


//#if polish.usePopupItem
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#isInContentArea(int, int)
 */
public boolean isInContentArea(int relX, int relY) {
	if (this.isPopup && !this.isPopupClosed) {
		if (relY < this.contentY || relY > this.contentY + this.originalContentHeight) {
			return false;
		}
		if (relX < this.contentX || relX > this.contentX + this.originalContentWidth) {
			return false;
		}
		return true;
	} else {
		return super.isInContentArea(relX, relY);
	}
}
//#endif

//#if polish.usePopupItem
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#isInItemArea(int, int)
 */
public boolean isInItemArea(int relX, int relY) {
	if (this.isPopup && !this.isPopupClosed) {
		if (relY < 0 || relY > (this.itemHeight + (this.originalContentHeight - this.contentHeight)) 
				|| relX < 0 || relX > (this.itemWidth + (this.originalContentWidth - this.contentWidth)))
		{
			return false;
		}
		return true;
	} else {
		return super.isInItemArea(relX, relY);
	}
}
//#endif

/**
 * Sets the select command for this choice group.
 *
 * @param command the new select command
 */
protected void setSelectCommand(Command command) {
	this.selectCommand = command;
}


//#ifndef tmp.suppressAllCommands
/**
 * Sets the command for selecting this (and opening this POPUP) choicegroup.
 * This implementation only works like described when not all ChoiceGroup commands are deactivated
 * by specifying the <variable name="polish.ChoiceGroup.suppressMarkCommands" value="true"/>
 * and <variable name="polish.ChoiceGroup.suppressSelectCommand" value="true"/>
 * preprocessing variables. When all commands are deactivated by the mentioned preprocessing variables,
 * the implementation of Item is used instead.
 * 
 * @param cmd the new command for selecting this choice group
 */
public void setDefaultCommand(Command cmd) {
	if (this.choiceType == Choice.MULTIPLE) {
		//#ifndef tmp.suppressMarkCommands
			removeCommand( MARK_COMMAND );
		//#endif
	} else {
		//#ifndef tmp.suppressSelectCommand
			removeCommand( List.SELECT_COMMAND );
			if (this.selectCommand != null) {
				removeCommand( this.selectCommand );
			}
		//#endif
	}
	if (this.additionalItemCommandListener == null) {
		this.additionalItemCommandListener = this.itemCommandListener;
	}
	addCommand( cmd );
	this.selectCommand = cmd;
	this.defaultCommand = cmd;
	this.itemCommandListener = this;
}
//#endif

//#ifdef polish.usePopupItem
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#defocus(de.enough.polish.ui.Style)
 */
public void defocus(Style originalStyle) {
	if (this.isPopup) {
		boolean requestInit = false;
		if (this.isPopupClosed) {
			this.popupItem.setStyle( originalStyle );
		} else {
			this.isPopupClosed = true;
			requestInit = true;
		}
		setStyle( originalStyle );
		// now remove any commands which are associated with this item:
		Screen scr = getScreen();
		if (scr != null) {
			// Nothing to do here.
		}
		// change the label-style of this container:
		//#ifdef polish.css.label-style
			Style tmpLabelStyle = null;
			if ( originalStyle != null) {
				tmpLabelStyle = (Style) originalStyle.getObjectProperty("label-style");
			}
			if (tmpLabelStyle == null) {
				tmpLabelStyle = StyleSheet.labelStyle;
			}
			if (this.label != null && tmpLabelStyle != null && this.label.style != tmpLabelStyle) {
				this.label.setStyle( tmpLabelStyle );
			}
		//#endif
		if (requestInit) {
			requestInit();
		}
	} else {
		super.defocus(originalStyle);
	}
}
//#endif

//#ifdef polish.usePopupItem	
/* (non-Javadoc)
 * @see de.enough.polish.ui.Item#focus(de.enough.polish.ui.Style, int)
 */
protected Style focus(Style focusStyle, int direction) {
	if (this.isPopup && this.isPopupClosed) {
		if (this.focusedStyle != null) {
			focusStyle = this.focusedStyle;
		}
		Style original = this.style;
		this.popupItem.setStyle( focusStyle );
		setStyle( focusStyle );
		// now remove any commands which are associated with this item:
		showCommands();
//		Screen scr = getScreen();
//		if (scr != null) {
//			scr.setItemCommands(this);
//		}
		// change the label-style of this container:
		//#ifdef polish.css.label-style
			if (this.label != null) {
				Style labStyle = (Style) focusStyle.getObjectProperty("label-style");
				if (labStyle != null) {
					this.labelStyle = this.label.style;
					this.label.setStyle( labStyle );
				}
			}
		//#endif
		return original;
	} else {
		return super.focus(focusStyle, direction);
	}
}
//#endif


/* (non-Javadoc)
 * @see de.enough.polish.ui.Container#setStyleWithBackground(de.enough.polish.ui.Style, boolean)
 */
public void setStyleWithBackground(Style style, boolean ignoreBackground)
{
	super.setStyleWithBackground(style, ignoreBackground);
	//#ifdef polish.usePopupItem
		if (this.isPopup && this.popupItem != null) {
			this.popupItem.setStyle( style );
		}
		if (this.isPopup && this.popupItem.image == null ) {
			//#ifdef polish.css.popup-image
				String url = style.getProperty("popup-image");
				if (url != null ) {
					this.popupItem.setImage( url );
				}
			//#endif
			//#ifdef polish.css.popup-roundtrip
				Boolean popupRoundTripBool = style.getBooleanProperty("popup-roundtrip");
				if (popupRoundTripBool != null) {
					this.popupRoundTrip = popupRoundTripBool.booleanValue();
				}
			//#endif
			//#if ! tmp.suppressSelectCommand && tmp.supportViewType
				if (!this.isSelectCommandAdded && this.choiceType == Choice.EXCLUSIVE && this.containerView == null) {
					if (this.selectCommand != null) {
						addCommand( this.selectCommand );
					} else {
						addCommand( List.SELECT_COMMAND );
					}
					this.isSelectCommandAdded = true;				
				}
			//#endif
		}
	//#endif
	//#ifndef tmp.suppressAllCommands
		if (this.choiceType == Choice.MULTIPLE) {
			//#ifndef tmp.suppressMarkCommands
				//#ifdef polish.i18n.useDynamicTranslations
					String cmdLabel = Locale.get("polish.command.mark");
					if (cmdLabel != MARK_COMMAND.getLabel()) {
						MARK_COMMAND = new Command( cmdLabel, Command.ITEM, 9 );
					}
					cmdLabel = Locale.get("polish.command.unmark");
					if (cmdLabel != UNMARK_COMMAND.getLabel()) {
						UNMARK_COMMAND = new Command( cmdLabel, Command.ITEM, 10 );
					}
				//#endif					
				//addCommand( MARK_COMMAND );
				//addCommand( UNMARK_COMMAND );
			//#endif
		} else if (this.choiceType == Choice.EXCLUSIVE){
			//#if !tmp.suppressSelectCommand
				//#if tmp.supportViewType
					if (this.containerView == null) {
				//#endif
					//#ifdef polish.i18n.useDynamicTranslations
						String cmdLabel = Locale.get("polish.command.select");
						if (cmdLabel != List.SELECT_COMMAND.getLabel()) {
							List.SELECT_COMMAND = new Command( cmdLabel, Command.ITEM, 3 );
						}
					//#endif
					addCommand( List.SELECT_COMMAND );
				//#if tmp.supportViewType
					}
				//#endif
			//#endif
		}
		this.itemCommandListener = this;
	//#endif
	setStyle( style, true );
}

//#ifdef polish.usePopupItem
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Container#setStyle(de.enough.polish.ui.Style, boolean)
	 */
	public void setStyle(Style style, boolean resetStyle) {
		super.setStyle(style, resetStyle);
		if (!resetStyle && this.isPopup && this.popupItem != null) {
			this.popupItem.setStyle( style, resetStyle );
		}
		if (this.isPopup && this.popupItem.image == null ) {
			//#ifdef polish.css.popup-color
				Integer color = style.getIntProperty("popup-color");
				if (color != null) {
					this.popupColor = color.intValue();
				}
			//#endif
			//#ifdef polish.css.popup-background-color
				Integer bgColor = style.getIntProperty("popup-background-color");
				if (bgColor != null) {
					this.popupBackgroundColor = bgColor.intValue();
				}
			//#endif
		}
	}
//#endif

//#ifndef tmp.suppressAllCommands
/* (non-Javadoc)
 * @see de.enough.polish.ui.ItemCommandListener#commandAction(javax.microedition.lcdui.Command, de.enough.polish.ui.Item)
 */
public void commandAction(Command c, Item item) {
}
//#endif

//#ifndef tmp.suppressAllCommands
/* (non-Javadoc)
 * @see de.enough.polish.ui.Container#handleCommand(javax.microedition.lcdui.Command)
 */
protected boolean handleCommand(Command cmd)
{
	//#if tmp.allowSelectCommand && tmp.allowMarkCommands
		if (cmd == List.SELECT_COMMAND || cmd == MARK_COMMAND || cmd == this.selectCommand  ) {
	//#elif tmp.allowSelectCommand
		//# if (cmd == List.SELECT_COMMAND || cmd == this.selectCommand ) {
	//#elif tmp.allowMarkCommands
		//# if (cmd == MARK_COMMAND || cmd == this.selectCommand ) {
	//#else
		//#abort Invalid combination of suppressed commands for a ChoiceGroup!
		//# if (false) {
	//#endif
		if (this.focusedIndex != -1) {
			setSelectedIndex( this.focusedIndex, true );
			if ( (this.choiceType != Choice.IMPLICIT) 
					//#ifdef polish.usePopupItem
					&& !(this.isPopup && !this.isPopupClosed)
					//#endif
			) {
				notifyStateChanged();
			}
			//#ifdef polish.usePopupItem
				if (this.isPopup) {
					if (this.isPopupClosed) {
						openPopup();
					} else {
						closePopup();
					}
					repaint();
				}
			//#endif
			return !this.isImplicit;
		}
		//#ifdef polish.usePopupItem
			else if (this.isPopup && this.isPopupClosed) {
				openPopup();
				return true;
			}
		//#endif
	//#ifdef tmp.allowMarkCommands
	} else if (cmd == UNMARK_COMMAND ) {
		if (this.focusedIndex != -1) {
			setSelectedIndex( this.focusedIndex, false );
			if ( (this.choiceType != Choice.IMPLICIT) 
					//#ifdef polish.usePopupItem
					&& !(this.isPopup && !this.isPopupClosed)
					//#endif
			) {
				notifyStateChanged();
			}
			return true;
		}
	//#endif
	} else if (this.additionalItemCommandListener != null) {
		return true;
	}
	return super.handleCommand(cmd);
}
//#endif


//#ifndef tmp.suppressAllCommands
public void setItemCommandListener(ItemCommandListener l) {
	this.additionalItemCommandListener = l;
}
//#endif

/* overrding Container.setItemsList() */
public void setItemsList(ArrayList itemsList) {
	this.selectedIndex = -1;
	super.setItemsList(itemsList);
}


}
