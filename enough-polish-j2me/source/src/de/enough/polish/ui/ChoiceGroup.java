//#condition polish.usePolishGui
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2004-2005 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.ui;

import javax.microedition.lcdui.Canvas;

import javax.microedition.lcdui.Font;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;

//#if polish.android
import de.enough.polish.android.midlet.MidletBridge;
//#endif
import de.enough.polish.util.ArrayList;
import de.enough.polish.util.Locale;

/**
 * A <code>ChoiceGroup</code> is a group of selectable elements intended to be
 * placed within a <CODE>Form</CODE>. The group may be created with a mode that requires a
 * single choice to be made or that allows multiple choices. The
 * implementation is responsible for providing the graphical representation of
 * these modes and must provide visually different graphics for different
 * modes. For example, it might use &quot;radio buttons&quot; for the
 * single choice
 * mode and &quot;check boxes&quot; for the multiple choice mode.
 * 
 * <p> <strong>Note:</strong> most of the essential methods have been
 * specified in the <CODE>Choice</CODE> interface.</p>
 * <HR>
 * 
 * @author Robert Virkus, robert@enough.de
 * @since MIDP 1.0
 */
public class ChoiceGroup 
extends Container 
implements Choice
//#if polish.ChoiceGroup.supressCommands == true
	//#define tmp.suppressMarkCommands
	//#define tmp.suppressSelectCommand
//#else
	//#if polish.ChoiceGroup.suppressMarkCommands == true
		//#define tmp.suppressMarkCommands
	//#else
		//#define tmp.allowMarkCommands
	//#endif
	//#if polish.ChoiceGroup.suppressSelectCommand == true
		//#define tmp.suppressSelectCommand
	//#else
		//#define tmp.allowSelectCommand
	//#endif
//#endif
//#if tmp.suppressMarkCommands && tmp.suppressSelectCommand
	//#define tmp.suppressAllCommands
//#else
	, ItemCommandListener
//#endif
{
	//#ifndef tmp.suppressMarkCommands
		//#ifdef polish.i18n.useDynamicTranslations
			public static Command MARK_COMMAND = new Command( Locale.get("polish.command.mark"), Command.ITEM, 9 );
		//#elifdef polish.command.mark:defined
			//#= public static final Command MARK_COMMAND = new Command("${polish.command.mark}", Command.ITEM, 9 );
		//#else
			//# public static final Command MARK_COMMAND = new Command( "Mark", Command.ITEM, 9 );
		//#endif
		//#ifdef polish.i18n.useDynamicTranslations
			public static Command UNMARK_COMMAND = new Command( Locale.get("polish.command.unmark"), Command.ITEM, 9 );
		//#elifdef polish.command.mark:defined
			//#= public static final Command UNMARK_COMMAND = new Command("${polish.command.unmark}", Command.ITEM, 10 );
		//#else
			//# public static final Command UNMARK_COMMAND = new Command( "Unmark", Command.ITEM, 10 );
		//#endif
	//#endif
	private int selectedIndex;
	//private boolean isExclusive;
	private boolean isMultiple;
	protected int choiceType;
	private boolean isImplicit;
	private Command selectCommand;
	//#ifdef polish.usePopupItem
		private static Image popupImage;
		private boolean isPopup;
		private int popupColor = 0;
		private int popupBackgroundColor = 0xFFFFFF;
		private IconItem popupItem;
		private boolean isPopupClosed;
		//#ifdef polish.css.popup-roundtrip
			private boolean popupRoundTrip;
		//#endif
		//private int popupOpenY;
		private int popupParentOpenY;
		private int originalContentWidth;
		private int originalContentHeight;
		private int originalBackgroundHeight;
//		private boolean closePopupOnKeyRelease;
	//#endif
	//#ifndef tmp.suppressAllCommands
		private ItemCommandListener additionalItemCommandListener;
	//#endif
	//#if polish.css.view-type || polish.css.columns
		//#define tmp.supportViewType 
	//#endif	
	//#if ! tmp.suppressSelectCommand && tmp.supportViewType
		private boolean isSelectCommandAdded;
	//#endif
	//#ifdef polish.hasPointerEvents
		private boolean isPointerReleaseShouldTriggerKeyRelease;
	//#endif
	

	/**
	 * Creates a new, empty <code>ChoiceGroup</code>, specifying its
	 * title and its type.
	 * The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>. The
	 * <code>IMPLICIT</code>
	 * choice type is not allowed within a <code>ChoiceGroup</code>.
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE,  or POPUP
	 * @throws IllegalArgumentException - if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
	 * @see Choice#EXCLUSIVE 
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType)
	{
		this( label, choiceType, new String[0], null, null, false );
	}

	/**
	 * Creates a new, empty <code>ChoiceGroup</code>, specifying its
	 * title and its type.
	 * The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>. The
	 * <code>IMPLICIT</code>
	 * choice type is not allowed within a <code>ChoiceGroup</code>.
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE,  or POPUP
	 * @param style the CSS style for this item
	 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType, Style style)
	{
		this( label, choiceType, new String[0], null, style, false );
	}

	/**
	 * Creates a new <code>ChoiceGroup</code>, specifying its title,
	 * the type of the
	 * <code>ChoiceGroup</code>, and an array of <code>Strings</code>
	 * and <code>Images</code> to be used as its
	 * initial contents.
	 * 
	 * <p>The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
	 * <code>IMPLICIT</code>
	 * type is not allowed for <code>ChoiceGroup</code>.</p>
	 * 
	 * <p>The <code>stringElements</code> array must be non-null and
	 * every array element
	 * must also be non-null.  The length of the
	 * <code>stringElements</code> array
	 * determines the number of elements in the <code>ChoiceGroup</code>.  The
	 * <code>imageElements</code> array
	 * may be <code>null</code> to indicate that the
	 * <code>ChoiceGroup</code> elements have no images.
	 * If the
	 * <code>imageElements</code> array is non-null, it must be the
	 * same length as the
	 * <code>stringElements</code> array.  Individual elements of the
	 * <code>imageElements</code> array
	 * may be <code>null</code> in order to indicate the absence of an
	 * image for the
	 * corresponding <code>ChoiceGroup</code> element.  Non-null elements
	 * of the
	 * <code>imageElements</code> array may refer to mutable or
	 * immutable images.</p>
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
	 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
	 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
	 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
	 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
	 *   			 or  if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType, String[] stringElements, Image[] imageElements)
	{
		this( label, choiceType, stringElements, imageElements, null, false );
	}

	/**
	 * Creates a new <code>ChoiceGroup</code>, specifying its title,
	 * the type of the
	 * <code>ChoiceGroup</code>, and an array of <code>Strings</code>
	 * and <code>Images</code> to be used as its
	 * initial contents.
	 * 
	 * <p>The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
	 * <code>IMPLICIT</code>
	 * type is not allowed for <code>ChoiceGroup</code>.</p>
	 * 
	 * <p>The <code>stringElements</code> array must be non-null and
	 * every array element
	 * must also be non-null.  The length of the
	 * <code>stringElements</code> array
	 * determines the number of elements in the <code>ChoiceGroup</code>.  The
	 * <code>imageElements</code> array
	 * may be <code>null</code> to indicate that the
	 * <code>ChoiceGroup</code> elements have no images.
	 * If the
	 * <code>imageElements</code> array is non-null, it must be the
	 * same length as the
	 * <code>stringElements</code> array.  Individual elements of the
	 * <code>imageElements</code> array
	 * may be <code>null</code> in order to indicate the absence of an
	 * image for the
	 * corresponding <code>ChoiceGroup</code> element.  Non-null elements
	 * of the
	 * <code>imageElements</code> array may refer to mutable or
	 * immutable images.</p>
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
	 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
	 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
	 * @param style The CSS style for this item
	 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
	 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
	 *   			 or  if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType, String[] stringElements, Image[] imageElements, Style style )
	{
		this( label, choiceType, stringElements, imageElements, style, false );
	}
	
	/**
	 * Creates a new <code>ChoiceGroup</code>, specifying its title,
	 * the type of the
	 * <code>ChoiceGroup</code>, and an array of <code>Strings</code>
	 * and <code>Images</code> to be used as its
	 * initial contents.
	 * 
	 * <p>The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
	 * <code>IMPLICIT</code>
	 * type is not allowed for <code>ChoiceGroup</code>.</p>
	 * 
	 * <p>The <code>stringElements</code> array must be non-null and
	 * every array element
	 * must also be non-null.  The length of the
	 * <code>stringElements</code> array
	 * determines the number of elements in the <code>ChoiceGroup</code>.  The
	 * <code>imageElements</code> array
	 * may be <code>null</code> to indicate that the
	 * <code>ChoiceGroup</code> elements have no images.
	 * If the
	 * <code>imageElements</code> array is non-null, it must be the
	 * same length as the
	 * <code>stringElements</code> array.  Individual elements of the
	 * <code>imageElements</code> array
	 * may be <code>null</code> in order to indicate the absence of an
	 * image for the
	 * corresponding <code>ChoiceGroup</code> element.  Non-null elements
	 * of the
	 * <code>imageElements</code> array may refer to mutable or
	 * immutable images.</p>
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
	 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
	 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
	 * @param style The CSS style for this item
	 * @param allowImplicit true when the Choice.IMPLICIT choiceType is also allowed
	 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
	 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
	 *   			 or  if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType, String[] stringElements, Image[] imageElements, Style style, boolean allowImplicit )
	{
		this( label, choiceType, 
				buildChoiceItems(stringElements, imageElements, choiceType, style),
				style, allowImplicit );
	}

	/**
	 * Creates a new <code>ChoiceGroup</code>, specifying its title,
	 * the type of the
	 * <code>ChoiceGroup</code>, and an array of <code>ChoiceItem</code>s
	 * to be used as its initial contents.
	 * 
	 * <p>The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
	 * <code>IMPLICIT</code>
	 * type is not allowed for <code>ChoiceGroup</code>.</p>
	 * 
	 * <p>The <code>items</code>s array must be non-null and
	 * every <code>ChoiceItem</code> must have its text be a non-null
	 * <code>String</code>.
	 * The length of the <code>items</code> array
	 * determines the number of elements in the <code>ChoiceGroup</code>.</p>
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
	 * @param items set of <code>ChoiceItem</code>s specifying the ChoiceGroup elements
	 * @throws NullPointerException if <code>items</code> is null 
	 *         or if getText() for one of the <code>ChoiceItem</code> in the array 
	 *         retuns a null <code>String</code>.
	 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType, ChoiceItem[] items)
	{
		this( label, choiceType, items, null, false );
	}

	/**
	 * Creates a new <code>ChoiceGroup</code>, specifying its title,
	 * the type of the
	 * <code>ChoiceGroup</code>, and an array of <code>ChoiceItem</code>s
	 * to be used as its initial contents.
	 * 
	 * <p>The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
	 * <code>IMPLICIT</code>
	 * type is not allowed for <code>ChoiceGroup</code>.</p>
	 * 
	 * <p>The <code>items</code>s array must be non-null and
	 * every <code>ChoiceItem</code> must have its text be a non-null
	 * <code>String</code>.
	 * The length of the <code>items</code> array
	 * determines the number of elements in the <code>ChoiceGroup</code>.</p>
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
	 * @param items set of <code>ChoiceItem</code>s specifying the ChoiceGroup elements
	 * @param style The CSS style for this item
	 * @throws NullPointerException if <code>items</code> is null 
	 *         or if getText() for one of the <code>ChoiceItem</code> in the array 
	 *         retuns a null <code>String</code>.
	 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType, ChoiceItem[] items, Style style )
	{
		this( label, choiceType, items, style, false );
	}

	/**
	 * Creates a new <code>ChoiceGroup</code>, specifying its title,
	 * the type of the
	 * <code>ChoiceGroup</code>, and an array of <code>ChoiceItem</code>s
	 * to be used as its initial contents.
	 * 
	 * <p>The type must be one of <code>EXCLUSIVE</code>,
	 * <code>MULTIPLE</code>, or <code>POPUP</code>.  The
	 * <code>IMPLICIT</code>
	 * type is not allowed for <code>ChoiceGroup</code>.</p>
	 * 
	 * <p>The <code>items</code>s array must be non-null and
	 * every <code>ChoiceItem</code> must have its text be a non-null
	 * <code>String</code>.
	 * The length of the <code>items</code> array
	 * determines the number of elements in the <code>ChoiceGroup</code>.</p>
	 * 
	 * @param label the item's label (see Item)
	 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
	 * @param items set of <code>ChoiceItem</code>s specifying the ChoiceGroup elements
	 * @param style The CSS style for this item
	 * @param allowImplicit true when the Choice.IMPLICIT choiceType is also allowed
	 * @throws IllegalArgumentException if choiceType is not one of EXCLUSIVE, MULTIPLE, or POPUP (unless allowImplicit is defined)
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	public ChoiceGroup( String label, int choiceType, ChoiceItem[] items, Style style, boolean allowImplicit )
	{
		super( label, false, style, -1 );
		if (choiceType == Choice.EXCLUSIVE
			//#if !polish.usePopupItem
				|| choiceType == Choice.POPUP
			//#endif
		) {
			//this.isExclusive = true;
		} else if (choiceType == Choice.MULTIPLE) {
			this.isMultiple = true;
		//#ifdef polish.usePopupItem
		} else if (choiceType == Choice.POPUP) {
			this.isPopup = true;
			this.isPopupClosed = true;
			this.popupItem = new IconItem( null, null, style );
			this.popupItem.setImageAlign( Graphics.RIGHT );
			this.popupItem.setAppearanceMode( BUTTON );
			this.popupItem.parent = this;
		//#endif
		} else if (choiceType == Choice.IMPLICIT && allowImplicit ) {
			this.isImplicit = true;
			//#if !(polish.hasVirtualKeyboard || (polish.android && !polish.android.autoFocus))
				setAutoFocusEnabled( true );
			//#endif
		} else {
			throw new IllegalArgumentException(
			//#ifdef polish.verboseDebug
				"invalid choiceType [" + choiceType + "] - IMPLICIT=" + Choice.IMPLICIT + "."
			//#endif
			);
		}
		this.choiceType = choiceType;
		if (items != null) {
			for (int i = 0; i < items.length; i++) {
				ChoiceItem item = items[i];
				append( item );
			}
		}
	}
	
	/**
	 * Builds an array of <code>ChoiceItems</code> out of
	 * an array of <code>String</code>s and <code>Image</code>s,
	 * specifying the <code>choiceType</code> and <code>style</code>
	 * common to any <code>ChoiceItem</code> in the resulting array.
	 * 
	 * @param stringElements set of strings specifying the string parts of the ChoiceGroup elements
	 * @param imageElements set of images specifying the image parts of the ChoiceGroup elements
	 * @param choiceType EXCLUSIVE, MULTIPLE, or POPUP
	 * @param style The CSS style for this item
	 * @return an aray of choice items
	 * @throws NullPointerException if stringElements is null or if the stringElements array contains any null elements
	 * @throws IllegalArgumentException if the imageElements array is non-null and has a different length from the stringElements array
	 * @see Choice#EXCLUSIVE
	 * @see Choice#MULTIPLE
	 * @see Choice#IMPLICIT
	 * @see Choice#POPUP
	 */
	protected static ChoiceItem[] buildChoiceItems(String[] stringElements, Image[] imageElements, int choiceType, Style style)
	{
		//#ifndef polish.skipArgumentCheck
			if (imageElements != null && imageElements.length != stringElements.length) {
				//#ifdef polish.verboseDebug
					throw new IllegalArgumentException("imageElements need to have the same length as the stringElements.");
				//#else
					//# throw new IllegalArgumentException();
				//#endif
			}
		//#endif
		ChoiceItem[] items = new ChoiceItem[stringElements.length];
		for (int i = 0; i < stringElements.length; ++i) {
			Image img = null;
			if (imageElements != null) {
				img = imageElements[i];
			}
			items[i] = new ChoiceItem( stringElements[i], img, choiceType, style );
		}
		return items;
	}
	
	//#ifdef polish.usePopupItem
	/**
	 * Creates or returns the default image for popup groups.
	 * 
	 * @return the default popup image
	 */
	protected Image createPopupImage() {
		if (popupImage == null) {
			popupImage = Image.createImage( 9, 12 );
			Graphics g = popupImage.getGraphics();
			g.setColor( this.popupBackgroundColor );
			g.fillRect(0, 0, 10, 13 );
			g.setColor( this.popupColor );
			g.drawLine(0, 0, 9, 0 );
			g.drawLine( 3, 3, 3, 9 );
			g.drawLine( 4, 3, 4, 10 );
			g.drawLine( 5, 3, 5, 9 );
			g.drawLine( 2, 8, 6, 8 );	
			g.drawLine( 1, 7, 7, 7 );	
		}
		return popupImage;
	}
	//#endif

	/**
	 * Gets the <code>String</code> part of the element referenced by
	 * <code>elementNum</code>.
	 * 
	 * @param elementNum the index of the element to be queried
	 * @return the string part of the element
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @see Choice#getString(int) in interface Choice
	 * @see #getImage(int)
	 */
	public String getString(int elementNum)
	{
		ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
		return item.getText();
	}

	/**
	 * Gets the <code>Image</code> part of the element referenced by
	 * <code>elementNum</code>.
	 * 
	 * @param elementNum the number of the element to be queried
	 * @return the image part of the element, or null if there is no image
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @see Choice#getImage(int) in interface Choice
	 * @see #getString(int)
	 */
	public Image getImage(int elementNum)
	{
		ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
		return item.getImage();
	}

	/**
	 * Gets the <code>ChoiceItem</code> of the element referenced by
	 * <code>elementNum</code>.
	 *
	 * @param elementNum the number of the element to be queried
	 * @return the ChoiceItem of the element
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 */
	public ChoiceItem getItem( int elementNum )
	{
		return (ChoiceItem)this.itemsList.get( elementNum );
	}

	/**
	 * Appends an element to the <code>ChoiceGroup</code>.
	 * 
	 * @param stringPart the string part of the element to be added
	 * @param imagePart the image part of the element to be added, or null if there is no image part
	 * @return the assigned index of the element
	 * @throws NullPointerException if stringPart is null
	 * @see Choice#append( String, Image) in interface Choice
	 */
	public int append( String stringPart, Image imagePart)
	{
		return append( stringPart, imagePart, null );
	}
	
	/**
	 * Appends an element to the <code>ChoiceGroup</code>.
	 * 
	 * @param stringPart the string part of the element to be added
	 * @param imagePart the image part of the element to be added, or null if there is no image part
	 * @param elementStyle the style for the appended ChoiceItem
	 * @return the assigned index of the element
	 * @throws NullPointerException if stringPart is null
	 * @see Choice#append( String, Image) in interface Choice
	 */
	public int append( String stringPart, Image imagePart, Style elementStyle )
	{
		ChoiceItem item = new ChoiceItem( stringPart, imagePart, this.choiceType, elementStyle );
		return append( item, elementStyle );
	}
	
	/**
	 * Appends a ChoiceItem to this choice group.
	 * 
	 * @param item the item
	 * @return the assigned index of the element
	 */
	public int append( ChoiceItem item ) {
		return append( item, null );
	}
	/**
	 * Appends a ChoiceItem to this choice group.
	 * 
	 * @param item the item
	 * @param elementStyle the style of the item, ignored when null
	 * @return the assigned index of the element
	 */
	public int append( ChoiceItem item, Style elementStyle ) {
		add( item );
		if ( elementStyle != null ) {
			// set the field directly instead of calling setStyle() so that the style is applied later when it's needed
			item.style = elementStyle;
			item.isStyleInitialized = false;
		}
		int itemIndex = this.itemsList.size() - 1;
		if (this.choiceType == Choice.EXCLUSIVE && item.isSelected) {
			if (this.selectedIndex != -1) {
				((ChoiceItem)get( this.selectedIndex )).select( false );
			}
			this.selectedIndex = itemIndex;
		}
		//#if ! tmp.suppressMarkCommands
			if (this.isMultiple) {
				selectChoiceItem(item, item.isSelected);
				item.setItemCommandListener( this );
			}
		//#endif
		//#ifdef polish.usePopupItem
			if (this.isPopup && this.isPopupClosed && this.selectedIndex == -1) {
				this.popupItem.setText( item.text );
				this.selectedIndex = 0;
			}
		//#endif
		return itemIndex;
	}

	/**
	 * Inserts an element into the <code>ChoiceGroup</code> just prior to
	 * the element specified.
	 * 
	 * @param elementNum the index of the element where insertion is to occur
	 * @param stringPart the string part of the element to be inserted
	 * @param imagePart the image part of the element to be inserted, or null if there is no image part
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @throws NullPointerException if stringPart is null
	 * @see Choice#insert(int, String, Image)  in interface Choice
	 */
	public void insert(int elementNum, String stringPart, Image imagePart)
	{
		insert( elementNum, stringPart, imagePart, null );
	}

	/**
	 * Inserts an element into the <code>ChoiceGroup</code> just prior to
	 * the element specified.
	 * 
	 * @param elementNum the index of the element where insertion is to occur
	 * @param stringPart the string part of the element to be inserted
	 * @param imagePart the image part of the element to be inserted, or null if there is no image part
	 * @param elementStyle the style for the inserted ChoiceItem
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @throws NullPointerException if stringPart is null
	 * @see Choice#insert(int, String, Image)  in interface Choice
	 */
	public void insert(int elementNum, String stringPart, Image imagePart, Style elementStyle)
	{
		ChoiceItem item = new ChoiceItem( stringPart, imagePart, this.choiceType, elementStyle );
		add(elementNum, item);
	}

	/**
	 * Inserts an element into the <code>ChoiceGroup</code> just prior to
	 * the element specified.
	 * 
	 * @param elementNum the index of the element where insertion is to occur
	 * @param item ChoiceItem of the element to be inserted
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 */
	public void insert(int elementNum, ChoiceItem item)
	{
		add(elementNum, item);
	}

	/**
	 * Inserts an element into the <code>ChoiceGroup</code> just prior to
	 * the element specified.
	 * 
	 * @param elementNum the index of the element where insertion is to occur
	 * @param item ChoiceItem of the element to be inserted
	 * @param elementStyle the style for the inserted ChoiceItem
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 */
	public void insert(int elementNum, ChoiceItem item, Style elementStyle)
	{
		if (elementStyle != null) {
			item.setStyle(elementStyle);
		}
		add(elementNum, item);
	}

	/**
	 * Sets the <code>String</code> and <code>Image</code> parts of the
	 * element referenced by <code>elementNum</code>,
	 * replacing the previous contents of the element.
	 * 
	 * @param elementNum - the index of the element to be set
	 * @param stringPart - the string part of the new element
	 * @param imagePart - the image part of the element, or null if there is no image part
	 * @throws IndexOutOfBoundsException - if elementNum is invalid
	 * @throws NullPointerException - if stringPart is null
	 * @see Choice#set(int, String, Image) in interface Choice
	 */
	public void set(int elementNum, String stringPart, Image imagePart)
	{
		set( elementNum, stringPart, imagePart, null );
	}

	/**
	 * Sets the <code>String</code> and <code>Image</code> parts of the
	 * element referenced by <code>elementNum</code>,
	 * replacing the previous contents of the element.
	 * 
	 * @param elementNum the index of the element to be set
	 * @param stringPart the string part of the new element
	 * @param imagePart the image part of the element, or null if there is no image part
	 * @param elementStyle the style for the new list element.
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @throws NullPointerException if stringPart is null
	 * @see Choice#set(int, String, Image) in interface Choice
	 */
	public void set(int elementNum, String stringPart, Image imagePart, Style elementStyle )
	{
		ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
		item.setText( stringPart );
		if (imagePart != null) {
			item.setImage(imagePart);
		}
		if (elementStyle != null) {
			item.setStyle(elementStyle);
		}

		if (isInitialized()) {
			setInitialized(false);
			repaint();
		}
	}

//	/**
//	 * Sets the <code>ChoiceItem</code> of the
//	 * element referenced by <code>elementNum</code>,
//	 * replacing the previous one.
//	 * 
//	 * @param elementNum the index of the element to be set
//	 * @param item the ChoiceItem of the new element
//	 * @throws IndexOutOfBoundsException if elementNum is invalid
//	 */
//	public void set(int elementNum, ChoiceItem item )
//	{
//		super.set(elementNum, item);
//		if (this.isInitialized) {
//			this.isInitialized = false;
//			repaint();
//		}
//	}
	
//	/**
//	 * Sets the <code>ChoiceItem</code> of the
//	 * element referenced by <code>elementNum</code>,
//	 * replacing the previous one.
//	 * 
//	 * @param elementNum the index of the element to be set
//	 * @param item the ChoiceItem of the new element
//	 * @param elementStyle the style for the new list element.
//	 * @throws IndexOutOfBoundsException if elementNum is invalid
//	 */
//	public void set(int elementNum, ChoiceItem item, Style elementStyle )
//	{
//		if (elementStyle != null) {
//			item.setStyle(elementStyle);
//		}
//		delete( elementNum );
//		add( elementNum, item );
//		if (this.isInitialized) {
//			this.isInitialized = false;
//			repaint();
//		}
//	}

	/**
	 * Deletes the element referenced by <code>elementNum</code>.
	 * 
	 * @param elementNum the index of the element to be deleted
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @see Choice#delete(int) in interface Choice
	 */
	public void delete(int elementNum)
	{
		remove(elementNum);
		//#ifdef polish.usePopupItem
			if (this.isPopup) {
				if (this.selectedIndex == elementNum ) {
					if (this.itemsList.size() > 0) {
						this.selectedIndex = -1;
						if (this.isPopupClosed) {
							setSelectedIndex( 0, true );
						}
					} else {
						this.selectedIndex = -1;
					}
				} else if ( elementNum < this.selectedIndex ) {
					this.selectedIndex--;
				}
			} else {
		//#endif
			if (this.selectedIndex == elementNum ) {
				this.selectedIndex = -1;
			} else if (elementNum < this.selectedIndex) {
				this.selectedIndex--;
			}
		//#ifdef polish.usePopupItem
			}
		//#endif
	}

	/**
	 * Deletes all elements from this <code>ChoiceGroup</code>.
	 * 
	 * @see Choice#deleteAll() in interface Choice
	 */
	public void deleteAll()
	{
		clear();
	}
	
	
	/*
	 * (non-Javadoc)
	 * @see de.enough.polish.ui.Container#clear()
	 */
	public void clear() {
		this.selectedIndex = -1;
		super.clear();
	}

	/**
	 * Gets a boolean value indicating whether this element is selected.
	 * 
	 * @param elementNum the index of the element to be queried
	 * @return selection state of the element
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @see Choice#isSelected(int) in interface Choice
	 */
	public boolean isSelected(int elementNum)
	{
		ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
		return item.isSelected;
	}

	/**
	 * Returns the index number of an element in the
	 * <code>ChoiceGroup</code> that is
	 * selected. For <code>ChoiceGroup</code> objects of type
	 * <code>EXCLUSIVE</code> and <code>POPUP</code>
	 * there is at most one element selected, so
	 * this method is useful for determining the user's choice.
	 * Returns <code>-1</code> if
	 * there are no elements in the <code>ChoiceGroup</code>.
	 * 
	 * <p>For <code>ChoiceGroup</code> objects of type
	 * <code>MULTIPLE</code>, this always
	 * returns <code>-1</code> because no
	 * single value can in general represent the state of such a
	 * <code>ChoiceGroup</code>.
	 * To get the complete state of a <code>MULTIPLE</code>
	 * <code>Choice</code>, see <A HREF="../../../javax/microedition/lcdui/ChoiceGroup.html#getSelectedFlags(boolean[])"><CODE>getSelectedFlags</CODE></A>.</p>
	 * 
	 * @return index of selected element, or -1 if none
	 * @see Choice#getSelectedIndex() in interface Choice
	 * @see #setSelectedIndex(int, boolean)
	 */
	public int getSelectedIndex()
	{
		if (this.isMultiple || this.itemsList.size() == 0) {
			return -1;
		} else if (!this.isImplicit || this.focusedIndex == -1) {
			return this.selectedIndex;
		} else {
			// this is an implicit/focused choice:
			return this.focusedIndex;
		}
	}

	/**
	 * Queries the state of a <code>ChoiceGroup</code> and returns the state of
	 * all elements in the
	 * boolean array
	 * <code>selectedArray_return</code>. <strong>Note:</strong> this
	 * is a result parameter.
	 * It must be at least as long as the size
	 * of the <code>ChoiceGroup</code> as returned by <code>size()</code>.
	 * If the array is longer, the extra
	 * elements are set to <code>false</code>.
	 * 
	 * <p>For <code>ChoiceGroup</code> objects of type
	 * <code>MULTIPLE</code>, any
	 * number of elements may be selected and set to true in the result
	 * array.  For <code>ChoiceGroup</code> objects of type
	 * <code>EXCLUSIVE</code> and <code>POPUP</code>
	 * exactly one element will be selected, unless there are
	 * zero elements in the <code>ChoiceGroup</code>. </p>
	 * 
	 * @param selectedArray_return array to contain the results
	 * @return the number of selected elements in the ChoiceGroup
	 * @throws IllegalArgumentException if selectedArray_return is shorter than the size of the ChoiceGroup
	 * @throws NullPointerException if selectedArray_return is null
	 * @see Choice#getSelectedFlags(boolean[]) in interface Choice
	 * @see #setSelectedFlags(boolean[])
	 */
	public int getSelectedFlags(boolean[] selectedArray_return)
	{
		//#ifndef polish.skipArgumentCheck
			if (selectedArray_return.length < this.itemsList.size()) {
				//#ifdef polish.verboseDebug
					throw new IllegalArgumentException("length of selectedArray is too small");
				//#else
					//# throw new IllegalArgumentException();
				//#endif
			}
		//#endif
		ChoiceItem[] myItems = (ChoiceItem[]) this.itemsList.toArray( new ChoiceItem[ this.itemsList.size() ] );
		int selectedItems = 0;
		for (int i = 0; i < myItems.length; i++) {
			ChoiceItem item = myItems[i];
			if (item.isSelected || (this.isImplicit && i == this.focusedIndex) || (!this.isMultiple && i == this.selectedIndex)) {
				selectedArray_return[i] = true;
				selectedItems++;
			} else {
				selectedArray_return[i] = false;
			}
		}
		return selectedItems;
	}

	/**
	 * For <code>ChoiceGroup</code> objects of type
	 * <code>MULTIPLE</code>, this simply sets an
	 * individual element's selected state.
	 * 
	 * <P>For <code>ChoiceGroup</code> objects of type
	 * <code>EXCLUSIVE</code> and <code>POPUP</code>, this can be used only to
	 * select an element.  That is, the <code> selected </code> parameter must
	 * be <code> true </code>. When an element is selected, the previously
	 * selected element is deselected. If <code> selected </code> is <code>
	 * false </code>, this call is ignored.</P>
	 * 
	 * <p>For both list types, the <code>elementNum</code> parameter
	 * must be within
	 * the range
	 * <code>[0..size()-1]</code>, inclusive. </p>
	 * 
	 * @param elementNum the number of the element. Indexing of the elements is zero-based
	 * @param selected the new state of the element true=selected, false=not selected
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @see Choice#setSelectedIndex(int, boolean) in interface Choice
	 * @see #getSelectedIndex()
	 */
	public void setSelectedIndex(int elementNum, boolean selected)
	{
		//#debug
		System.out.println("setSelectedIndex: index="  + elementNum + ", selected=" + selected + ", current selectedIndex=" + this.selectedIndex) ;
		if (this.isMultiple) {
			ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
			selectChoiceItem(item, selected);
		} else {
			if (!selected) {
				return; // ignore this call
			}
			if (this.selectedIndex != -1) {
				ChoiceItem oldSelected = (ChoiceItem) this.itemsList.get( this.selectedIndex );
				oldSelected.select( false );
			}
			
			if(elementNum != -1)
			{
				this.selectedIndex = elementNum;
				ChoiceItem newSelected = (ChoiceItem) this.itemsList.get( elementNum );
				newSelected.select( true );
				
				if (this.isFocused) {
					if ( isInitialized()) {
						focusChild( elementNum, newSelected, 0, true );
					} else {
						setAutoFocusEnabled( true );
						this.autoFocusIndex = elementNum;
					}
				}
				//#ifdef polish.usePopupItem
					if (this.isPopup) {
						this.popupItem.setText( newSelected.getText() );
					}
				//#endif
			}		
			
		}
		if (isInitialized()) {
			setInitialized(false);
			repaint();
		}
		notifyValueChanged(null);
	}

	/**
	 * Attempts to set the selected state of every element in the
	 * <code>ChoiceGroup</code>. The array
	 * must be at least as long as the size of the
	 * <code>ChoiceGroup</code>. If the array is
	 * longer, the additional values are ignored. <p>
	 * 
	 * For <code>ChoiceGroup</code> objects of type
	 * <code>MULTIPLE</code>, this sets the selected
	 * state of every
	 * element in the <code>Choice</code>. An arbitrary number of
	 * elements may be selected.
	 * <p>
	 * 
	 * For <code>ChoiceGroup</code> objects of type
	 * <code>EXCLUSIVE</code> and <code>POPUP</code>, exactly one array
	 * element must have the value <code>true</code>. If no element is
	 * <code>true</code>,
	 * the first element
	 * in the <code>Choice</code> will be selected. If two or more
	 * elements are <code>true</code>, the
	 * implementation will choose the first <code>true</code> element
	 * and select it. <p>
	 * 
	 * @param selectedArray an array in which the method collect the selection status
	 * @throws IllegalArgumentException if selectedArray is shorter than the size of the ChoiceGroup
	 * @throws NullPointerException if the selectedArray is null
	 * @see Choice#setSelectedFlags(boolean[]) in interface Choice
	 * @see #getSelectedFlags(boolean[])
	 */
	public void setSelectedFlags(boolean[] selectedArray)
	{
		if (selectedArray == null || selectedArray.length == 0) {
			// ignore these flags
			return;
		}
		//#ifndef polish.skipArgumentCheck
			if (selectedArray.length < this.itemsList.size()) {
				//#ifdef polish.verboseDebug
					throw new IllegalArgumentException("length of selectedArray is too small");
				//#else
					//# throw new IllegalArgumentException();
				//#endif
			}
		//#endif
		if (this.isMultiple) {
			ChoiceItem[] myItems = (ChoiceItem[]) this.itemsList.toArray( new ChoiceItem[ this.itemsList.size() ] );
			for (int i = 0; i < myItems.length; i++) {
				ChoiceItem item = myItems[i];
				boolean isSelected = selectedArray[i];
				selectChoiceItem(item, isSelected);
			}
		} else {
			int index = 0;
			for (int i = 0; i < selectedArray.length; i++) {
				if (selectedArray[i]) {
					index = i;
					break;
				}
			}
			if (index > this.itemsList.size()) {
				index = 0;
			}
			setSelectedIndex( index, true );
		}
		if (isInitialized()) {
			setInitialized(false);
			repaint();
		}
		notifyValueChanged(null);
	}

	/**
	 * Sets the application's preferred policy for fitting
	 * <code>Choice</code> element contents to the available screen space. The set policy applies for all
	 * elements of the <code>Choice</code> object.  Valid values are
	 * <CODE>Choice.TEXT_WRAP_DEFAULT</CODE>, 
	 * <CODE>Choice.TEXT_WRAP_ON</CODE>,
	 * and <CODE>Choice.TEXT_WRAP_OFF</CODE>. 
	 * Fit policy is a hint, and the
	 * implementation may disregard the application's preferred policy.
	 * The J2ME Polish implementation always uses the TEXT_WRAP_ON policy.
	 * 
	 * @param fitPolicy preferred content fit policy for choice elements
	 * @see Choice#setFitPolicy(int) in interface Choice
	 * @see #getFitPolicy()
	 * @since  MIDP 2.0
	 */
	public void setFitPolicy(int fitPolicy)
	{
		//this.fitPolicy = fitPolicy;
		// ignore hint
	}

	/**
	 * Gets the application's preferred policy for fitting
	 * <code>Choice</code> element contents to the available screen space.  The value returned is the
	 * policy that had been set by the application, even if that value had
	 * been disregarded by the implementation.
	 * 
	 * @return always Choice.TEXT_WRAP_ON
	 * @see Choice#getFitPolicy() in interface Choice
	 * @see #setFitPolicy(int)
	 * @since  MIDP 2.0
	 */
	public int getFitPolicy()
	{
		return Choice.TEXT_WRAP_ON;
	}

	/**
	 * Sets the application's preferred font for
	 * rendering the specified element of this <code>Choice</code>.
	 * An element's font is a hint, and the implementation may disregard
	 * the application's preferred font.
	 * The J2ME Polish implementation uses the font defined by the appropriate
	 * CSS style and ignores the font which is set here.
	 * 
	 * @param elementNum the index of the element, starting from zero
	 * @param font the preferred font to use to render the element
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @see Choice#setFont(int, Font) in interface Choice
	 * @see #getFont(int)
	 * @since  MIDP 2.0
	 */
	public void setFont(int elementNum, Font font)
	{
		ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
		item.setPreferredFont( font );
	}

	/**
	 * Gets the application's preferred font for
	 * rendering the specified element of this <code>Choice</code>. The
	 * value returned is the font that had been set by the application,
	 * even if that value had been disregarded by the implementation.
	 * If no font had been set by the application, or if the application
	 * explicitly set the font to <code>null</code>, the value is the default
	 * font chosen by the implementation.
	 * 
	 * <p> The <code>elementNum</code> parameter must be within the range
	 * <code>[0..size()-1]</code>, inclusive.</p>
	 * 
	 * @param elementNum the index of the element, starting from zero
	 * @return the preferred font to use to render the element
	 * @throws IndexOutOfBoundsException if elementNum is invalid
	 * @see Choice#getFont(int) in interface Choice
	 * @see #setFont(int elementNum, Font font)
	 * @since  MIDP 2.0
	 */
	public Font getFont(int elementNum)
	{
		ChoiceItem item = (ChoiceItem) this.itemsList.get( elementNum );
		Font font = item.preferredFont;
		if (font == null) {
			font = item.font;
		}
		return font;
	}
	//#ifdef polish.usePopupItem
	protected void hideNotify() {
		if (this.isPopup && !this.isPopupClosed) {
			closePopup();
		}
	}
	//#endif

	//#ifdef polish.usePopupItem
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#paint(int, int, javax.microedition.lcdui.Graphics)
	 */
	public void paintContent(int x, int y, int leftBorder, int rightBorder, Graphics g) {
		//#if tmp.supportViewType
			if (this.containerView != null) {
				super.paintContent(x, y, leftBorder, rightBorder, g);
				return;
			}
		//#endif
		if (this.isPopup && this.isPopupClosed) {
			this.popupItem.paintContent(x, y, leftBorder, rightBorder, g);
		} else {
			//System.out.println("painting popup content at y=" + y + ", yScrollOffse=" + this.yOffset + ", clipY=" + g.getClipY() + ", clipHeight=" + g.getClipHeight());
			super.paintContent(x, y, leftBorder, rightBorder, g );
		}
	}
	//#endif
	
	//#ifdef polish.usePopupItem
	protected void init( int firstLineWidth, int availWidth, int availHeight ) {
		super.init(firstLineWidth, availWidth, availHeight);
		//#if tmp.supportViewType
			if (this.containerView != null) {
				return;
			}
		//#endif
			
		if (this.isPopup && !this.isPopupClosed) {
			this.backgroundWidth += (this.originalContentWidth - this.contentWidth); 
			this.backgroundHeight += (this.originalContentHeight - this.contentHeight); 
		}
	}
	//#endif


	//#ifdef polish.usePopupItem
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#initItem()
	 */
	protected void initContent(int firstLineWidth, int availWidth, int availHeight) {
		super.initContent(firstLineWidth, availWidth, availHeight);
		//#if tmp.supportViewType
			if (this.containerView != null) {
				return;
			}
		//#endif
		if (this.isPopup) {
			//System.out.println("initContent of POPUP " + this + ", isClosed=" + this.isPopupClosed );
			if (this.popupItem.image == null) {
				this.popupItem.setImage( createPopupImage() );
			}
			if (this.isPopupClosed) {
				if (this.popupItem.getText() == null && this.itemsList.size() > 0) {
					ChoiceItem selectedItem = (ChoiceItem) this.itemsList.get( 0 );
					this.popupItem.setText( selectedItem.getText() );
				}
				this.internalX = NO_POSITION_SET;
			} else {
				this.originalContentWidth = this.contentWidth;
				this.originalContentHeight = this.contentHeight;
			}
			this.popupItem.getItemWidth( this.availableWidth, this.availableWidth, this.availableHeight );
			this.originalBackgroundHeight = this.contentHeight + this.marginTop + this.marginBottom;
			if (!this.useSingleRow && this.label != null) {
				this.originalBackgroundHeight += this.label.itemHeight + this.paddingVertical;
			}
			if (this.popupItem.contentWidth > this.contentWidth) {
				this.contentWidth = this.popupItem.contentWidth;		
			} else {
				this.popupItem.setContentWidth(this.contentWidth);
			}
			this.contentHeight = this.popupItem.contentHeight;
		}
	}
	//#endif
	
//
//	//#ifdef polish.usePopupItem
//	/* (non-Javadoc)
//	 * @see de.enough.polish.ui.Container#setItemWidth(int)
//	 */
//	public void setItemWidth(int width) {
//		System.out.println("increasing popup width to " + width);
//		if (!this.isPopup) {
//			super.setItemWidth(width);
//		} else {
//			int diff = (width - this.itemWidth);
//			int availWidth = (this.availContentWidth + diff);
//			this.popupItem.setItemWidth(availWidth);
//			this.contentWidth = availWidth;
//			this.backgroundWidth += diff;
//			this.itemWidth = width;
//		}
//	}
//	//#endif
//	

	//#ifdef polish.usePopupItem
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Container#updateInternalPosition(Item)
	 */
	protected void updateInternalPosition(Item item) {
		if (this.isPopup && this.isPopupClosed) {
			if (this.parent instanceof Container) {
				this.internalX = NO_POSITION_SET;
				((Container)this.parent).updateInternalPosition(this);
			}
		} else {
			super.updateInternalPosition( item );
		}
	}
	//#endif

	//#ifdef polish.useDynamicStyles
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#getCssSelector()
	 */
	protected String createCssSelector() {
		return "choicegroup";
	}
	//#endif
		
	//#ifdef polish.usePopupItem
	private void closePopup() {
		if (this.isPopupClosed) {
			return;
		}
		getScreen().removeCommandsLayer();
		this.isPopupClosed = true;
		this.internalX = NO_POSITION_SET;			
		if (this.parent instanceof Container) {
			//#debug
			System.out.println("closing popup and adjusting scroll y offset to " + this.popupParentOpenY);
			Container container = (Container)this.parent;
			container.setScrollYOffset( this.popupParentOpenY, false );
		}
		setInitialized(false);
	}
	//#endif

	//#ifdef polish.usePopupItem
	private void openPopup() {
		if (!this.isPopupClosed) {
			return;
		}
		//#if polish.javaplatform >= Android/1.5
			if (this.isShown) {
				MidletBridge.instance.hideSoftKeyboard();
			}
		//#endif
		getScreen().addCommandsLayer( new Command[]{ StyleSheet.OK_CMD, StyleSheet.CANCEL_CMD} );
		//this.popupOpenY = this.yTopPos; 
		if (this.parent instanceof Container) {
			this.popupParentOpenY = ((Container)this.parent).getScrollYOffset();
			//#debug
			System.out.println("opening popup and storing scroll y offset of " + this.popupParentOpenY);
		}
		//System.out.println("openPopup: backgroundHeight=" + this.originalBackgroundHeight + ", itemHeight=" + this.itemHeight);
		this.isPopupClosed = false;
		focusChild( this.selectedIndex );
		// recalculate the internal positions of the selected choice:
		if (this.selectedIndex != -1) {
			Item item = (Item) this.itemsList.get( this.selectedIndex );
			//System.out.println("selectedIndex=" + this.selectedIndex + ", isInitialized=" + item.isInitialized);
			this.internalY = item.relativeY;
			this.internalHeight = item.itemHeight;
			this.internalX = item.relativeX;
			this.internalWidth = item.itemWidth;
		}
		setInitialized(false);
		this.backgroundHeight = this.originalBackgroundHeight;
	}
	//#endif
	
	/**
	 * Checks if the popup window is currently closed for a POPUP ChoiceGroup.
	 * @return true when this is a POPUP ChoiceGroup and the popup is closed
	 */
	public boolean isPopupClosed()
	{
		boolean result = false;
		//#ifdef polish.usePopupItem
			result = this.isPopupClosed;
		//#endif
		return result;
	}

	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#handleKeyPressed(int, int)
	 */
	protected boolean handleKeyPressed(int keyCode, int gameAction) {
		if (this.itemsList.size() == 0) {
			//#debug
			System.out.println("itemsList.size()==0, aborting handleKeyPressed");
			return super.handleKeyPressed(keyCode, gameAction);
		}
		boolean gameActionIsFire = (gameAction == Canvas.FIRE); 
		//#debug
		System.out.println("handleKeyPressed( " + keyCode + ", " + gameAction + " ) for " + this + ", isFire=" + gameActionIsFire);
		
		//#if polish.ChoiceGroup.handleDefaultCommandFirst == true
			if (gameActionIsFire) {
				//#ifdef polish.usePopupItem
					if (!this.isPopup || this.isPopupClosed) {
				//#endif
						ItemCommandListener listener = this.itemCommandListener;
						//#ifndef tmp.suppressAllCommands
							listener = this.additionalItemCommandListener;
						//#endif
						if (this.defaultCommand != null && listener != null) {
							listener.commandAction( this.defaultCommand, this );
							notifyItemPressedStart();
							return true;
						}
				//#ifdef polish.usePopupItem
				}
				//#endif
			}
		//#endif
		boolean processed = false;
		//#ifdef polish.usePopupItem
			if (!(this.isPopup && this.isPopupClosed)) {
				processed = super.handleKeyPressed(keyCode, gameAction);
				//#ifdef polish.css.popup-roundtrip
					if (!processed && this.popupRoundTrip && this.isPopup && !this.isPopupClosed && this.itemsList.size() > 1) {
						int nextFocusedIndex = -1;
						if (gameAction == Canvas.DOWN && keyCode != Canvas.KEY_NUM8 ) {
							// focus the first item of the opened POPUP choice:
							for (int i= 0; i < this.itemsList.size(); i++ ) {
								Item item = (Item) this.itemsList.get(i);
								if (item.appearanceMode != PLAIN) {
									nextFocusedIndex = i;
									break;
								}
							}
						} else if ( gameAction == Canvas.UP && keyCode != Canvas.KEY_NUM2) {							
							for (int i= this.itemsList.size()-1; i >= 0; i-- ) {
								Item item = (Item) this.itemsList.get(i);
								if (item.appearanceMode != PLAIN) {
									nextFocusedIndex = i;
									break;
								}
							}
						}
						if (nextFocusedIndex != -1) {
							focusChild(nextFocusedIndex);
							processed = true;
						}
					}
				//#endif
			}
		//#else
			processed = super.handleKeyPressed(keyCode, gameAction);
		//#endif
		//#debug
		System.out.println("ChoiceGroup: container handled keyPressEvent: " + processed);
		if (!processed) {
			ChoiceItem choiceItem = (ChoiceItem) this.focusedItem;
			//#ifdef polish.usePopupItem
				if (this.isPopup && this.isPopupClosed && gameActionIsFire) {
					notifyItemPressedStart(); // open popup in handleKeyReleased()
					return true;
				} else
			//#endif
			if (gameActionIsFire && choiceItem != null) {
				choiceItem.notifyItemPressedStart();
				return true;
			} else {
				//#if polish.Container.dontUseNumberKeys != true
					if (keyCode >= Canvas.KEY_NUM1 && keyCode <= Canvas.KEY_NUM9) {
						int index = keyCode - Canvas.KEY_NUM1;
						if (index < this.itemsList.size()) {
							Item item = getItem(index);
							if (
							//#ifdef polish.usePopupItem
									(!this.isPopup || !this.isPopupClosed) && 
							//#endif
									(item.appearanceMode != PLAIN) ) 
							{
								// either this is not a POPUP or the POPUP is opened:
								setSelectedIndex( index, true );
								//#ifdef polish.usePopupItem
									if (this.isPopup) {
										closePopup();
									}
								//#endif
								if (this.isImplicit) {
									// call command listener:
									Screen scr = getScreen();
									if (scr != null) {
										Command selectCmd = this.selectCommand;
										if (selectCmd == null) {
											selectCmd = List.SELECT_COMMAND;
										}
										scr.callCommandListener( selectCmd );
									}
								} else {
									notifyStateChanged();
								}
								notifyItemPressedStart();
								return true;
							}
						}
					}
				//#endif
//				//#ifdef polish.usePopupItem
//					if (this.isPopup && (this.isPopupClosed == false)) {
//						this.closePopupOnKeyRelease = true;
//						return true;
//					}
//				//#endif
			}
		}
//		//#else
//		// no popup item is used by this application:
//		processed = super.handleKeyPressed(keyCode, gameAction);
//		if (!processed) {
//			if (gameAction == Canvas.FIRE && keyCode != Canvas.KEY_NUM5 && this.focusedIndex != -1 ) {
//				ChoiceItem item = (ChoiceItem) this.focusedItem;
//				item.notifyItemPressedStart();
//				if (this.isMultiple) {
//					item.toggleSelect();
//				} else {
//					setSelectedIndex(this.focusedIndex, true);
//				}
//				if ( this.choiceType != IMPLICIT ) 
//				{
//					notifyStateChanged();
//				}
//				return true;
//			//#if polish.Container.dontUseNumberKeys != true
//			} else if ( (keyCode >= Canvas.KEY_NUM1) && (keyCode <= Canvas.KEY_NUM9) ) {
//				int index = keyCode - Canvas.KEY_NUM1;
//				if (index < this.itemsList.size()) {
//					Item item = getItem(index);
//					if (item.appearanceMode != PLAIN) {
//						setSelectedIndex( index, true );
//						if (this.isImplicit) {
//							// call command listener:
//							Screen scr = getScreen();
//							if (scr != null) {
//								Command selectCmd = this.selectCommand;
//								if (selectCmd == null) {
//									selectCmd = List.SELECT_COMMAND;
//								}
//								scr.callCommandListener( selectCmd );
//							}
//						} else {
//							notifyStateChanged();
//						}
//					}
//					return true;
//				}
//			//#endif
//			}
//		}
//		//#endif
		return processed;
	}
	
	
	
	//#ifdef polish.usePopupItem
	protected boolean handleNavigate(int keyCode, int gameAction) {
		if (this.isPopup && this.isPopupClosed) {
			return false;
		}
		return super.handleNavigate(keyCode, gameAction);
	}
	//#endif

	/**
	 * Selects a choice item.
	 * @param item the item
	 * @param isSelected true when it should be marked as selected
	 */
	protected void selectChoiceItem(ChoiceItem item, boolean isSelected)
	{
		item.select(isSelected);
		//#if !tmp.suppressMarkCommands
			if (this.isMultiple) {
				if (isSelected) {
					item.removeCommand(ChoiceGroup.MARK_COMMAND);
					item.setDefaultCommand(ChoiceGroup.UNMARK_COMMAND);
				} else {
					item.removeCommand(ChoiceGroup.UNMARK_COMMAND);
					item.setDefaultCommand(ChoiceGroup.MARK_COMMAND);
				}
			}
		//#endif
	}

	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Container#handleKeyReleased(int, int)
	 */
	protected boolean handleKeyReleased(int keyCode, int gameAction) {
		//#debug
		System.out.println("handleKeyReleased( " + keyCode + ", " + gameAction + " ) for " + this + ", isPressed="+ this.isPressed );
		//#ifdef polish.usePopupItem
			boolean isClosed = this.isPopupClosed;
		//#endif
		// note: this was a rough fix for selecting an entry on a popup choice group when the "Select" command button
		// was pressed - that worked for few cases and additionally required a Nokia layout, so it's outcommented for now
//		if ((gameAction == Canvas.FIRE && keyCode != Canvas.KEY_NUM5) 
//				|| (
//				//#if polish.key.LeftSoftKey:defined
//					//#= keyCode == ${polish.key.LeftSoftKey} 
//				//#else
//					keyCode == -6
//				//#endif	
//				&& this.isPopup && !this.isPopupClosed
//				)
//			) {
		boolean gameActionIsFire = (gameAction == Canvas.FIRE); 
		if (gameActionIsFire) {
			ChoiceItem choiceItem = (ChoiceItem) this.focusedItem;
			boolean handled = false;
			if (choiceItem != null
					//#ifdef polish.usePopupItem
						&& !(this.isPopup && isClosed)
					//#endif
					) 
			{
				if (this.isMultiple) {
					selectChoiceItem( choiceItem, !choiceItem.isSelected);
					handled = true;
				} else if (this.selectedIndex != this.focusedIndex){
					setSelectedIndex(this.focusedIndex, true);
					handled = true;
				}
				if ( handled && (this.choiceType != Choice.IMPLICIT) ) 
				{
					notifyStateChanged();
				}
				if (choiceItem.isPressed) {
					choiceItem.notifyItemPressedEnd();
					if (this.isImplicit) {
						// call command listener:
						Screen scr = getScreen();
						if (scr != null) {
							Command selectCmd = this.selectCommand;
							if (selectCmd == null) {
								selectCmd = List.SELECT_COMMAND;
							}
							scr.callCommandListener( selectCmd );
							handled = true;
						}
					}
				}
			}
			//#ifdef polish.usePopupItem
			if (this.isPopup) {
				if (isClosed) {
					notifyItemPressedEnd();
					openPopup();
				} else {
					closePopup();
				}
				handled = true;
			}
			//#endif
			return handled;
		}
//		//#ifdef polish.usePopupItem
//			if (this.closePopupOnKeyRelease) {
//				this.closePopupOnKeyRelease = false;
//				closePopup();
//				return true;
//			}
//		//#endif
		return super.handleKeyReleased(keyCode, gameAction);
	}

	//#ifdef polish.hasPointerEvents
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#handlePointerPressed(int, int)
	 */
	protected boolean handlePointerPressed(int relX, int relY) {
		//#debug
		System.out.println("ChoiceGroup.handlePointerPressed(" + relX + ", " + relY + ") for " + this );
		//#ifdef polish.usePopupItem
			if (this.isPopup && this.isPopupClosed && !isInItemArea(relX, relY)) {
				return false;
			}
		//#endif
		int index = this.focusedIndex;
		boolean handled = super.handlePointerPressed(relX, relY); // focuses the appropriate item, might change this.focusedIndex...
		relY -= this.contentY;
		relX -= this.contentX;
		//#ifdef tmp.supportViewType
			ContainerView contView = this.containerView;
			if (contView != null) {
				relX -= contView.getScrollXOffset();
			}
		//#endif
		boolean triggerKey = (    
				(handled || isInItemArea(relX, relY, this.focusedItem))
				//#if polish.css.view-type
				&& (index == this.focusedIndex || contView == null || contView.allowsDirectSelectionByPointerEvent) 
				//#endif
		);
		//#debug
		System.out.println("triggerKey=" + triggerKey + ", handled=" + handled + ", index=" + index + ", focusedIndex=" + this.focusedIndex + ", focusedItem=" + this.focusedItem  + ", isInItemArea(relX, relY, this.focusedItem)=" + isInItemArea(relX, relY, this.focusedItem));
		if (  triggerKey )  
		{
			this.isPointerReleaseShouldTriggerKeyRelease = true;
			handled |= handleKeyPressed( 0, Canvas.FIRE );
		}
		return handled;
	}
	//#endif
	
	//#ifdef polish.hasPointerEvents
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#handlePointerReleased(int, int)
	 */
	protected boolean handlePointerReleased(int relX, int relY) {
		//#debug
		System.out.println("ChoiceGroup.handlePointerReleased(" + relX + ", " + relY + ") for " + this + ", isPointerReleaseShouldTriggerKeyRelease=" + this.isPointerReleaseShouldTriggerKeyRelease + ", focusedItem=" + this.focusedItem + ", focusuedIndex=" + this.focusedIndex);
		if (this.enableScrolling && Math.abs(getScrollYOffset() - this.lastPointerPressYOffset)>20) {
			// if we handle this case below, we would trigger choice elements accidently while dragging items:
			return super.handlePointerReleased(relX, relY);
		}
		//#ifdef polish.usePopupItem
			boolean isClosed = this.isPopupClosed;
			if (this.isFocused && this.isPopup && isClosed) {
				if (isInItemArea(relX, relY)) {
					openPopup();
					return true;
				} else {
					return false;
				}
			}
		//#endif
		if (   this.isPointerReleaseShouldTriggerKeyRelease ) { 
			this.isPointerReleaseShouldTriggerKeyRelease = false;
			
			boolean handled = handlePointerScrollReleased(relX, relY);
			if (!handled) {
				//#ifdef tmp.supportViewType
				ContainerView contView = this.containerView;
					if (contView != null) {
						handled = contView.handlePointerReleased(relX, relY - this.yOffset);
					}
				//#endif
				int x = relX;
				//#ifdef tmp.supportViewType
					if (contView != null) {
						x -= contView.getScrollXOffset();
					}
				//#endif
//				System.out.println("isInItemArea(relX - this.contentX, relY - this.yOffset - this.contentY, this.focusedItem)=" + isInItemArea(relX - this.contentX, relY - this.yOffset - this.contentY, this.focusedItem));
				if (!handled && isInItemArea(x - this.contentX, relY - this.yOffset - this.contentY, this.focusedItem)) {
					handled = handleKeyReleased( 0, Canvas.FIRE );
				}
			}
			if (handled) {
				return true;
			}
		}
		boolean handled = super.handlePointerReleased(relX, relY);
		//#ifdef polish.usePopupItem
			if (!handled && this.isPopup && !isClosed) { // && isEventCloseBy ) {
				closePopup();
				handled = true;
			}
		//#endif
		return handled;
	}
	//#endif

	

//	//#ifdef polish.hasPointerEvents && polish.usePopupItem
//	/* (non-Javadoc)
//	 * @see de.enough.polish.ui.Container#handlePointerDragged(int, int)
//	 */
//	protected boolean handlePointerDragged(int relX, int relY)
//	{
//		if (this.isPopup  && !this.isPopupClosed) {
//			
//		}
//		return super.handlePointerDragged(relX, relY);
//	}
//	//#endif

	//#if polish.usePopupItem
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#isInContentArea(int, int)
	 */
	public boolean isInContentArea(int relX, int relY) {
		if (this.isPopup && !this.isPopupClosed) {
			if (relY < this.contentY || relY > this.contentY + this.originalContentHeight) {
				return false;
			}
			if (relX < this.contentX || relX > this.contentX + this.originalContentWidth) {
				return false;
			}
			return true;
		} else {
			return super.isInContentArea(relX, relY);
		}
	}
	//#endif

	//#if polish.usePopupItem
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#isInItemArea(int, int)
	 */
	public boolean isInItemArea(int relX, int relY) {
		if (this.isPopup) {
			if(this.isPopupClosed) {
				if (relY < 0 || relY > this.itemHeight) {
					return false;
				}
			} else {
				if (relY < 0 || relY > (this.itemHeight + (this.originalContentHeight - this.contentHeight)) 
						|| relX < 0 || relX > (this.itemWidth + (this.originalContentWidth - this.contentWidth)))
				{
					return false;
				}
			}
			return true;
		} else {
			return super.isInItemArea(relX, relY);
		}
	}
	//#endif

	/**
	 * Sets the select command for this choice group.
	 *
	 * @param command the new select command
	 */
	protected void setSelectCommand(Command command) {
		this.selectCommand = command;
	}
	
	
	//#ifndef tmp.suppressAllCommands
	/**
	 * Sets the command for selecting this (and opening this POPUP) choicegroup.
	 * This implementation only works like described when not all ChoiceGroup commands are deactivated
	 * by specifying the <variable name="polish.ChoiceGroup.suppressMarkCommands" value="true"/>
	 * and <variable name="polish.ChoiceGroup.suppressSelectCommand" value="true"/>
	 * preprocessing variables. When all commands are deactivated by the mentioned preprocessing variables,
	 * the implementation of Item is used instead.
	 * 
	 * @param cmd the new command for selecting this choice group
	 */
	public void setDefaultCommand(Command cmd) {
		if (this.choiceType == Choice.MULTIPLE) {
			//#ifndef tmp.suppressMarkCommands
				removeCommand( MARK_COMMAND );
			//#endif
		} else {
			//#ifndef tmp.suppressSelectCommand
				removeCommand( List.SELECT_COMMAND );
				if (this.selectCommand != null) {
					removeCommand( this.selectCommand );
				}
			//#endif
		}
		
		//removed due to potential infinite loops
		/*
		 * if (this.additionalItemCommandListener == null) {
			this.additionalItemCommandListener = this.itemCommandListener;
		}*/
		
		addCommand( cmd );
		this.selectCommand = cmd;
		this.defaultCommand = cmd;
		this.itemCommandListener = this;
	}
	//#endif
	
	//#ifdef polish.usePopupItem
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#defocus(de.enough.polish.ui.Style)
	 */
	public void defocus(Style originalStyle) {
		if (this.isPopup) {
			if (this.isPopupClosed) {
				this.popupItem.setStyle( originalStyle );
			} else {
				closePopup();
			}
			setStyle( originalStyle );
			// now remove any commands which are associated with this item:
			Screen scr = getScreen();
			if (scr != null) {
				scr.removeItemCommands(this);
			}
			// change the label-style of this container:
			//#ifdef polish.css.label-style
				Style tmpLabelStyle = null;
				if ( originalStyle != null) {
					tmpLabelStyle = (Style) originalStyle.getObjectProperty("label-style");
				}
				if (tmpLabelStyle == null) {
					tmpLabelStyle = StyleSheet.labelStyle;
				}
				if (this.label != null && tmpLabelStyle != null && this.label.style != tmpLabelStyle) {
					this.label.setStyle( tmpLabelStyle );
				}
			//#endif
			this.isFocused = false;
		} else {
			super.defocus(originalStyle);
		}
	}
	//#endif

	//#ifdef polish.usePopupItem	
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#focus(de.enough.polish.ui.Style, int)
	 */
	protected Style focus(Style focusStyle, int direction) {
		if (this.isPopup && this.isPopupClosed) {
			if (focusStyle == null) {
				focusStyle = getFocusedStyle();
			}
			Style original = this.style;
			this.popupItem.setStyle( focusStyle );
			setStyle( focusStyle );
			// now remove any commands which are associated with this item:
			showCommands();
//			Screen scr = getScreen();
//			if (scr != null) {
//				scr.setItemCommands(this);
//			}
			// change the label-style of this container:
			//#ifdef polish.css.label-style
				if (this.label != null) {
					Style labStyle = (Style) focusStyle.getObjectProperty("label-style");
					if (labStyle != null) {
						this.labelStyle = this.label.style;
						this.label.setStyle( labStyle );
					}
				}
			//#endif
			this.isFocused = true;
			return original;
		} else {
			return super.focus(focusStyle, direction);
		}
	}
	//#endif
	
	
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Container#setStyleWithBackground(de.enough.polish.ui.Style, boolean)
	 */
	public void setStyleWithBackground(Style style, boolean ignoreBackground)
	{
//		System.out.println("ChoiceGroup " + this.label + ", setStyle " + style.name);
		super.setStyleWithBackground(style, ignoreBackground);
		//#ifdef polish.usePopupItem
			if (this.isPopup && this.popupItem != null) {
				this.popupItem.setStyle( style );
			}
			if (this.isPopup && this.popupItem.image == null ) {
				//#ifdef polish.css.popup-image
					String url = style.getProperty("popup-image");
					if (url != null ) {
						this.popupItem.setImage( url );
					}
				//#endif
				//#ifdef polish.css.popup-roundtrip
					Boolean popupRoundTripBool = style.getBooleanProperty("popup-roundtrip");
					if (popupRoundTripBool != null) {
						this.popupRoundTrip = popupRoundTripBool.booleanValue();
					}
				//#endif
				//#if ! tmp.suppressSelectCommand && tmp.supportViewType
					if (!this.isSelectCommandAdded && this.choiceType == Choice.EXCLUSIVE && this.containerView == null) {
						if (this.selectCommand != null) {
							setDefaultCommand( this.selectCommand );
						} else {
							setDefaultCommand( List.SELECT_COMMAND );
						}
						this.isSelectCommandAdded = true;				
					}
				//#endif
			}
		//#endif
		//#ifndef tmp.suppressAllCommands
			if (this.choiceType == Choice.MULTIPLE) {
				//#ifndef tmp.suppressMarkCommands
					//#ifdef polish.i18n.useDynamicTranslations
						String cmdLabel = Locale.get("polish.command.mark");
						if (cmdLabel != MARK_COMMAND.getLabel()) {
							MARK_COMMAND = new Command( cmdLabel, Command.ITEM, 9 );
						}
						cmdLabel = Locale.get("polish.command.unmark");
						if (cmdLabel != UNMARK_COMMAND.getLabel()) {
							UNMARK_COMMAND = new Command( cmdLabel, Command.ITEM, 10 );
						}
					//#endif					
					//addCommand( MARK_COMMAND );
					//addCommand( UNMARK_COMMAND );
				//#endif
			} else if (this.choiceType == Choice.EXCLUSIVE){
				//#if !tmp.suppressSelectCommand
					//#if tmp.supportViewType
						if (this.containerView == null) {
					//#endif
						//#ifdef polish.i18n.useDynamicTranslations
							String cmdLabel = Locale.get("polish.command.select");
							if (cmdLabel != List.SELECT_COMMAND.getLabel()) {
								List.SELECT_COMMAND = new Command( cmdLabel, Command.ITEM, 3 );
							}
						//#endif
						setDefaultCommand( List.SELECT_COMMAND );
					//#if tmp.supportViewType
						}
					//#endif
				//#endif
			}
			this.itemCommandListener = this;
		//#endif
		setStyle( style, true );
	}
	
	//#ifdef polish.usePopupItem
		/* (non-Javadoc)
		 * @see de.enough.polish.ui.Container#setStyle(de.enough.polish.ui.Style, boolean)
		 */
		public void setStyle(Style style, boolean resetStyle) {
			super.setStyle(style, resetStyle);
			if (!resetStyle && this.isPopup && this.popupItem != null) {
				this.popupItem.setStyle( style, resetStyle );
			}
			if (this.isPopup && this.popupItem.image == null ) {
				//#ifdef polish.css.popup-color
					Integer color = style.getIntProperty("popup-color");
					if (color != null) {
						this.popupColor = color.intValue();
					}
				//#endif
				//#ifdef polish.css.popup-background-color
					Integer bgColor = style.getIntProperty("popup-background-color");
					if (bgColor != null) {
						this.popupBackgroundColor = bgColor.intValue();
					}
				//#endif
			}
		}
	//#endif

	//#ifndef tmp.suppressAllCommands
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.ItemCommandListener#commandAction(javax.microedition.lcdui.Command, de.enough.polish.ui.Item)
	 */
	public void commandAction(Command c, Item item) {
		//#debug
		System.out.println("handle item command " + c.getLabel() + " for " + item );
		if (item == this || this.itemsList.contains(item)) {
			handleCommand( c );
		}
	}
	//#endif
	
	//#if polish.usePopupItem || !tmp.suppressAllCommands
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Container#handleCommand(javax.microedition.lcdui.Command)
	 */
	protected boolean handleCommand(Command cmd)
	{
		//#debug
		System.out.println("handle command " + cmd.getLabel());
		//#ifdef polish.usePopupItem
			if (this.isPopup && !this.isPopupClosed) {
				if (cmd == StyleSheet.OK_CMD) {
					ChoiceItem choiceItem = (ChoiceItem) this.focusedItem;
					if (choiceItem != null) 
					{
						setSelectedIndex(this.focusedIndex, true);
						notifyStateChanged();
					}
					closePopup();
					return true;
				} else if (cmd == StyleSheet.CANCEL_CMD) {
					closePopup();
					return true;
				}
			}
		//#endif
		//#ifndef tmp.suppressAllCommands
			//#if tmp.allowSelectCommand && tmp.allowMarkCommands
				if (cmd == List.SELECT_COMMAND || cmd == MARK_COMMAND || cmd == this.selectCommand  ) {
			//#elif tmp.allowSelectCommand
				//# if (cmd == List.SELECT_COMMAND || cmd == this.selectCommand ) {
			//#elif tmp.allowMarkCommands
				//# if (cmd == MARK_COMMAND || cmd == this.selectCommand ) {
			//#else
				//#abort Invalid combination of suppressed commands for a ChoiceGroup!
				//# if (false) {
			//#endif
				if (this.focusedIndex != -1) {
					setSelectedIndex( this.focusedIndex, true );
					if ( (this.choiceType != Choice.IMPLICIT) 
							//#ifdef polish.usePopupItem
							&& !(this.isPopup && !this.isPopupClosed)
							//#endif
					) {
						notifyStateChanged();
					}
					//#ifdef polish.usePopupItem
						if (this.isPopup) {
							if (this.isPopupClosed) {
								openPopup();
							} else {
								closePopup();
							}
							repaint();
						}
					//#endif
					return !this.isImplicit;
				}
				//#ifdef polish.usePopupItem
					else if (this.isPopup && this.isPopupClosed) {
						openPopup();
						return true;
					}
				//#endif
			//#ifdef tmp.allowMarkCommands
			} else if (cmd == UNMARK_COMMAND ) {
				if (this.focusedIndex != -1) {
					setSelectedIndex( this.focusedIndex, false );
					if ( (this.choiceType != Choice.IMPLICIT) 
							//#ifdef polish.usePopupItem
							&& !(this.isPopup && !this.isPopupClosed)
							//#endif
					) {
						notifyStateChanged();
					}
					return true;
				}
			//#endif
			} else if (this.additionalItemCommandListener != null && this.additionalItemCommandListener != this) {
				this.additionalItemCommandListener.commandAction(cmd, this);
				return true;
			}
		//#endif
		return super.handleCommand(cmd);
	}
	//#endif
	
	
	//#ifndef tmp.suppressAllCommands
	public void setItemCommandListener(ItemCommandListener l) {
		this.additionalItemCommandListener = l;
	}
	//#endif

	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Container#setItemsList(de.enough.polish.util.ArrayList)
	 */
	public void setItemsList(ArrayList itemsList) {
		this.selectedIndex = -1;
		super.setItemsList(itemsList);
	}

	/**
	 * Retrieves the choice type of this group 
	 * @return the choice type, either MULTIPLE, EXCLUSIVE or POPUP
	 */
	public int getType()
	{
		return this.choiceType;
	}

//	//#ifdef polish.usePopupItem
//	/* (non-Javadoc)
//	 * @see de.enough.polish.ui.Item#getItemHeightOverlap()
//	 */
//	public int getItemHeightOverlap()
//	{
//		if (this.isPopup && !this.isPopupClosed) {
//			int res = this.backgroundHeight - this.itemHeight;
//			if (res > 0) {
//				return res;
//			}
//		}
//		return 0;
//	}
//	//#endif


	
	

}
