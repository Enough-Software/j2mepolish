//#condition (polish.midp1 || polish.usePolishGameApi == true) || ((polish.blackberry || polish.doja || polish.android) && polish.usePolishGui)  

// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2004-2005 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.ui.game;


import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;
//#ifdef polish.api.siemens-color-game-api
	//# import com.siemens.mp.color_game.TiledLayer;
//#endif

//#ifdef polish.api.nokia-ui
	import com.nokia.mid.ui.DirectGraphics;
	import com.nokia.mid.ui.DirectUtils;
//#endif

/**
 * A Sprite is a basic visual element that can be rendered with one of
 * several frames stored in an Image; different frames can be shown to
 * animate the Sprite.  Several transforms such as flipping and rotation
 * can also be applied to a Sprite to further vary its appearance.  As with
 * all Layer subclasses, a Sprite's location can be changed and it can also
 * be made visible or invisible.
 * <h3>Sprite Frames</h3>
 * The raw frames used to render a Sprite are provided in a single Image
 * object, which may be mutable or immutable.  If more than one frame is used,
 * the Image is broken up into a series of equally-sized frames of a specified
 * width and height.  As shown in the figure below, the same set of frames may
 * be stored in several different arrangements depending on what is the most
 * convenient for the game developer.
 * <br>
 * <center><img src="doc-files/frames.gif" width=777 height=402 ALT="Sprite Frames" /></center>
 * <br>
 * <p>
 * Each frame is assigned a unique index number.  The frame located in the
 * upper-left corner of the Image is assigned an index of 0.  The remaining
 * frames are then numbered consecutively in row-major order (indices are
 * assigned across the first row, then the second row, and so on).  The method
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRawFrameCount()"><CODE>getRawFrameCount()</CODE></A> returns the total number of raw frames.
 * <h3>Frame Sequence</h3>
 * A Sprite's frame sequence defines an ordered list of frames to be displayed.
 * The default frame sequence mirrors the list of available frames, so
 * there is a direct mapping between the sequence index and the corresponding
 * frame index.  This also means that the length of the default frame sequence
 * is equal to the number of raw frames.  For example, if a Sprite has 4
 * frames, its default frame sequence is {0, 1, 2, 3}.
 * <center><img src="doc-files/defaultSequence.gif" width=182 height=269 ALT="Default Frame Sequence" /></center>
 * The developer must manually switch the current frame in the frame sequence.
 * This may be accomplished by calling <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setFrame(int)"><CODE>setFrame(int)</CODE></A>,
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#prevFrame()"><CODE>prevFrame()</CODE></A>, or <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#nextFrame()"><CODE>nextFrame()</CODE></A>.  Note that these methods
 * always operate on the sequence index, they do not operate on frame indices;
 * however, if the default frame sequence is used, then the sequence indices
 * and the frame indices are interchangeable.
 * If desired, an arbitrary frame sequence may be defined for a Sprite.
 * The frame sequence must contain at least one element, and each element must
 * reference a valid frame index.  By defining a new frame sequence, the
 * developer can conveniently display the Sprite's frames in any order
 * desired; frames may be repeated, omitted, shown in reverse order, etc.
 * For example, the diagram below shows how a special frame sequence might be
 * used to animate a mosquito.  The frame sequence is designed so that the
 * mosquito flaps its wings three times and then pauses for a moment before
 * the cycle is repeated.
 * <center><img src="doc-files/specialSequence.gif" width=346 height=510 ALT="Special Frame Sequence" /></center>
 * By calling <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#nextFrame()"><CODE>nextFrame()</CODE></A> each time the display is updated, the
 * resulting animation would like this:
 * <br>
 * <center><img src="doc-files/sequenceDemo.gif" width=96 height=36 /></center>
 * <h3>Reference Pixel</h3>
 * Being a subclass of Layer, Sprite inherits various methods for setting and
 * retrieving its location such as <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#setPosition(int, int)"><CODE>setPosition(x,y)</CODE></A>,
 * <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getX()"><CODE>getX()</CODE></A>, and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getY()"><CODE>getY()</CODE></A>.  These methods all define
 * position in terms of the upper-left corner of the Sprite's visual bounds;
 * however, in some cases, it is more convenient to define the Sprite's position
 * in terms of an arbitrary pixel within its frame, especially if transforms
 * are applied to the Sprite.
 * Therefore, Sprite includes the concept of a <em>reference pixel</em>.
 * The reference pixel is defined by specifying its location in the
 * Sprite's untransformed frame using
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#defineReferencePixel(int, int)"><CODE>defineReferencePixel(x,y)</CODE></A>.
 * By default, the reference pixel is defined to be the pixel at (0,0)
 * in the frame.  If desired, the reference pixel may be defined outside
 * of the frame's bounds.
 * <p>
 * In this example, the reference pixel is defined to be the pixel that
 * the monkey appears to be hanging from:
 * <p>
 * <center><img src="doc-files/refpixel.gif" width=304 height=199 ALT="Defining The Reference Pixel" /></center>
 * <p>
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelX()"><CODE>getRefPixelX()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelY()"><CODE>getRefPixelY()</CODE></A>
 * can be used to query the location of the reference pixel in the painter's
 * coordinate system.  The developer can also use
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setRefPixelPosition(int, int)"><CODE>setRefPixelPosition(x,y)</CODE></A> to position the Sprite
 * so that reference pixel appears at a specific location in the painter's
 * coordinate system.  These methods automatically account for any transforms
 * applied to the Sprite.
 * <p>
 * In this example, the reference pixel's position is set to a point at the end
 * of a tree branch; the Sprite's location changes so that the reference pixel
 * appears at this point and the monkey appears to be hanging from the branch:
 * <p>
 * <center><img src="doc-files/setrefposition.gif" width=332 height=350 ALT="Setting The Reference Pixel Position" /></center>
 * <p>
 * <a name="transforms"></a>
 * <h3>Sprite Transforms</h3>
 * Various transforms can be applied to a Sprite.  The available transforms
 * include rotations in multiples of 90 degrees, and mirrored (about
 * the vertical axis) versions of each of the rotations.  A Sprite's transform
 * is set by calling <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setTransform(int)"><CODE>setTransform(transform)</CODE></A>.
 * <p>
 * <center><img src="doc-files/transforms.gif" width=355 height=575 ALT="Transforms" /></center>
 * <br>
 * When a transform is applied, the Sprite is automatically repositioned
 * such that the  reference pixel appears stationary in the painter's
 * coordinate system.  Thus, the reference pixel effectively becomes the
 * center of the transform operation.  Since the reference pixel does not
 * move, the values returned by <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelX()"><CODE>getRefPixelX()</CODE></A> and
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelY()"><CODE>getRefPixelY()</CODE></A> remain the same; however, the values returned by
 * <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getX()"><CODE>getX()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getY()"><CODE>getY()</CODE></A> may change to reflect the
 * movement of the Sprite's upper-left corner.
 * <p>
 * Referring to the monkey example once again, the position of the
 * reference pixel remains at (48, 22) when a 90 degree rotation
 * is applied, thereby making it appear as if the monkey is swinging
 * from the branch:
 * <p>
 * <center><img src="doc-files/transcenter.gif" width=333 height=350 ALT="Transform Center" /></center>
 * <p>
 * <h3>Sprite Drawing</h3>
 * Sprites can be drawn at any time using the <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#paint(javax.microedition.lcdui.Graphics)"><CODE>paint(Graphics)</CODE></A> method.
 * The Sprite will be drawn on the Graphics object according to the current
 * state information maintained by the Sprite (i.e. position, frame,
 * visibility).  Erasing the Sprite is always the responsibility of code
 * outside the Sprite class.<p>
 * <p>
 * Sprites can be implemented using whatever techniques a manufacturers
 * wishes to use (e.g hardware acceleration may be used for all Sprites, for
 * certain sizes of Sprites, or not at all).
 * <p>
 * For some platforms, certain Sprite sizes may be more efficient than others;
 * manufacturers may choose to provide developers with information about
 * device-specific characteristics such as these.
 * <p>
  * 
 * <p>Copyright Enough Software 2005 - 2009</p>
 * @author Robert Virkus (original implementation)
 * @author Thomas Boyer (optimizations)
 */
public class Sprite
//#ifdef polish.api.siemens-color-game-api
	//# extends com.siemens.mp.color_game.Sprite
//#else
	extends Layer
//#endif
{
	/**
	 * No transform is applied to the Sprite.
	 * This constant has a value of <code>0</code>.
	 */
	public static final int TRANS_NONE = 0;

	/**
	 * Causes the Sprite to appear rotated clockwise by 90 degrees.
	 * This constant has a value of <code>5</code>.
	 */
	public static final int TRANS_ROT90 = 5;

	/**
	 * Causes the Sprite to appear rotated clockwise by 180 degrees.
	 * This constant has a value of <code>3</code>.
	 */
	public static final int TRANS_ROT180 = 3;

	/**
	 * Causes the Sprite to appear rotated clockwise by 270 degrees.
	 * This constant has a value of <code>6</code>.
	 */
	public static final int TRANS_ROT270 = 6;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center.
	 * This constant has a value of <code>2</code>.
	 */
	public static final int TRANS_MIRROR = 2;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center and then rotated clockwise by 90 degrees.
	 * This constant has a value of <code>7</code>.
	 */
	public static final int TRANS_MIRROR_ROT90 = 7;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center and then rotated clockwise by 180 degrees.
	 * This constant has a value of <code>1</code>.
	 */
	public static final int TRANS_MIRROR_ROT180 = 1;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center and then rotated clockwise by 270 degrees.
	 * This constant has a value of <code>4</code>.
	 */
	public static final int TRANS_MIRROR_ROT270 = 4;
		
	private Image image;
	private int refPixelX;
	private int refPixelY;
	private int frameSequenceIndex;
	private int[] frameSequence;
	private int transform;
	//#ifdef polish.api.nokia-ui
		private static final int[] NOKIA_TRANSFORM_LOOKUP = {
			0,
			DirectGraphics.FLIP_VERTICAL,
			DirectGraphics.FLIP_HORIZONTAL,
			DirectGraphics.ROTATE_180,
			DirectGraphics.ROTATE_90 | DirectGraphics.FLIP_VERTICAL,
			DirectGraphics.ROTATE_270,
			DirectGraphics.ROTATE_90,
			DirectGraphics.ROTATE_90 | DirectGraphics.FLIP_HORIZONTAL
		};
		private int nokiaTransform;
		private Image nokiaFrame;
		private Image[] nokiaFrames;
	//#endif
	private int collisionX;
	private int collisionY;
	private int collisionWidth;
	private int collisionHeight;
	private int transformedCollisionX;
	private int transformedCollisionY;
	private int transformedCollisionWidth;
	private int transformedCollisionHeight;

	private int frameHeight;
	private int frameWidth;
	private int rawFrameCount;
	private boolean isSingleFrame;
	private int transformedRefX;
	private int transformedRefY;
	private int numberOfColumns;
	private int column;
	private int row;
	
	//#ifdef polish.api.siemens-color-game-api
		//# protected int xPosition;
		//# protected int yPosition;
		//# protected int width;
		//# protected int height;
		//# protected boolean isVisible = true;
	//#endif

	/**
	 * Creates a new non-animated Sprite using the provided Image.
	 * This constructor is functionally equivalent to calling
	 * <code>new Sprite(image, image.getWidth(), image.getHeight())</code>
	 * <p>
	 * By default, the Sprite is visible and its upper-left
	 * corner is positioned at (0,0) in the painter's coordinate system.
	 * <br>
	 * 
	 * @param image the Image to use as the single frame for the Sprite
	 * @throws NullPointerException if img is null
	 */
	public Sprite( Image image)
	{
		//#ifdef polish.api.siemens-color-game-api
			//# super( image );
		//#else
			setImage( image, image.getWidth(), image.getHeight() );
		//#endif
	}

	/**
	 * Creates a new animated Sprite using frames contained in
	 * the provided Image.  The frames must be equally sized, with the
	 * dimensions specified by <code>frameWidth</code> and
	 * <code>frameHeight</code>.  They may be laid out in the image
	 * horizontally, vertically, or as a grid.  The width of the source
	 * image must be an integer multiple of the frame width, and the height
	 * of the source image must be an integer multiple of the frame height.
	 * The  values returned by <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getWidth()"><CODE>Layer.getWidth()</CODE></A> and
	 * <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getHeight()"><CODE>Layer.getHeight()</CODE></A> will reflect the frame width and frame height
	 * subject to the Sprite's current transform.
	 * <p>
	 * Sprites have a default frame sequence corresponding to the raw frame
	 * numbers, starting with frame 0.  The frame sequence may be modified
	 * with <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setFrameSequence(int[])"><CODE>setFrameSequence(int[])</CODE></A>.
	 * <p>
	 * By default, the Sprite is visible and its upper-left corner is
	 * positioned at (0,0) in the painter's coordinate system.
	 * <p>
	 * 
	 * @param image the Image to use for Sprite
	 * @param frameWidth the width, in pixels, of the individual raw frames
	 * @param frameHeight the height, in pixels, of the individual raw frames
	 * @throws NullPointerException if img is null
	 * @throws IllegalArgumentException if frameHeight or frameWidth is less than 1
	 *									or if the image width is not an integer multiple of the frameWidth
	 *									or if the image height is not an integer multiple of the frameHeight
	 */
	public Sprite( Image image, int frameWidth, int frameHeight)
	{
		//#ifdef polish.api.siemens-color-game-api
			//# super( image, frameWidth, frameHeight );
		//#else
			setImage(image, frameWidth, frameHeight);
		//#endif
	}

	/**
	 * Creates a new Sprite from another Sprite. 
	 * 
	 * All instance attributes (raw frames, position, frame sequence, current
	 * frame, reference point, collision rectangle, transform, and visibility)
	 * of the source Sprite are duplicated in the new Sprite.
	 * 
	 * @param s  the Sprite to create a copy of
	 * @throws NullPointerException if s is null
	 */
	public Sprite( Sprite s)
	{
		//#ifdef polish.api.siemens-color-game-api
			//# super( s );
			this.refPixelX = s.refPixelX;
			this.refPixelY = s.refPixelY;
			this.transformedRefX = s.transformedRefX;
			this.transformedRefY = s.transformedRefY;
			this.transform = s.transform;
			this.transformedCollisionX = s.transformedCollisionX;
			this.transformedCollisionY = s.transformedCollisionY;
			this.transformedCollisionWidth = s.transformedCollisionWidth;
			this.transformedCollisionHeight = s.transformedCollisionHeight;
		//#else
			this.image = s.image;
			this.frameWidth = s.frameWidth;
			this.frameHeight = s.frameHeight;
			this.numberOfColumns = s.numberOfColumns;
			this.width = s.width;
			this.height = s.height;
			this.xPosition = s.xPosition;
			this.yPosition = s.yPosition;
			this.frameSequenceIndex = s.frameSequenceIndex;
			if (s.frameSequence != null) {
				this.frameSequence = new int[s.frameSequence.length];
				System.arraycopy(s.frameSequence, 0, this.frameSequence, 0, this.frameSequence.length);
			}
			this.refPixelX = s.refPixelX;
			this.refPixelY = s.refPixelY;
			this.transformedRefX = s.transformedRefX;
			this.transformedRefY = s.transformedRefY;
			this.transform = s.transform;
			//#ifdef polish.api.nokia-ui
				this.nokiaTransform = s.nokiaTransform;
				this.nokiaFrame = s.nokiaFrame;
				this.nokiaFrames = s.nokiaFrames;
			//#endif
			this.collisionX = s.collisionX;
			this.collisionY = s.collisionY;
			this.collisionWidth = s.collisionWidth;
			this.collisionHeight = s.collisionHeight;
			this.transformedCollisionX = s.transformedCollisionX;
			this.transformedCollisionY = s.transformedCollisionY;
			this.transformedCollisionWidth = s.transformedCollisionWidth;
			this.transformedCollisionHeight = s.transformedCollisionHeight;
			this.isSingleFrame = s.isSingleFrame;
		//#endif
	}

	/**
	 * Defines the reference pixel for this Sprite.  The pixel is
	 * defined by its location relative to the upper-left corner of
	 * the Sprite's un-transformed frame, and it may lay outside of
	 * the frame's bounds.
	 * <p>
	 * When a transformation is applied, the reference pixel is
	 * defined relative to the Sprite's initial upper-left corner
	 * before transformation. This corner may no longer appear as the
	 * upper-left corner in the painter's coordinate system under
	 * current transformation.
	 * <p>
	 * By default, a Sprite's reference pixel is located at (0,0); that is,
	 * the pixel in the upper-left corner of the raw frame.
	 * <p>
	 * Changing the reference pixel does not change the
	 * Sprite's physical position in the painter's coordinate system;
	 * that is, the values returned by <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getX()"><CODE>getX()</CODE></A> and
	 * <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getY()"><CODE>getY()</CODE></A> will not change as a result of defining the
	 * reference pixel.  However, subsequent calls to methods that
	 * involve the reference pixel will be impacted by its new definition.
	 * 
	 * @param refX the horizontal location of the reference pixel, relative to the left edge of the un-transformed frame
	 * @param refY the vertical location of the reference pixel, relative to the top edge of the un-transformed frame
	 * @see #setRefPixelPosition(int, int)
	 * @see #getRefPixelX()
	 * @see #getRefPixelY()
	 */
	public void defineReferencePixel(int refX, int refY)
	{
		this.refPixelX = refX;
		this.refPixelY = refY;
		applyTransform();
	}

	/**
	 * Sets this Sprite's position such that its reference pixel is located
	 * at (x,y) in the painter's coordinate system.
	 * 
	 * @param x the horizontal location at which to place the reference pixel
	 * @param y the vertical location at which to place the reference pixel
	 * @see #defineReferencePixel(int, int)
	 * @see #getRefPixelX()
	 * @see #getRefPixelY()
	 */
	public void setRefPixelPosition(int x, int y)
	{
		//#ifdef polish.api.siemens-color-game
			this.move(x - this.transformedRefX, y - this.transformedRefY );
		//#else
			this.xPosition = x - this.transformedRefX;
			this.yPosition = y - this.transformedRefY;
		//#endif
	}

	/**
	 * Gets the horizontal position of this Sprite's reference pixel
	 * in the painter's coordinate system.
	 * 
	 * @return the horizontal location of the reference pixel
	 * @see #defineReferencePixel(int, int)
	 * @see #setRefPixelPosition(int, int)
	 * @see #getRefPixelY()
	 */
	public int getRefPixelX()
	{
		return this.transformedRefX + this.xPosition;
	}

	/**
	 * Gets the vertical position of this Sprite's reference pixel
	 * in the painter's coordinate system.
	 * 
	 * @return the vertical location of the reference pixel
	 * @see #defineReferencePixel(int, int)
	 * @see #setRefPixelPosition(int, int)
	 * @see #getRefPixelX()
	 */
	public int getRefPixelY()
	{
		return this.transformedRefY + this.yPosition;
	}

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Selects the current frame in the frame sequence.  
	 * <p>
	 * The current frame is rendered when 
	 * <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#paint(javax.microedition.lcdui.Graphics)"><CODE>paint(Graphics)</CODE></A>
	 * is called.
	 * <p>
	 * The index provided refers to the desired entry in the frame sequence,
	 * not the index of the actual frame itself.
	 * 
	 * @param sequenceIndex the index of of the desired entry in the frame  sequence
	 * @throws IndexOutOfBoundsException if frameIndex is less than 0
	 *									 or if frameIndex is equal to or greater than the length of the current frame sequence (or the number of raw frames for the default sequence)
	 * @see #setFrameSequence(int[])
	 * @see #getFrame()
	 */
	public void setFrame(int sequenceIndex)
	{
		this.frameSequenceIndex = sequenceIndex;
		updateFrame();
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Gets the current index in the frame sequence.
	 * The index returned refers to the current entry in the frame sequence,
	 * not the index of the actual frame that is displayed.
	 * 
	 * @return the current index in the frame sequence
	 * @see #setFrameSequence(int[])
	 * @see #setFrame(int)
	 */
	public final int getFrame()
	{
		return this.frameSequenceIndex;
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Gets the number of raw frames for this Sprite.  The value returned
	 * reflects the number of frames; it does not reflect the length of the
	 * Sprite's frame sequence.  However, these two values will be the same
	 * if the default frame sequence is used.
	 * 
	 * @return the number of raw frames for this Sprite
	 * @see #getFrameSequenceLength()
	 */
	public int getRawFrameCount()
	{
		return this.rawFrameCount;
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Gets the number of elements in the frame sequence.  The value returned
	 * reflects the length of the Sprite's frame sequence; it does not reflect
	 * the number of raw frames.  However, these two values will be the same
	 * if the default frame sequence is used.
	 * 
	 * @return the number of elements in this Sprite's frame sequence
	 * @see #getRawFrameCount()
	 */
	public int getFrameSequenceLength()
	{
		if (this.frameSequence == null)
			return this.rawFrameCount;
		return this.frameSequence.length;
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Selects the next frame in the frame sequence.
	 * 
	 * The frame sequence is considered to be circular, i.e. if
	 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#nextFrame()"><CODE>nextFrame()</CODE></A> is called when at the end of the sequence,
	 * this method will advance to the first entry in the sequence.
	 * 
	 * @see #setFrameSequence(int[])
	 * @see #prevFrame()
	 */
	public void nextFrame()
	{
		this.frameSequenceIndex++;
		if (this.frameSequenceIndex >= this.getFrameSequenceLength()) {
			this.frameSequenceIndex = 0;
		}
		updateFrame();
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Selects the previous frame in the frame sequence.  <p>
	 * 
	 * The frame sequence is considered to be circular, i.e. if
	 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#prevFrame()"><CODE>prevFrame()</CODE></A> is called when at the start of the sequence,
	 * this method will advance to the last entry in the sequence.
	 * 
	 * @see #setFrameSequence(int[])
	 * @see #nextFrame()
	 */
	public void prevFrame()
	{
		this.frameSequenceIndex--;
		if (this.frameSequenceIndex < 0 ) {
			this.frameSequenceIndex = this.getFrameSequenceLength() - 1;
		}
		updateFrame();
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Updates the position at which the image should be drawn,
	 * This depends on the frame-index as well as the current transformation.
	 */
	private void updateFrame() {
		int frameIndex = (this.frameSequence == null) ? this.frameSequenceIndex : this.frameSequence[this.frameSequenceIndex];
		int c = frameIndex % this.numberOfColumns;
		int r = frameIndex / this.numberOfColumns;
		
		//#ifdef polish.api.nokia-ui
			Image frame = this.nokiaFrames[ frameIndex ];
			if ( frame == null ) {
				frame = DirectUtils.createImage( this.frameWidth, this.frameHeight, 0x00FFFFFF );
				Graphics g = frame.getGraphics();
				// when creating an transparent image, one must not "touch"
				// that image with an ordinary Graphics-object --- instead
				// ALWAYS an DirectGraphics-object needs to be used. Sigh!
				//g.drawImage(this.image, -(c * this.frameWidth), -(r * this.frameHeight), Graphics.TOP | Graphics.LEFT );
				DirectGraphics dg = DirectUtils.getDirectGraphics(g);
				dg.drawImage(this.image, -(c * this.frameWidth), -(r * this.frameHeight), Graphics.TOP | Graphics.LEFT, 0 );
			}
			this.nokiaFrame = frame; 
		//#else
			int numberOfRows = this.rawFrameCount / this.numberOfColumns;
			
			this.column = c;
			this.row = r;
			switch (this.transform ) {
				case TRANS_NONE:
					this.column = c;
					this.row = r;
					break;
				case TRANS_MIRROR_ROT180:
					this.column = c;
					this.row = (numberOfRows-1) - r;
					break;
				case TRANS_MIRROR:
					this.column = (this.numberOfColumns -1) - c;
					this.row = r;
					break;
				case TRANS_ROT180:
					this.column = (this.numberOfColumns -1) - c;
					this.row = (numberOfRows-1) - r;
					break;
				case TRANS_MIRROR_ROT270:
					this.column = c;
					this.row = r;
					break;
				case TRANS_ROT90:
					this.column = (numberOfRows -1) - r;
					this.row = c;
					break;
				case TRANS_ROT270:
					this.column = r;
					this.row = (this.numberOfColumns -1) - c;
					break;
				case TRANS_MIRROR_ROT90:
					this.row = (numberOfRows-1) - r;
					this.row = (this.numberOfColumns -1) - c;
					break;
			}
		//#endif
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Draws the Sprite.
	 * <P>
	 * Draws current frame of Sprite using the provided Graphics object.
	 * The Sprite's upper left corner is rendered at the Sprite's current
	 * position relative to the origin of the Graphics object.  The current
	 * position of the Sprite's upper-left corner can be retrieved by
	 * calling <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getX()"><CODE>Layer.getX()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getY()"><CODE>Layer.getY()</CODE></A>.
	 * <P>
	 * Rendering is subject to the clip region of the Graphics object.
	 * The Sprite will be drawn only if it is visible.
	 * <p>
	 * If the Sprite's Image is mutable, the Sprite is rendered using the
	 * current contents of the Image.
	 * 
	 * @param g the graphics object to draw Sprite on
	 * @throws NullPointerException - if g is null
	 * @see Layer#paint(Graphics) in class Layer
	 */
	public final void paint( Graphics g)
	{
		if (this.isSingleFrame && this.transform == 0) {
			g.drawImage( this.image, this.xPosition, this.yPosition, Graphics.TOP | Graphics.LEFT );
			return;
		}
		//#ifdef polish.api.nokia-ui
			// just draw and rotate the current frame:
			DirectGraphics dg = DirectUtils.getDirectGraphics( g );
			dg.drawImage(this.nokiaFrame, this.xPosition, this.yPosition, Graphics.TOP | Graphics.LEFT, this.nokiaTransform );
			/*
			 * uncomment this code for visualising the reference pixel 
			 * and collision rectangle:
			g.setColor( 0xFFFFFF );
			g.drawLine( this.xPosition + this.transformedCollisionX, this.yPosition + this.transformedCollisionY, this.xPosition + this.transformedCollisionX + this.transformedCollisionWidth, this.yPosition + this.transformedCollisionY  );
			g.drawLine( this.xPosition + this.transformedCollisionX, this.yPosition + this.transformedCollisionY, this.xPosition + this.transformedCollisionX, this.yPosition + this.transformedCollisionY + this.transformedCollisionHeight );
			g.setColor( 0xFF0000 );
			g.drawLine( this.xPosition + this.transformedRefX - 4, this.yPosition + this.transformedRefY, this.xPosition + this.transformedRefX + 4, this.yPosition + this.transformedRefY );
			g.drawLine( this.xPosition + this.transformedRefX, this.yPosition + this.transformedRefY - 4, this.xPosition + this.transformedRefX, this.yPosition + this.transformedRefY + 4 );
			*/
		//#else
			if (this.rawFrameCount == 1) {
				g.drawImage( this.image, this.xPosition, this.yPosition, Graphics.TOP | Graphics.LEFT );							
			} else { 
				// there are several frames contained in the base-image:
				int x = this.xPosition;
				int y = this.yPosition;
				//System.out.print("painting sprite at " + x + ", " + y );
				//save the current clip position:
				int clipX = g.getClipX();
				int clipY = g.getClipY();
				int clipWidth = g.getClipWidth();
				int clipHeight = g.getClipHeight();
				g.clipRect( x, y, this.width, this.height );
				x -= this.column * this.width;
				y -= this.row * this.height;
			
				g.drawImage( this.image, x, y, Graphics.TOP | Graphics.LEFT );			
				
				// reset original clip:
				g.setClip( clipX, clipY, clipWidth, clipHeight );
			}
		//#endif
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Set the frame sequence for this Sprite.
	 * 
	 * All Sprites have a default sequence that displays the Sprites
	 * frames in order.  This method allows for the creation of an
	 * arbitrary sequence using the available frames.  The current
	 * index in the frame sequence is reset to zero as a result of
	 * calling this method.
	 * <p>
	 * The contents of the sequence array are copied when this method
	 * is called; thus, any changes made to the array after this method
	 * returns have no effect on the Sprite's frame sequence.
	 * <P>
	 * Passing in <code>null</code> causes the Sprite to revert to the
	 * default frame sequence.<p>
	 * 
	 * @param sequence an array of integers, where each integer represents a frame index
	 * @throws ArrayIndexOutOfBoundsException if seq is non-null and any member of the array has a value less than 0 or greater than or equal to the number of frames as reported by getRawFrameCount()
	 * @throws IllegalArgumentException if the array has less than 1 element
	 * @see #nextFrame()
	 * @see #prevFrame()
	 * @see #setFrame(int)
	 * @see #getFrame()
	 */
	public void setFrameSequence(int[] sequence)
	{
		int frameIndex = 0;
		this.frameSequence = null;

		if (sequence != null) {
			int[] newSequence = new int[ sequence.length ];
			System.arraycopy( sequence, 0, newSequence, 0, sequence.length );
			this.frameSequence = newSequence;
			frameIndex = this.frameSequence[ 0 ];
		}

		this.frameSequenceIndex = 0;
		this.column = frameIndex % this.numberOfColumns;
		this.row = frameIndex / this.numberOfColumns;
	}
	//#endif

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Changes the Image containing the Sprite's frames.
	 * <p>
	 * Replaces the current raw frames of the Sprite with a new set of raw
	 * frames.  See the constructor <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#Sprite(javax.microedition.lcdui.Image, int, int)"><CODE>Sprite(Image, int, int)</CODE></A> for
	 * information on how the frames are created from the image.  The
	 * values returned by <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getWidth()"><CODE>Layer.getWidth()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getHeight()"><CODE>Layer.getHeight()</CODE></A>
	 * will reflect the new frame width and frame height subject to the
	 * Sprite's current transform.
	 * <p>
	 * Changing the image for the Sprite could change the number of raw
	 * frames.  If the new frame set has as many or more raw frames than the
	 * previous frame set, then:
	 * <ul>
	 * <li>The current frame will be unchanged
	 * <li>If a custom frame sequence has been defined (using
	 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setFrameSequence(int[])"><CODE>setFrameSequence(int[])</CODE></A>), it will remain unchanged.  If no
	 * custom frame sequence is defined (i.e. the default frame
	 * sequence
	 * is in use), the default frame sequence will be updated to
	 * be the default frame sequence for the new frame set.  In other
	 * words, the new default frame sequence will include all of the
	 * frames from the new raw frame set, as if this new image had been
	 * used in the constructor.
	 * </ul>
	 * <p>
	 * If the new frame set has fewer frames than the previous frame set,
	 * then:
	 * <ul>
	 * <li>The current frame will be reset to entry 0
	 * <li>Any custom frame sequence will be discarded and the frame sequence
	 * will revert to the default frame sequence for the new frame
	 * set.
	 * </ul>
	 * <p>
	 * The reference point location is unchanged as a result of calling this
	 * method, both in terms of its defined location within the Sprite and its
	 * position in the painter's coordinate system.  However, if the frame
	 * size is changed and the Sprite has been transformed, the position of
	 * the Sprite's upper-left corner may change such that the reference
	 * point remains stationary.
	 * <p>
	 * If the Sprite's frame size is changed by this method, the collision
	 * rectangle is reset to its default value (i.e. it is set to the new
	 * bounds of the untransformed Sprite).
	 * <p>
	 * 
	 * @param image the Image to use for Sprite
	 * @param frameWidth the width in pixels of the individual raw frames
	 * @param frameHeight the height in pixels of the individual raw frames
	 * @throws NullPointerException if img is null
	 * @throws IllegalArgumentException if frameHeight or frameWidth is less than 1
	 *									or if the image width is not an integer multiple of the frameWidth
	 *									or if the image height is not an integer multiple of the frameHeight
	 */
	public void setImage( Image image, int frameWidth, int frameHeight)
	{
		this.image = image;
		this.frameWidth = frameWidth;
		this.frameHeight = frameHeight;
		this.numberOfColumns = image.getWidth() / frameWidth;
		int rows = image.getHeight() / frameHeight;

		int oldRawFrameCount = this.rawFrameCount;
		this.rawFrameCount = this.numberOfColumns * rows;
		this.isSingleFrame = (this.rawFrameCount == 1);
		if (this.rawFrameCount < oldRawFrameCount) {
			this.frameSequenceIndex = 0;
			// set default frame sequence:
			this.frameSequence = null;
			this.column = 0;
			this.row = 0;
		} else {
			int frameIndex = (this.frameSequence == null) ? this.frameSequenceIndex : this.frameSequence[this.frameSequenceIndex];
			this.column = frameIndex % this.numberOfColumns;
			this.column = frameIndex / this.numberOfColumns;
		}

		this.collisionX = 0;
		this.collisionY = 0;
		this.collisionWidth = frameWidth;
		this.collisionHeight = frameHeight;

		// computes tranformed* values and reposition the sprite.
		int oldRefX = this.transformedRefX, oldRefY = this.transformedRefY;
		applyTransform();
		this.xPosition += oldRefX - this.transformedRefX;
		this.yPosition += oldRefY - this.transformedRefY;

		//#ifdef polish.api.nokia-ui
			if (!this.isSingleFrame) {
				this.nokiaFrame = DirectUtils.createImage( frameWidth, frameHeight, 0x00FFFFFF );
				Graphics g = this.nokiaFrame.getGraphics();
				// when creating an transparent image, one must not "touch"
				// that image with an ordinary Graphics-object --- instead
				// ALWAYS a DirectGraphics-object needs to be used. Sigh!
				//g.drawImage(this.image, 0, 0, Graphics.TOP | Graphics.LEFT );
				DirectGraphics dg = DirectUtils.getDirectGraphics(g);
				dg.drawImage(this.image, 0, 0, Graphics.TOP | Graphics.LEFT, 0 );
			}
			this.nokiaFrames = new Image[ this.rawFrameCount ];
		//#endif
	}
	//#endif

	/**
	 * Defines the Sprite's bounding rectangle that is used for collision
	 * detection purposes.  This rectangle is specified relative to the
	 * un-transformed Sprite's upper-left corner and defines the area that is
	 * checked for collision detection.  For pixel-level detection, only those
	 * pixels within the collision rectangle are checked.
	 * 
	 * By default, a Sprite's collision rectangle is located at 0,0 as has the
	 * same dimensions as the Sprite.  The collision rectangle may be
	 * specified to be larger or smaller than the default rectangle; if made
	 * larger, the pixels outside the bounds of the Sprite are considered to be
	 * transparent for pixel-level collision detection.
	 * 
	 * @param leftX the horizontal location of the collision rectangle relative to the untransformed Sprite's left edge
	 * @param topY the vertical location of the collision rectangle relative to the untransformed Sprite's top edge
	 * @param cWidth the width of the collision rectangle
	 * @param cHeight the height of the collision rectangle
	 * @throws IllegalArgumentException if the specified width or height is less than 0
	 */
	public void defineCollisionRectangle(int leftX, int topY, int cWidth, int cHeight)
	{
		this.collisionX = leftX;
		this.collisionY = topY;
		this.collisionWidth = cWidth;
		this.collisionHeight = cHeight;
		this.applyTransform();
	}

	/*
	 * Applies the current transformation to the collision rectangle and reference pixel.
	 * 
	 * Carefully look at the image in the "Sprite Transforms" section of the doc
	 * and report the number values of the symbols next to each sample image.
	 * We can notive the following:
	 *  - "x = width - x" if transform is 2 or 3
	 *    (that is, (transform & 2) != 0 and (transform & 4) == 0)
	 *  - "y = height - y" if transform is 1 or 3
	 *    (that is, (transform & 1) != 0 and (transform & 4) == 0)
	 *  - width and height are switched if transform >= 4 (that is, (transform & 4) != 0)
	 *  - "x = y" if transform is 4 or 6
	 *    (that is, (transform & 1) == 0 and (transform & 4) != 0)
	 *  - "y = x" if transform is 4 or 5
	 *    (that is, (transform & 2) == 0 and (transform & 4) != 0)
	 *  - "x = height - y" if transform is 5 or 7
	 *    (that is, (transform & 1) != 0 and (transform & 4) != 0)
	 *  - "y = width - x" if transform is 6 or 7
	 *    (that is, (transform & 2) != 0 and (transform & 4) != 0)
	 * 
	 * So:
	 *  - if (transform & 1) == 0, use "y", else use "height - y"
	 *  - if (transform & 2) == 0, use "x", else use "width - x"
	 *  - if (transform & 4) != 0, switch width and height, and x and y
	 *    (after you've applied the previous rules for x and y computation)
	 */
	private void applyTransform() {
		int refX, refY, colX, colY;
		
		// set the horizontal values:
		if ((this.transform & 2) == 0) {
			// Either TRANS_NONE, TRANS_MIRROR_ROT180, TRANS_MIRROR_ROT270 or TRANS_ROT90
			refX = this.refPixelX;
			colX = this.collisionX;
		} else {
			// Either TRANS_MIRROR, TRANS_ROT180, TRANS_ROT270 or TRANS_MIRROR_ROT90
			refX = this.frameWidth - this.refPixelX;
			colX = this.frameWidth - (this.collisionX + this.collisionWidth);
		}
		
		// set the vertical values:
		if ((this.transform & 1) == 0) {
			// Either TRANS_NONE, TRANS_MIRROR, TRANS_MIRROR_ROT270 or TRANS_ROT270
			refY = this.refPixelY;
			colY = this.collisionY;
		} else {
			// Either TRANS_MIRROR_ROT180, TRANS_ROT180, TRANS_ROT90 or TRANS_MIRROR_ROT90
			refY = this.frameHeight - this.refPixelY;
			colY = this.frameHeight - (this.collisionY + this.collisionHeight);
		}

		if ((this.transform & 4) == 0) {
			// Either TRANS_NONE, TRANS_MIRROR_ROT180, TRANS_MIRROR or TRANS_ROT180
			this.width = this.frameWidth;
			this.height = this.frameHeight;
			this.transformedRefX = refX;
			this.transformedRefY = refY;
			this.transformedCollisionX = colX;
			this.transformedCollisionY = colY;
			this.transformedCollisionWidth = this.collisionWidth;
			this.transformedCollisionHeight = this.collisionHeight;
		} else {
			// Either TRANS_MIRROR_ROT270, TRANS_ROT90, TRANS_ROT270 or TRANS_MIRROR_ROT90
			// the vertical and horizontal values needs to be switched:
			this.width = this.frameHeight;
			this.height = this.frameWidth;
			this.transformedRefX = refY;
			this.transformedRefY = refX;
			this.transformedCollisionX = colY;
			this.transformedCollisionY = colX;
			this.transformedCollisionWidth = this.collisionHeight;
			this.transformedCollisionHeight = this.collisionWidth;
		}
	}

	/**
	 * Sets the transform for this Sprite.  Transforms can be
	 * applied to a Sprite to change its rendered appearance.  Transforms
	 * are applied to the original Sprite image; they are not cumulative,
	 * nor can they be combined.  By default, a Sprite's transform is
	 * <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#TRANS_NONE"><CODE>TRANS_NONE</CODE></A>.
	 * <P>
	 * Since some transforms involve rotations of 90 or 270 degrees, their
	 * use may result in the overall width and height of the Sprite
	 * being swapped.  As a result, the values returned by
	 * <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getWidth()"><CODE>Layer.getWidth()</CODE></A> 
	 * and <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getHeight()"><CODE>Layer.getHeight()</CODE></A> may change.
	 * <p>
	 * The collision rectangle is also modified by the transform so that
	 * it remains static relative to the pixel data of the Sprite.
	 * Similarly, the defined reference pixel is unchanged by this method,
	 * but its visual location within the Sprite may change as a result.
	 * <P>
	 * This method repositions the Sprite so that the location of
	 * the reference pixel in the painter's coordinate system does not change
	 * as a result of changing the transform.  Thus, the reference pixel
	 * effectively becomes the centerpoint for the transform.  Consequently,
	 * the values returned by <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#getRefPixelX()"><CODE>getRefPixelX()</CODE></A> 
	 * and <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#getRefPixelY()"><CODE>getRefPixelY()</CODE></A>
	 * will be the same both before and after the transform is applied, but
	 * the values returned by <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getX()"><CODE>getX()</CODE></A> 
	 * and <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getY()"><CODE>getY()</CODE></A>
	 * may change.
	 * <p>
	 * 
	 * @param transform the desired transform for this Sprite
	 * @throws IllegalArgumentException if the requested transform is invalid
	 * @see #TRANS_NONE
	 * @see #TRANS_ROT90
	 * @see #TRANS_ROT180
	 * @see #TRANS_ROT270
	 * @see #TRANS_MIRROR
	 * @see #TRANS_MIRROR_ROT90
	 * @see #TRANS_MIRROR_ROT180
	 * @see #TRANS_MIRROR_ROT270
	 */
	public void setTransform(int transform)
	{
		this.transform = transform;

		// computes tranformed* values and reposition the sprite.
		int oldRefX = this.transformedRefX, oldRefY = this.transformedRefY;
		applyTransform();
		this.xPosition += oldRefX - this.transformedRefX;
		this.yPosition += oldRefY - this.transformedRefY;
	
		//#ifndef polish.api.siemens-color-game-api
			//#ifndef polish.api.nokia-ui
				// when the nokia-ui is used the frame-dimensions do not need to be changed:
				if (this.rawFrameCount > 1) {
					updateFrame();
				}
			//#endif
		//#endif
		//#if polish.api.nokia-ui && !polish.api.siemens-color-game-api
			this.nokiaTransform = NOKIA_TRANSFORM_LOOKUP[transform];
			if (this.isSingleFrame) {
				updateFrame();
			}
		//#endif
	}

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Checks for a collision between this Sprite and the specified Sprite.
	 * <p>
	 * The J2ME Polish implementation for MIDP/1.0 devices currently does
	 * not support a pixel-level detection. Instead only the defined
	 * collision rectangles are used. 
	 * </p>
	 * <P>
	 * If pixel-level detection is used, a collision is detected only if
	 * opaque pixels collide.  That is, an opaque pixel in the first
	 * Sprite would have to collide with an opaque  pixel in the second
	 * Sprite for a collision to be detected.  Only those pixels within
	 * the Sprites' respective collision rectangles are checked.
	 * </P>
	 * <P>
	 * If pixel-level detection is not used, this method simply
	 * checks if the Sprites' collision rectangles intersect.
	 * </P>
	 * <P>
	 * Any transforms applied to the Sprites are automatically accounted for.
	 * <P>
	 * Both Sprites must be visible in order for a collision to be
	 * detected.
	 * </P>
	 * 
	 * @param s the Sprite to test for collision with
	 * @param pixelLevel true to test for collision on a pixel-by-pixel basis, false to test using simple bounds checking.
	 * 	      The J2ME Polish implementation does not support the pixel-level collision detection.
	 * @return true if the two Sprites have collided, otherwise false
	 * @throws NullPointerException if Sprite s is null
	 */
	public final boolean collidesWith( Sprite s, boolean pixelLevel)
	{
		if (!(this.isVisible && s.isVisible)) {
			return false;
		}
		int enemyX = s.xPosition + s.transformedCollisionX;
		int enemyY = s.yPosition + s.transformedCollisionY; 
		return collidesWith( enemyX, enemyY,
				s.transformedCollisionWidth,
				s.transformedCollisionHeight
				);
	}
	//#endif

	/**
	 * Checks for a collision between this Sprite and the specified TiledLayer.  
	 * 
	 * If pixel-level detection is used, a collision is
	 * detected only if opaque pixels collide.  That is, an opaque pixel in
	 * the Sprite would have to collide with an opaque pixel in TiledLayer
	 * for a collision to be detected.  Only those pixels within the Sprite's
	 * collision rectangle are checked.
	 * <P>
	 * If pixel-level detection is not used, this method simply checks if the
	 * Sprite's collision rectangle intersects with a non-empty cell in the
	 * TiledLayer.
	 * <P>
	 * Any transform applied to the Sprite is automatically accounted for.
	 * <P>
	 * The Sprite and the TiledLayer must both be visible in order for
	 * a collision to be detected.
	 * <P>
	 * 
	 * @param t the TiledLayer to test for collision with
	 * @param pixelLevel true to test for collision on a pixel-by-pixel basis, false to test using simple bounds checking against non-empty cells.
	 * 	      The J2ME Polish implementation does not support the pixel-level collision detection.
	 * @return true if this Sprite has collided with the TiledLayer, otherwise false
	 * @throws NullPointerException - if t is null
	 */
	public final boolean collidesWith( TiledLayer t, boolean pixelLevel)
	{
		//#ifdef polish.api.siemens-color-game-api
			if (!(this.isVisible && t.isVisible())) {
				return false;
			}
			//# int tileWidth = t.getCellWidth();
			//# int tileHeight = t.getCellHeight();
		//#else
			if (!(this.isVisible && t.isVisible)) {
				return false;
			}
			int tileWidth = t.cellWidth;
			int tileHeight = t.cellHeight;
		//#endif
		int cXStart = this.xPosition + this.transformedCollisionX;
		int cXEnd = cXStart + this.transformedCollisionWidth;
		int cYStart = this.yPosition + this.transformedCollisionY;
		int cYEnd = cYStart + this.transformedCollisionHeight;
		int x = cXStart;
		int y = cYStart;
		//#ifdef polish.api.siemens-color-game-api
			if (!(this.isVisible && t.isVisible())) {
				return false;
			}
			int tileX = t.getX();
			int firstColumn = (cXStart - tileX) / tileWidth;
			if (firstColumn < 0) {
				x -= (firstColumn * tileWidth);
				firstColumn = 0;
			}
			int tileY = t.getY();
			int firstRow = (cYStart - tileY) / tileHeight;
			if (firstRow < 0) {
				y -= (firstRow * tileHeight );
				firstRow = 0;
			}
			int tileRow = firstRow;
			int tileColumn = firstColumn;
			while (x <= cXEnd) {
				while (y <= cYEnd) {
					int tile = t.getCell(tileColumn, tileRow);
					if (tile != 0) {
						return true;
					}
					y += tileHeight;
					tileRow++;
				}
				y = cYStart;
				tileRow = firstRow;
				x += tileWidth;
				tileColumn++;
			}
			//# return false;
		//#else			
			while (x <= cXEnd) {
				while (y <= cYEnd) {
					int tile = t.getTileAt(x, y);
					if (tile != 0) {
						return true;
					}
					y += tileHeight;
				}
				y = cYStart;
				x += tileWidth;
			}
			return false;
		//#endif
	}

	//#ifndef polish.api.siemens-color-game-api
	/**
	 * Checks for a collision between this Sprite and the specified Image
	 * with its upper left corner at the specified location.  If pixel-level
	 * detection is used, a collision is detected only if opaque pixels
	 * collide.  That is, an opaque pixel in the Sprite would have to collide
	 * with an opaque  pixel in Image for a collision to be detected.  Only
	 * those pixels within the Sprite's collision rectangle are checked.
	 * <P>
	 * If pixel-level detection is not used, this method simply checks if the
	 * Sprite's collision rectangle intersects with the Image's bounds.
	 * <P>
	 * Any transform applied to the Sprite is automatically accounted for.
	 * <P>
	 * The Sprite must be visible in order for a collision to be
	 * detected.
	 * <P>
	 * The J2ME Polish implementation does not support the pixel-level collision detection.
	 * 
	 * @param img the Image to test for collision
	 * @param leftX the horizontal location of the Image's upper left corner
	 * @param topY the vertical location of the Image's upper left corner
	 * @param pixelLevel true to test for collision on a pixel-by-pixel basis, false to test using simple bounds checking;
	 * 	      The J2ME Polish implementation does not support the pixel-level collision detection.
	 * @return true if this Sprite has collided with the Image, otherwise false
	 * @throws NullPointerException if image is null
	 */
	public final boolean collidesWith( Image img, int leftX, int topY, boolean pixelLevel)
	{
		return collidesWith( leftX, topY, img.getWidth(), img.getHeight() );
	}
	//#endif
	
	private boolean collidesWith( int enemyX, int enemyY, int enemyWidth, int enemyHeight ) {
		int cXStart = this.xPosition + this.transformedCollisionX;
		int cXEnd = cXStart + this.transformedCollisionWidth;
		int cYStart = this.yPosition + this.transformedCollisionY;
		int cYEnd = cYStart + this.transformedCollisionHeight;
		/*
		System.out.println("Sprite-Collision: this(" + cXStart + "," + cYStart + ", " + cXEnd + ", " + cYEnd + ")" );
		System.out.println("Sprite-Collision: real(" + this.xPosition + "," + this.yPosition + ")" );
		System.out.println("Sprite-Collision: enem(" + enemyX + "," + enemyY + ", " + (enemyX + enemyWidth) + ", " + (enemyY + enemyHeight) + ")" );
		*/
		if (cYEnd <= enemyY
				|| cYStart >= enemyY + enemyHeight
				|| cXEnd <= enemyX
				|| cXStart >= enemyX + enemyWidth ) 
		{
			return false;
		}
		return true;
	}

}
