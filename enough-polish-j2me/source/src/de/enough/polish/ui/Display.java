//#condition polish.usePolishGui


// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sun Feb 29 19:10:57 CET 2004
package de.enough.polish.ui;


import javax.microedition.lcdui.Font;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;
import javax.microedition.lcdui.game.Sprite;
import javax.microedition.midlet.MIDlet;

//#if polish.BlackBerry
	//#if polish.JavaPlatform >= BlackBerry/6.0
		import net.rim.device.api.system.Sensor;
	//#endif
	import net.rim.device.api.ui.Keypad;
//#endif

import de.enough.polish.event.EventManager;
import de.enough.polish.util.ArrayList;
import de.enough.polish.util.DeviceInfo;
import de.enough.polish.util.ImageUtil;
//#if polish.api.sensor && polish.Screen.AutomaticOrientationChange && polish.midp2
	//#define tmp.automaticScreenOrientation
	import de.enough.polish.util.sensor.AccelerationListener;
	import de.enough.polish.util.sensor.AccelerationUtil;
//#endif


/**
 * <code>Display</code> represents the manager of the display and
 * input devices of the system. It includes methods for retrieving properties of the device and
 * for requesting that objects be displayed on the device. Other methods that
 * deal with device attributes are primarily used with <A HREF="../../../javax/microedition/lcdui/Canvas.html"><CODE>Canvas</CODE></A>
 * objects and are thus defined there instead of here. <p>
 * 
 * There is exactly one instance of Display per <A HREF="../../../javax/microedition/midlet/MIDlet.html"><CODE>MIDlet</CODE></A> and the application can get a
 * reference to that instance by calling the <A HREF="../../../javax/microedition/lcdui/Display.html#getDisplay(javax.microedition.midlet.MIDlet)"><CODE>getDisplay()</CODE></A> method. The
 * application may call the <code>getDisplay()</code> method at any time
 * during course of
 * its execution. The <code>Display</code> object
 * returned by all calls to <code>getDisplay()</code> will remain the
 * same during this
 * time. <p>
 * 
 * A typical application will perform the following actions in response to
 * calls to its <code>MIDlet</code> methods:
 * <UL>
 * <LI><STRONG>startApp</STRONG> - the application is moving from the
 * paused state to the active state.
 * Initialization of objects needed while the application is active should be
 * done.  The application may call
 * <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent()</CODE></A> for the first screen if that
 * has not already been done. Note that <code>startApp()</code> can be
 * called several
 * times if <code>pauseApp()</code> has been called in between. This
 * means that one-time
 * initialization
 * should not take place here but instead should occur within the
 * <code>MIDlet's</code>
 * constructor.
 * </LI>
 * <LI><STRONG>pauseApp</STRONG> - the application may pause its threads.
 * Also, if it is
 * desirable to start with another screen when the application is re-activated,
 * the new screen should be set with <code>setCurrent()</code>.</LI>
 * <LI><STRONG>destroyApp</STRONG> - the application should free resources,
 * terminate threads, etc.
 * The behavior of method calls on user interface objects after
 * <code>destroyApp()</code> has returned is undefined. </li>
 * </UL>
 * <p>
 * 
 * <P>The user interface objects that are shown on the display device are
 * contained within a <A HREF="../../../javax/microedition/lcdui/Displayable.html"><CODE>Displayable</CODE></A> object. At any time the
 * application may have at most one <code>Displayable</code> object
 * that it intends to be
 * shown on the display device and through which user interaction occurs.  This
 * <code>Displayable</code> is referred to as the <em>current</em>
 * <code>Displayable</code>. </p>
 * 
 * <P>The <code>Display</code> class has a <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent()</CODE></A>
 * method for setting the current <code>Displayable</code> and a
 * <A HREF="../../../javax/microedition/lcdui/Display.html#getCurrent()"><CODE>getCurrent()</CODE></A> method for retrieving the current
 * <code>Displayable</code>.  The
 * application has control over its current <code>Displayable</code>
 * and may call
 * <code>setCurrent()</code> at any time.  Typically, the application
 * will change the
 * current <code>Displayable</code> in response to some user action.
 * This is not always the
 * case, however.  Another thread may change the current
 * <code>Displayable</code> in
 * response to some other stimulus.  The current
 * <code>Displayable</code> will also be
 * changed when the timer for an <A HREF="../../../javax/microedition/lcdui/Alert.html"><CODE>Alert</CODE></A> elapses. </P>
 * 
 * <p> The application's current <code>Displayable</code> may not
 * physically be drawn on the
 * screen, nor will user events (such as keystrokes) that occur necessarily be
 * directed to the current <code>Displayable</code>.  This may occur
 * because of the presence
 * of other <code>MIDlet</code> applications running simultaneously on
 * the same device. </p>
 * 
 * <P>An application is said to be in the <em>foreground</em> if its current
 * <code>Displayable</code> is actually visible on the display device
 * and if user input
 * device events will be delivered to it. If the application is not in the
 * foreground, it lacks access to both the display and input devices, and it is
 * said to be in the <em>background</em>. The policy for allocation of these
 * devices to different <code>MIDlet</code> applications is outside
 * the scope of this
 * specification and is under the control of an external agent referred to as
 * the <em>application management software</em>. </p>
 * 
 * <P>As mentioned above, the application still has a notion of its current
 * <code>Displayable</code> even if it is in the background. The
 * current <code>Displayable</code> is
 * significant, even for background applications, because the current
 * <code>Displayable</code> is always the one that will be shown the
 * next time the
 * application is brought into the foreground.  The application can determine
 * whether a <code>Displayable</code> is actually visible on the
 * display by calling <A HREF="../../../javax/microedition/lcdui/Displayable.html#isShown()"><CODE>isShown()</CODE></A>. In the case of <code>Canvas</code>,
 * the <A HREF="../../../javax/microedition/lcdui/Canvas.html#showNotify()"><CODE>showNotify()</CODE></A> and <A HREF="../../../javax/microedition/lcdui/Canvas.html#hideNotify()"><CODE>hideNotify()</CODE></A> methods are called when the <code>Canvas</code> is
 * made visible and is
 * hidden, respectively.</P>
 * 
 * <P> Each <code>MIDlet</code> application has its own current
 * <code>Displayable</code>.  This means
 * that the <A HREF="../../../javax/microedition/lcdui/Display.html#getCurrent()"><CODE>getCurrent()</CODE></A> method returns the
 * <code>MIDlet's</code>
 * current <code>Displayable</code>, regardless of the
 * <code>MIDlet's</code> foreground/background
 * state.  For example, suppose a <code>MIDlet</code> running in the
 * foreground has current
 * <code>Displayable</code> <em>F</em>, and a <code>MIDlet</code>
 * running in the background has current
 * <code>Displayable</code> <em>B</em>.  When the foreground
 * <code>MIDlet</code> calls <code>getCurrent()</code>, it
 * will return <em>F</em>, and when the background <code>MIDlet</code>
 * calls <code>getCurrent()</code>, it
 * will return <em>B</em>.  Furthermore, if either <code>MIDlet</code>
 * changes its current
 * <code>Displayable</code> by calling <code>setCurrent()</code>, this
 * will not affect the any other
 * <code>MIDlet's</code> current <code>Displayable</code>. </p>
 * 
 * <P>It is possible for <code>getCurrent()</code> to return
 * <code>null</code>. This may occur at startup
 * time, before the <code>MIDlet</code> application has called
 * <code>setCurrent()</code> on its first
 * screen.  The <code>getCurrent(</code>) method will never return a
 * reference to a
 * <code>Displayable</code> object that was not passed in a prior call
 * to <code>setCurrent()</code> call
 * by this <code>MIDlet</code>. </p>
 * 
 * <a name="systemscreens"></a>
 * <h3>System Screens</h3>
 * 
 * <P> Typically, the
 * current screen of the foreground <code>MIDlet</code> will be
 * visible on the display.
 * However, under certain circumstances, the system may create a screen that
 * temporarily obscures the application's current screen.  These screens are
 * referred to as <em>system screens.</em> This may occur if the system needs
 * to show a menu of commands or if the system requires the user to edit text
 * on a separate screen instead of within a text field inside a
 * <code>Form</code>.  Even
 * though the system screen obscures the application's screen, the notion of
 * the current screen does not change.  In particular, while a system screen is
 * visible, a call to <code>getCurrent()</code> will return the
 * application's current
 * screen, not the system screen.  The value returned by
 * <code>isShown()</code> is <code>false</code>
 * while the current <code>Displayable</code> is obscured by a system
 * screen. </p>
 * 
 * <p> If system screen obscures a canvas, its
 * <code>hideNotify()</code> method is called.
 * When the system screen is removed, restoring the canvas, its
 * <code>showNotify()</code>
 * method and then its <code>paint()</code> method are called.  If the
 * system screen was used
 * by the user to issue a command, the <code>commandAction()</code>
 * method is called after
 * <code>showNotify()</code> is called. </p>
 * 
 * <p>This class contains methods to retrieve the prevailing foreground and
 * background colors of the high-level user interface.  These methods are
 * useful for creating <CODE>CustomItem</CODE> objects that match the user
 * interface of other items and for creating user interfaces within
 * <CODE>Canvas</CODE> that match the user interface of the rest of the
 * system.  Implementations are not restricted to using foreground and
 * background colors in their user interfaces (for example, they might use
 * highlight and shadow colors for a beveling effect) but the colors returned
 * are those that match reasonably well with the implementation's color
 * scheme.  An application implementing a custom item should use the
 * background color to clear its region and then paint text and geometric
 * graphics (lines, arcs, rectangles) in the foreground color.</p>
 * <HR>
 * 
 * 
 * @since MIDP 1.0
 */
public class Display
//#if polish.Display.baseclass:defined
	//#if polish.useFullScreen
		//#define tmp.fullScreen
	//#endif
	//#= extends ${polish.Display.baseclass}
//#elif polish.useFullScreen && (polish.midp2 && !polish.Bugs.needsNokiaUiForSystemAlerts)  && (!polish.useMenuFullScreen || polish.hasCommandKeyEvents)
	//#define tmp.fullScreen
	//#define tmp.useCanvasFullScreen
	//# extends javax.microedition.lcdui.Canvas
//#elif polish.useFullScreen && polish.classes.fullscreen:defined
	//#define tmp.fullScreen
	//#= extends ${polish.classes.fullscreen}
//#elif polish.useFullScreen && polish.build.classes.fullscreen:defined
	//#define tmp.fullScreen
	//#= extends ${polish.build.classes.fullscreen}
//#elif polish.build.classes.screen:defined
	//#= extends ${polish.build.classes.screen}
//#else
	extends javax.microedition.lcdui.Canvas
//#endif
//#if polish.android
	//# implements de.enough.polish.ui.CommandListener
//#elif polish.midp
	implements javax.microedition.lcdui.CommandListener
//#endif
//#if ${polish.license} == GPL
	//#define tmp.displayInfo
	, Runnable
//#endif
	
//#if polish.css.screen-transition || polish.css.screen-change-animation || polish.ScreenChangeAnimation.forward:defined
	//#define tmp.screenTransitions
//#endif
{
	/**
	 * Image type for <code>List</code> element image.
	 * 
	 * <P>The value of <code>LIST_ELEMENT</code> is <code>1</code>.</P>
	 * <DT><B>See Also: </B>
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageHeight(int)"><CODE>getBestImageHeight(int imageType)</CODE></A>
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LIST_ELEMENT = 1;

	/**
	 * Image type for <code>ChoiceGroup</code> element image.
	 * 
	 * <P>The value of <code>CHOICE_GROUP_ELEMENT</code> is <code>2</code>.</P>
	 * <DT><B>See Also: </B>
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageHeight(int)"><CODE>getBestImageHeight(int imageType)</CODE></A>
	 * 
	 * @since MIDP 2.0
	 */
	public static final int CHOICE_GROUP_ELEMENT = 2;

	/**
	 * Image type for <code>Alert</code> image.
	 * 
	 * <P>The value of <code>ALERT</code> is <code>3</code>.</P>
	 * <DT><B>See Also: </B>
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#getBestImageHeight(int)"><CODE>getBestImageHeight(int imageType)</CODE></A>
	 * 
	 * @since MIDP 2.0
	 */
	public static final int ALERT = 3;

	/**
	 * A color specifier for use with <code>getColor</code>.
	 * <code>COLOR_BACKGROUND</code> specifies the background color of
	 * the screen.
	 * The background color will always contrast with the foreground color.
	 * 
	 * <p>
	 * <code>COLOR_BACKGROUND</code> has the value <code>0</code>.
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int COLOR_BACKGROUND = 0;

	/**
	 * A color specifier for use with <code>getColor</code>.
	 * <code>COLOR_FOREGROUND</code> specifies the foreground color,
	 * for text characters
	 * and simple graphics on the screen.  Static text or user-editable
	 * text should be drawn with the foreground color.  The foreground color
	 * will always constrast with background color.
	 * 
	 * <p> <code>COLOR_FOREGROUND</code> has the value <code>1</code>.
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int COLOR_FOREGROUND = 1;

	/**
	 * A color specifier for use with <code>getColor</code>.
	 * <code>COLOR_HIGHLIGHTED_BACKGROUND</code> identifies the color for the
	 * focus, or focus highlight, when it is drawn as a
	 * filled in rectangle. The highlighted
	 * background will always constrast with the highlighted foreground.
	 * 
	 * <p>
	 * <code>COLOR_HIGHLIGHTED_BACKGROUND</code> has the value <code>2</code>.
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int COLOR_HIGHLIGHTED_BACKGROUND = 2;

	/**
	 * A color specifier for use with <code>getColor</code>.
	 * <code>COLOR_HIGHLIGHTED_FOREGROUND</code> identifies the color for text
	 * characters and simple graphics when they are highlighted.
	 * Highlighted
	 * foreground is the color to be used to draw the highlighted text
	 * and graphics against the highlighted background.
	 * The highlighted foreground will always constrast with
	 * the highlighted background.
	 * 
	 * <p>
	 * <code>COLOR_HIGHLIGHTED_FOREGROUND</code> has the value <code>3</code>.
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int COLOR_HIGHLIGHTED_FOREGROUND = 3;

	/**
	 * A color specifier for use with <code>getColor</code>.
	 * <code>COLOR_BORDER</code> identifies the color for boxes and borders
	 * when the object is to be drawn in a
	 * non-highlighted state.  The border color is intended to be used with
	 * the background color and will contrast with it.
	 * The application should draw its borders using the stroke style returned
	 * by <code>getBorderStyle()</code>.
	 * 
	 * <p> <code>COLOR_BORDER</code> has the value <code>4</code>.
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int COLOR_BORDER = 4;

	/**
	 * A color specifier for use with <code>getColor</code>.
	 * <code>COLOR_HIGHLIGHTED_BORDER</code>
	 * identifies the color for boxes and borders when the object is to be
	 * drawn in a highlighted state.  The highlighted border color is intended
	 * to be used with the background color (not the highlighted background
	 * color) and will contrast with it.  The application should draw its
	 * borders using the stroke style returned <code>by getBorderStyle()</code>.
	 * 
	 * <p> <code>COLOR_HIGHLIGHTED_BORDER</code> has the value <code>5</code>.
	 * 
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int COLOR_HIGHLIGHTED_BORDER = 5;
	
	///////////////////////////// Canvas Constants For Non-MIDP Platforms ///////////////////
	//#if !polish.midp || polish.blackberry
    /**
     * Constant for the <code>UP</code> game action.
     * 
     * <P>Constant value <code>1</code> is set to <code>UP</code>.</P>
     * 
     */
    public static final int UP = 1;

    /**
     * Constant for the <code>DOWN</code> game action.
     * 
     * <P>Constant value <code>6</code> is set to <code>DOWN</code>.</P>
     * 
     */
    public static final int DOWN = 6;

    /**
     * Constant for the <code>LEFT</code> game action.
     * 
     * <P>Constant value <code>2</code> is set to <code>LEFT</code>.</P>
     * 
     */
    public static final int LEFT = 2;

    /**
     * Constant for the <code>RIGHT</code> game action.
     * 
     * <P>Constant value <code>5</code> is set to <code>RIGHT</code>.</P>
     * 
     */
    public static final int RIGHT = 5;

    /**
     * Constant for the <code>FIRE</code> game action.
     * 
     * <P>Constant value <code>8</code> is set to <code>FIRE</code>.</P>
     * 
     */
    public static final int FIRE = 8;

    /**
     * Constant for the general purpose &quot;<code>A</code>&quot; game action.
     * 
     * <P>Constant value <code>9</code> is set to <code>GAME_A</code>.</P>
     * 
     */
    public static final int GAME_A = 9;

    /**
     * Constant for the general purpose &quot;<code>B</code>&quot; game action.
     * 
     * <P>Constant value <code>10</code> is set to <code>GAME_B</code>.</P>
     * 
     */
    public static final int GAME_B = 10;

    /**
     * Constant for the general purpose &quot;<code>C</code>&quot; game action.
     * 
     * <P>Constant value <code>11</code> is set to <code>GAME_C</code>.</P>
     * 
     */
    public static final int GAME_C = 11;

    /**
     * Constant for the general purpose &quot;<code>D</code>&quot; game action.
     * 
     * <P>Constant value <code>12</code> is set to <code>GAME_D</code>.</P>
     * 
     */
    public static final int GAME_D = 12;

    /**
     * keyCode for ITU-T key <code>0</code>.
     * 
     * <P>Constant value <code>48</code> is set to <code>KEY_NUM0</code>.</P>
     * 
     */
    public static final int KEY_NUM0 = 48;

    /**
     * keyCode for ITU-T key <code>1</code>.
     * 
     * <P>Constant value <code>49</code> is set to <code>KEY_NUM1</code>.</P>
     * 
     */
    public static final int KEY_NUM1 = 49;

    /**
     * keyCode for ITU-T key <code>2</code>.
     * 
     * <P>Constant value <code>50</code> is set to <code>KEY_NUM2</code>.</P>
     * 
     */
    public static final int KEY_NUM2 = 50;

    /**
     * keyCode for ITU-T key <code>3</code>.
     * 
     * <P>Constant value <code>51</code> is set to <code>KEY_NUM3</code>.</P>
     * 
     */
    public static final int KEY_NUM3 = 51;

    /**
     * keyCode for ITU-T key <code>4</code>.
     * 
     * <P>Constant value <code>52</code> is set to <code>KEY_NUM4</code>.</P>
     * 
     */
    public static final int KEY_NUM4 = 52;

    /**
     * keyCode for ITU-T key <code>5</code>.
     * 
     * <P>Constant value <code>53</code> is set to <code>KEY_NUM5</code>.</P>
     * 
     */
    public static final int KEY_NUM5 = 53;

    /**
     * keyCode for ITU-T key <code>6</code>.
     * 
     * <P>Constant value <code>54</code> is set to <code>KEY_NUM6</code>.</P>
     * 
     */
    public static final int KEY_NUM6 = 54;

    /**
     * keyCode for ITU-T key <code>7</code>.
     * 
     * <P>Constant value <code>55</code> is set to <code>KEY_NUM7</code>.</P>
     * 
     */
    public static final int KEY_NUM7 = 55;

    /**
     * keyCode for ITU-T key <code>8</code>.
     * 
     * <P>Constant value <code>56</code> is set to <code>KEY_NUM8</code>.</P>
     * 
     */
    public static final int KEY_NUM8 = 56;

    /**
     * keyCode for ITU-T key <code>9</code>.
     * 
     * <P>Constant value <code>57</code> is set to <code>KEY_NUM09</code>.</P>
     * 
     */
    public static final int KEY_NUM9 = 57;

    /**
     * keyCode for ITU-T key &quot;star&quot; (<code>*</code>).
     * 
     * <P>Constant value <code>42</code> is set to <code>KEY_STAR</code>.</P>
     * 
     */
    public static final int KEY_STAR = 42;

    /**
     * keyCode for ITU-T key &quot;pound&quot; (<code>#</code>).
     * 
     * <P>Constant value <code>35</code> is set to <code>KEY_POUND</code>.</P>
     * 
     * 
     */
    public static final int KEY_POUND = 35;
    //#endif
    
    /**
     * the input method identifier for touch
     */
    public static final int INPUT_METHOD_TOUCH = 0;
    
    /**
     * the input method identifier for keys
     */
    public static final int INPUT_METHOD_KEY= 1;
    
	private static Display instance;
	
	protected Displayable currentDisplayable;
	protected Canvas currentCanvas;
	protected MIDlet midlet;
	//#if polish.build.classes.NativeDisplay:defined
		//#= private ${polish.build.classes.NativeDisplay} nativeDisplay;
	//#else
		private NativeDisplay nativeDisplay;
	//#endif

	//#if polish.RemoteBluetoothScreen && polish.api.btapi
		//#define tmp.remoteScreen
		//#define polish.Screen.ManualOrientationChange
		private final RemoteScreen remoteScreen;
	//#endif
	//#if polish.midp2 && (polish.ScreenOrientationCanChangeManually || polish.Screen.ManualOrientationChange || tmp.automaticScreenOrientation)
		//#define tmp.screenOrientation
		private static int staticScreenOrientationDegrees;
		private int screenOrientationDegrees;
		private int originalScreenWidth;
		private int originalScreenHeight;
		private Image screenOrientationBuffer;
	//#endif
	private int screenWidth;
	private int screenHeight;
	//#if polish.Bugs.noSoftKeyReleasedEvents
		private boolean isIgnoreReleasedEvent;
	//#endif
	//#if polish.ScreenChangeAnimation.forward:defined
		//#if false
			private static ScreenChangeAnimation forwardAnimation;
			private static ScreenChangeAnimation backwardAnimation;			
		//#endif
		//#= private static ScreenChangeAnimation forwardAnimation = ${polish.ScreenChangeAnimation.forward};
		//#if polish.ScreenChangeAnimation.back:defined
			//#= private static ScreenChangeAnimation backwardAnimation = ${polish.ScreenChangeAnimation.back};
		//#elif polish.ScreenChangeAnimation.backward:defined
			//#= private static ScreenChangeAnimation backwardAnimation = ${polish.ScreenChangeAnimation.backward};
		//#else
			//#abort You need to define the polish.ScreenChangeAnimation.backward screen change animation as well, when you define the forward animation!
		//#endif
	//#endif
	//#if tmp.screenOrientation && polish.hasPointerEvents
		private final Point pointerEventPoint;
	//#endif
	protected boolean enableScreenChangeAnimations = true;
	//#if tmp.displayInfo
		private boolean showInfo;
		private int currentInfoColor;
		private Displayable infoNextDisplayable;
		private long infoStartTime;
	//#endif
	//#if polish.Display.idleEvent
		private Idle idle;
	//#endif

	//#if polish.log.display || polish.Display.supportLayers 
		//#define tmp.layer
		private ArrayList layers;
	//#endif
	//#if polish.Bugs.keyRepeatOverload && polish.midp
		//#define tmp.keyRepeatOverload
		//#define tmp.wrapperScreen
		private int keyRepeatCurrentKeyCode;
		private int keyRepeatBugCounter;
		private boolean keyRepeatBugCounterResetDone;
	//#endif
	//#if polish.Bugs.SnapshotRequiresScreenChange && polish.midp
		//TODO: not every application uses snapshot functionality... how can this be detected, if this extra code is really required?
		//#define tmp.wrapperScreen
	//#endif
	//#if tmp.wrapperScreen
		private boolean ignoreShowHide;
	//#endif
	private CommandListener commandListener;
	protected int nonFullScreenHeight;
	//#if polish.blackberry && polish.hasPointerEvents
		private int bbMaxScreenHeight;
		private int bbMinScreenHeight = Integer.MAX_VALUE;
	//#endif
		
    private int inputMethod = 
    	//#if polish.hasPointerEvents
	    	INPUT_METHOD_TOUCH;
	    //#else
    		//# INPUT_METHOD_KEY;
    	//#endif

	private boolean emitNotifyOnUserEvent;
	//#if !polish.blackberry
		protected boolean isLastEventProcessed;
	//#endif
	private Displayable nextOrCurrentDisplayable;

	private boolean hasBeenShown;
		
	//#if polish.build.classes.NativeDisplay:defined
		//#= protected Display( MIDlet midlet, ${polish.build.classes.NativeDisplay} nativeDisplay ) {
	//#else
		protected Display( MIDlet midlet, NativeDisplay nativeDisplay ) {
	//#endif
		this.midlet = midlet;
		this.nativeDisplay = nativeDisplay;
		this.nonFullScreenHeight = super.getHeight();
		//#if tmp.useCanvasFullScreen
			// calling setFullScreenMode(true) in showNotify() is not sufficient for some
			// Samsung devices, e.g. the SGH-U600
			super.setFullScreenMode(true);
		//#endif
		//#if tmp.screenOrientation && polish.hasPointerEvents
			this.pointerEventPoint = new Point();
		//#endif
		//#if tmp.automaticScreenOrientation
			ScreenOrientationDetector detector = new ScreenOrientationDetector();
			AccelerationUtil.addAccelerationListener(detector);
		//#endif
		
		//#if polish.Display.idleEvent
			this.idle = new Idle();
		//#endif
		//#if polish.RemoteBluetoothScreen && polish.api.btapi
			this.remoteScreen = new de.enough.polish.ui.remotescreen.BluetoothRemoteScreen();
		//#endif
	}

	/**
	 * Gets the <code>Display</code> object that is unique to this
	 * <code>MIDlet</code>.
	 * 
	 * @param m - MIDlet of the application
	 * @return the display object that application can use for its user interface
	 * @throws NullPointerException - if m is null
	 */
	public static Display getDisplay( MIDlet m)
	{
		if (instance == null) {
			//#if polish.build.classes.NativeDisplay:defined
				//#= ${polish.build.classes.NativeDisplay} nativeDisplay = ${polish.build.classes.NativeDisplay}.getDisplay(m);
			//#elif polish.midp
				NativeDisplay nativeDisplay = de.enough.polish.midp.ui.NativeDisplayImpl.getDisplay(m);
			//#endif
			instance = new Display( m, nativeDisplay );
			// for backward compatibility:
			StyleSheet.midlet = m;
			StyleSheet.display = instance;
			//#if tmp.screenOrientation
				instance.setScreenOrientationImpl(staticScreenOrientationDegrees);
			//#endif
			//#if tmp.displayInfo
				instance.showInfo = true;
				instance.infoStartTime = System.currentTimeMillis();
				instance.nativeDisplay.setCurrent(instance);
			//#endif
			//#if !tmp.fullScreen && polish.midp && !polish.blackberry
				instance.setCommandListener( instance );
			//#endif
		}
		return instance;
	}

	/**
	 * Returns one of the colors from the high level user interface
	 * color scheme, in the form <code>0x00RRGGBB</code> based on the
	 * <code>colorSpecifier</code> passed in.
	 * 
	 * @param colorSpecifier - the predefined color specifier; must be one of COLOR_BACKGROUND, COLOR_FOREGROUND, COLOR_HIGHLIGHTED_BACKGROUND, COLOR_HIGHLIGHTED_FOREGROUND, COLOR_BORDER, or COLOR_HIGHLIGHTED_BORDER
	 * @return color in the form of 0x00RRGGBB
	 * @throws IllegalArgumentException - if colorSpecifier is not a valid color specifier
	 * @since  MIDP 2.0
	 */
	public int getColor(int colorSpecifier)
	{
		return this.nativeDisplay.getColor(colorSpecifier);
	}
	
	//#if polish.Display.idleEvent
	public Idle getIdleController()
	{
		return this.idle;
	}
	//#endif

	/**
	 * Returns the stroke style used for border drawing
	 * depending on the state of the component
	 * (highlighted/non-highlighted). For example, on a monochrome
	 * system, the border around a non-highlighted item might be
	 * drawn with a <code>DOTTED</code> stroke style while the border around a
	 * highlighted item might be drawn with a <code>SOLID</code> stroke style.
	 * 
	 * @param highlighted - true if the border style being requested is for the highlighted state, false if the border style being requested is for the non-highlighted state
	 * @return Graphics.DOTTED or Graphics.SOLID
	 * @since  MIDP 2.0
	 */
	public int getBorderStyle(boolean highlighted)
	{
		return this.nativeDisplay.getBorderStyle(highlighted);
	}

	/**
	 * Gets information about color support of the device.
	 * 
	 * @return true if the display supports color,  false otherwise
	 */
	public boolean isColor()
	{
		return this.nativeDisplay.isColor();
	}

	/**
	 * Gets the number of colors (if <code>isColor()</code> is
	 * <code>true</code>)
	 * or graylevels (if <code>isColor()</code> is <code>false</code>)
	 * that can be
	 * represented on the device.<P>
	 * Note that the number of colors for a black and white display is
	 * <code>2</code>.
	 * 
	 * @return number of colors
	 */
	public int numColors()
	{
		return this.nativeDisplay.numColors();
	}

	/**
	 * Gets the number of alpha transparency levels supported by this
	 * implementation.  The minimum legal return value is
	 * <code>2</code>, which indicates
	 * support for full transparency and full opacity and no blending.  Return
	 * values greater than <code>2</code> indicate that alpha blending
	 * is supported.  For
	 * further information, see <a href="Image.html#alpha">Alpha
	 * Processing</a>.
	 * 
	 * @return number of alpha levels supported
	 * @since  MIDP 2.0
	 */
	public int numAlphaLevels()
	{
		return this.nativeDisplay.numAlphaLevels();
	}

	/**
	 * Gets the current <code>Displayable</code> object for this <code>MIDlet</code>.  
	 * The
	 * <code>Displayable</code> object returned may not actually be
	 * visible on the display
	 * if the <code>MIDlet</code> is running in the background, or if
	 * the <code>Displayable</code> is
	 * obscured by a system screen.  The <A HREF="../../../javax/microedition/lcdui/Displayable.html#isShown()"><CODE>Displayable.isShown()</CODE></A> method may be called to determine whether the
	 * <code>Displayable</code> is actually visible on the display.
	 * 
	 * <p> The value returned by <code>getCurrent()</code> may be
	 * <code>null</code>. This
	 * occurs after the application has been initialized but before the first
	 * call to <code>setCurrent()</code>. </p>
	 * 
	 * @return the MIDlet's current Displayable object
	 * @see #setCurrent(Displayable)
	 */
	public Displayable getCurrent()
	{
		return this.currentDisplayable;
	}
	
	/**
	 * Gets the <code>Displayable</code> that is going to be shown next. If that's not present then the current displayable will be returned.  
	 * 
	 * @return the MIDlet's next or current Displayable object
	 * @see #setCurrent(Displayable)
	 */
	public Displayable getNextOrCurrent()
	{
		if (this.nextOrCurrentDisplayable != null) {
			return this.nextOrCurrentDisplayable;
		}
		return this.currentDisplayable;
	}


	/**
	 * Requests that a different <code>Displayable</code> object be
	 * made visible on the
	 * display.  The change will typically not take effect immediately.  It
	 * may be delayed so that it occurs between event delivery method
	 * calls, although it is not guaranteed to occur before the next event
	 * delivery method is called.  The <code>setCurrent()</code> method returns
	 * immediately, without waiting for the change to take place.  Because of
	 * this delay, a call to <code>getCurrent()</code> shortly after a
	 * call to <code>setCurrent()</code>
	 * is unlikely to return the value passed to <code>setCurrent()</code>.
	 * 
	 * <p> Calls to <code>setCurrent()</code> are not queued.  A
	 * delayed request made by a
	 * <code>setCurrent()</code> call may be superseded by a subsequent call to
	 * <code>setCurrent()</code>.  For example, if screen
	 * <code>S1</code> is current, then </p>
	 * 
	 * <TABLE BORDER="2">
	 * <TR>
	 * <TD ROWSPAN="1" COLSPAN="1">
	 * <pre><code>
	 * d.setCurrent(S2);
	 * d.setCurrent(S3);     </code></pre>
	 * </TD>
	 * </TR>
	 * </TABLE>
	 * 
	 * <p> may eventually result in <code>S3</code> being made
	 * current, bypassing <code>S2</code>
	 * entirely. </p>
	 * 
	 * <p> When a <code>MIDlet</code> application is first started,
	 * there is no current
	 * <code>Displayable</code> object.  It is the responsibility of
	 * the application to
	 * ensure that a <code>Displayable</code> is visible and can
	 * interact with the user at
	 * all times.  Therefore, the application should always call
	 * <code>setCurrent()</code>
	 * as part of its initialization. </p>
	 * 
	 * <p> The application may pass <code>null</code> as the argument to
	 * <code>setCurrent()</code>.  This does not have the effect of
	 * setting the current
	 * <code>Displayable</code> to <code>null</code>; instead, the
	 * current <code>Displayable</code>
	 * remains unchanged.  However, the application management software may
	 * interpret this call as a request from the application that it is
	 * requesting to be placed into the background.  Similarly, if the
	 * application is in the background, passing a non-null
	 * reference to <code>setCurrent()</code> may be interpreted by
	 * the application
	 * management software as a request that the application is
	 * requesting to be
	 * brought to the foreground.  The request should be considered to be made
	 * even if the current <code>Displayable</code> is passed to the
	 * <code>setCurrent()</code>.  For
	 * example, the code </p>
	 * <TABLE BORDER="2">
	 * <TR>
	 * <TD ROWSPAN="1" COLSPAN="1">
	 * <pre><code>
	 * d.setCurrent(d.getCurrent());    </code></pre>
	 * </TD>
	 * </TR>
	 * </TABLE>
	 * <p> generally will have no effect other than requesting that the
	 * application be brought to the foreground.  These are only requests,
	 * and there is no requirement that the application management
	 * software comply with these requests in a timely fashion if at all. </p>
	 * 
	 * <p> If the <code>Displayable</code> passed to
	 * <code>setCurrent()</code> is an <A HREF="../../../javax/microedition/lcdui/Alert.html"><CODE>Alert</CODE></A>, the previously current <code>Displayable</code>, if
	 * any, is restored after
	 * the <code>Alert</code> has been dismissed.  If there is a
	 * current <code>Displayable</code>, the
	 * effect is as if <code>setCurrent(Alert, getCurrent())</code>
	 * had been called.  Note
	 * that this will result in an exception being thrown if the current
	 * <code>Displayable</code> is already an alert.  If there is no
	 * current <code>Displayable</code>
	 * (which may occur at startup time) the implementation's previous state
	 * will be restored after the <code>Alert</code> has been
	 * dismissed.  The automatic
	 * restoration of the previous <code>Displayable</code> or the
	 * previous state occurs
	 * only when the <code>Alert's</code> default listener is present
	 * on the <code>Alert</code> when it
	 * is dismissed.  See <a href="Alert.html#commands">Alert Commands and
	 * Listeners</a> for details.</p>
	 * 
	 * <p>To specify the
	 * <code>Displayable</code> to be shown after an
	 * <code>Alert</code> is dismissed, the application
	 * should use the <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Alert, javax.microedition.lcdui.Displayable)"><CODE>setCurrent(Alert,
	 * Displayable)</CODE></A> method.  If the application calls
	 * <code>setCurrent()</code> while an
	 * <code>Alert</code> is current, the <code>Alert</code> is
	 * removed from the display and any timer
	 * it may have set is cancelled. </p>
	 * 
	 * <p> If the application calls <code>setCurrent()</code> while a
	 * system screen is
	 * active, the effect may be delayed until after the system screen is
	 * dismissed.  The implementation may choose to interpret
	 * <code>setCurrent()</code> in
	 * such a situation as a request to cancel the effect of the system
	 * screen, regardless of whether <code>setCurrent()</code> has
	 * been delayed. </p>
	 * 
	 * @param nextDisplayable - the Displayable requested to be made current; null is allowed
	 * @see #getCurrent()
	 */
	public void setCurrent( Displayable nextDisplayable)
	{
		//#debug
		System.out.println("Display.setCurrent " + nextDisplayable + ", current=" + this.currentDisplayable + ", isShown=" + isShown() );
		//try { throw new RuntimeException("for " + nextDisplayable); } catch (Exception e) { e.printStackTrace(); }
		this.nextOrCurrentDisplayable = nextDisplayable;
		
		//#if tmp.displayInfo
			if (this.showInfo) {
				this.infoNextDisplayable = nextDisplayable;
				return;
			}
		//#endif
		
		if (nextDisplayable == this.currentDisplayable) {
			repaint();
			this.nextOrCurrentDisplayable = null;
			return;
		}

		//#if polish.blackberry
			if (this.nativeDisplay.notifyDisplayableChange( this.currentDisplayable, nextDisplayable )) {
				this.nextOrCurrentDisplayable = null;
				return;
			}
		//#endif
		if (nextDisplayable == null || !(nextDisplayable instanceof Canvas)) {
			// this is a native Displayable
			if (nextDisplayable != null) {
				if (this.currentCanvas != null) {
					this.currentCanvas._hideNotify();
					this.currentCanvas = null;
				}
				this.currentDisplayable = nextDisplayable;
			}
			this.nativeDisplay.setCurrent( nextDisplayable );
			this.nextOrCurrentDisplayable = null;
			return;
		}
		
		if (nextDisplayable instanceof Alert && this.currentDisplayable != nextDisplayable) {
			Alert alert = (Alert)nextDisplayable;
			if (alert.nextDisplayable == null) {
				Displayable nxt = instance.currentDisplayable;
				//#if tmp.screenTransitions
					if (nxt instanceof ScreenChangeAnimation) {
						nxt = ((ScreenChangeAnimation)nxt).nextDisplayable;
					}
				//#endif
				alert.nextDisplayable = nxt;
			}
		}
		
		Canvas canvas = (Canvas) nextDisplayable;
		
		//#if tmp.screenTransitions
			// This has been introduced
			// to prevent the run() / callSerially() combo of 
			// ScreenChangeAnimation to set its next Displayable
			// while another Displayable has already been set
			if(this.currentCanvas instanceof ScreenChangeAnimation)
			{
				ScreenChangeAnimation animation = (ScreenChangeAnimation)this.currentCanvas;
				animation.abort();
				if(animation.nextCanvas != null) {
					animation.nextCanvas._hideNotify();
				}
			} else if (this.enableScreenChangeAnimations) { // check if a screen transition should be played
				try {
					Screen nextScreen = null;
					if ( nextDisplayable instanceof Screen ) {
						nextScreen = (Screen) nextDisplayable;
					}
					ScreenChangeAnimation screenAnimation = null;
					boolean isForwardAnimation = true;
		
					Screen lastScreen = null;
					Style screenstyle = null;
					//#if polish.ScreenChangeAnimation.forward:defined
						if (this.currentCanvas != null && this.currentCanvas instanceof UiElement) {
							lastScreen = (Screen) this.currentCanvas;
							Command lastCommand = lastScreen.lastTriggeredCommand;
							if (lastCommand != null && (lastCommand.getCommandType() == Command.BACK  || lastCommand.getCommandType() == Command.CANCEL) ) {
								screenAnimation = backwardAnimation;
								screenstyle = lastScreen.style;
								isForwardAnimation = false;
							}
						}
						if ( screenAnimation == null ) {
							screenAnimation = forwardAnimation;
							if (nextScreen != null) {
								screenstyle = nextScreen.style;
							}
						}
					//#else	
						//#ifdef polish.useDynamicStyles
							// check if the next screen has got a style:
							if (nextScreen != null && nextScreen.style == null) {
								nextScreen.cssSelector = nextScreen.createCssSelector();
								nextScreen.setStyle( StyleSheet.getStyle( nextScreen ) );
							}
						//#endif
						if (nextScreen != null && nextScreen.style != null && nextScreen.enableScreenChangeAnimation) {
							screenstyle = nextScreen.style;
							screenAnimation = (ScreenChangeAnimation) screenstyle.getObjectProperty("screen-change-animation");
						}
						Displayable lastDisplayable = this.currentDisplayable;
						if (lastDisplayable != null && lastDisplayable instanceof ScreenChangeAnimation ) {
							//#debug
							System.out.println("StyleSheet: last displayable is a ScreenChangeAnimation" );
							lastDisplayable = ((ScreenChangeAnimation) lastDisplayable).nextDisplayable;
						}
						if (lastDisplayable != null && lastDisplayable instanceof Screen) {
							//#debug
							System.out.println("StyleSheet: last displayble is a Screen");
							lastScreen = (Screen) lastDisplayable;
							//#if !tmp.fullScreen
								Object[] commands = lastScreen._commands == null ? null : lastScreen._commands.getInternalArray();
								if (commands != null) {
									for (int i = 0; i < commands.length; i++)
									{
										Command cmd = (Command) commands[i];
										if (cmd == null) {
											break;
										}
										removeCommand( cmd );
									}
								}
							//#endif							
							Command lastCommand = lastScreen.lastTriggeredCommand;
							if (lastCommand != null && (lastCommand.getCommandType() == Command.BACK  || lastCommand.getCommandType() == Command.CANCEL) ) {
								isForwardAnimation = false;
							}
							if ( (screenAnimation == null || !isForwardAnimation || lastScreen instanceof Alert) && lastScreen.style != null && lastScreen.enableScreenChangeAnimation) {
								ScreenChangeAnimation animation = (ScreenChangeAnimation) lastScreen.style.getObjectProperty("screen-change-animation");
								if (screenAnimation == null || animation != null) {
									screenstyle = lastScreen.style;
									screenAnimation = animation;
									isForwardAnimation = false;
								} else {
									isForwardAnimation = true;
								}
								//#debug
								System.out.println("StyleSheet: Using screen animation of last screen");
							}
						}
						//#if polish.Screen.showScreenChangeAnimationOnlyForScreen
							if ( nextScreen == null ) {
								screenAnimation = null;
							}
						//#endif
					//#endif
					if (screenAnimation != null) {
						int width = this.screenWidth;
						int height = this.screenHeight;
						if (width == 0) {
							width = getScreenWidth();
							height = getScreenHeight();
						}
						//#if polish.blackberry && polish.hasPointerEvents
							if ((nextScreen != null)
								&& hasPointerEvents()
								//#if polish.JavaPlatform >= BlackBerry/6.0
									&& (!Sensor.isSupported(Sensor.SLIDE) || (Sensor.getState(Sensor.SLIDE) == Sensor.STATE_SLIDE_CLOSED) )
								//#endif
							) {
								//adjust the screen size for the virtual keyboard that is going to be shown on the next screen:
								Item currentItem = nextScreen.getCurrentItem();
								if (height < this.bbMaxScreenHeight) {
									if (currentItem == null || currentItem._bbField == null) {
										height = this.bbMaxScreenHeight;
										nextScreen.sizeChanged( width, height );
									}
								} else if (currentItem != null && currentItem._bbField != null) {
									nextScreen.sizeChanged( width, this.bbMinScreenHeight );
								}
							}
						//#endif
						this.currentDisplayable = nextDisplayable;
						screenAnimation.onShow( screenstyle, this, width, height, lastDisplayable, nextDisplayable, isForwardAnimation );
						
						this.currentCanvas = screenAnimation;
						this.currentDisplayable = screenAnimation;
						
						if ( screenstyle == null ) {
							screenstyle = StyleSheet.defaultStyle;
						}
						if (nextScreen != null) {
							nextScreen._showNotify();
						}
						
						if (lastScreen != null) {
							lastScreen._hideNotify();
						}
						//#if !tmp.fullScreen
							screenAnimation.setTitle( nextScreen.getTitle() );
						//#endif
						screenAnimation._showNotify();
						if ( !isShown() ) {
							this.nativeDisplay.setCurrent( this );
						} else {
							repaint();
						}
						this.nextOrCurrentDisplayable = null;
						return;
					}
				} catch (Exception e) {
					//#debug error
					System.out.println("Screen: unable to start screen change animation" + e );
				}
			}
		//#endif
		
			
		if (isShown()) {
			if (this.commandListener != null) {
				this.commandListener = null;
			}
			if (canvas != null) {
				canvas._showNotify();
			}
			if (this.screenWidth != 0) {
				nextDisplayable.sizeChanged( this.screenWidth, this.screenHeight);
			}
		}
		Canvas oldCanvas = this.currentCanvas;
		this.currentCanvas = canvas;
		this.currentDisplayable = nextDisplayable;
		
		if ( oldCanvas != null ) {
			oldCanvas._hideNotify();
		}

		//#if polish.css.repaint-previous-screen
			// de-register an old remaining J2ME Polish screen for situations, in
			// which an AccessibleCanvas which is not a Screen is shown next.
			// Otherwise the AnimationThread will continue to animate the old
			// screen.
			if (StyleSheet.currentScreen != nextDisplayable &&  (!(nextDisplayable instanceof Screen))  ) {
				StyleSheet.currentScreen = null;
			}
		//#endif
		//#if polish.Bugs.noSoftKeyReleasedEvents
			this.isIgnoreReleasedEvent = true;
		//#endif
		if ( !isShown() ) {
			this.nativeDisplay.setCurrent( this );
		} else {
			repaint();
		}
		this.nextOrCurrentDisplayable = null;
	}

//	//#if polish.midp2
//	/**
//	 * Sets a game canvas as the next displayable
//	 * @param nextDisplayable the next screen
//	 */
//	public void setCurrent( javax.microedition.lcdui.game.GameCanvas nextDisplayable) {
//		if (this.nativeDisplay instanceof de.enough.polish.midp.ui.NativeDisplayImpl) {
//			de.enough.polish.midp.ui.NativeDisplayImpl disp = (de.enough.polish.midp.ui.NativeDisplayImpl) this.nativeDisplay;
//			if (this.currentCanvas != null) {
//				this.currentCanvas.hideNotify();
//				this.currentCanvas = null;
//				this.currentDisplayable = null;
//			}
//			disp.getDisplay().setCurrent(nextDisplayable);
//		}
//	}
//	//#endif

	
	
//	//#if polish.LibraryBuild
//	/**
//	 * Sets the given native displayable
//	 * @param nextDisplayable the next native displayable
//	 */
//	public void setCurrent( javax.microedition.lcdui.Screen nextDisplayable)
//	{
//		// ignore
//	}
//	//#endif

	/**
	 * Requests that this <code>Alert</code> be made current, and that
	 * <code>nextDisplayable</code> be
	 * made current
	 * after the <code>Alert</code> is dismissed.  This call returns
	 * immediately regardless
	 * of the <code>Alert's</code> timeout value or whether it is a
	 * modal alert.  The
	 * <code>nextDisplayable</code> must not be an <code>Alert</code>,
	 * and it must not be <code>null</code>.
	 * 
	 * <p>The automatic advance to <code>nextDisplayable</code> occurs only
	 * when the <code>Alert's</code> default listener is present on
	 * the <code>Alert</code> when it
	 * is dismissed.  See <a href="Alert.html#commands">Alert Commands and
	 * Listeners</a> for details.</p>
	 * 
	 * <p> In other respects, this method behaves identically to
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent(Displayable)</CODE></A>. </p>
	 * 
	 * @param alert - the alert to be shown
	 * @param nextDisplayable - the Displayable to be shown after this alert is  dismissed
	 * @throws NullPointerException - if alert or nextDisplayable is null
	 * @throws IllegalArgumentException - if nextDisplayable is an Alert
	 * @see Alert
	 * @see #getCurrent()
	 */
	public void setCurrent( Alert alert, Displayable nextDisplayable)
	{
		if (nextDisplayable != null) {
			alert.nextDisplayable = nextDisplayable;
		}
		setCurrent( alert );
	}
	

	/**
	 * Requests that the <code>Displayable</code> that contains this
	 * <code>Item</code> be made current,
	 * scrolls the <code>Displayable</code> so that this
	 * <code>Item</code> is visible, and possibly
	 * assigns the focus to this <code>Item</code>.  The containing
	 * <code>Displayable</code> is first
	 * made current as if <A HREF="../../../javax/microedition/lcdui/Display.html#setCurrent(javax.microedition.lcdui.Displayable)"><CODE>setCurrent(Displayable)</CODE></A> had been called.  When the containing
	 * <code>Displayable</code> becomes current, or if it is already
	 * current, it is
	 * scrolled if necessary so that the requested <code>Item</code>
	 * is made visible.
	 * Then, if the implementation supports the notion of input focus, and if
	 * the <code>Item</code> accepts the input focus, the input focus
	 * is assigned to the
	 * <code>Item</code>.
	 * 
	 * <p>This method always returns immediately, without waiting for the
	 * switching of the <code>Displayable</code>, the scrolling, and
	 * the assignment of
	 * input focus to take place.</p>
	 * 
	 * <p>It is an error for the <code>Item</code> not to be contained
	 * within a container.
	 * It is also an error if the <code>Item</code> is contained
	 * within an <code>Alert</code>.</p>
	 * 
	 * @param item - the item that should be made visible
	 * @throws IllegalStateException - if the item is not owned by a container
	 * @throws IllegalStateException - if the item is owned by an  Alert
	 * @throws NullPointerException - if item is null
	 * @since  MIDP 2.0
	 */
	public void setCurrentItem( Item item)
	{
		//#if !polish.LibraryBuild
			item.show(this);
		//#endif
	}

	/**
	 * Causes the <code>Runnable</code> object <code>r</code> to have
	 * its <code>run()</code> method
	 * called later, serialized with the event stream, soon after completion of
	 * the repaint cycle.  As noted in the
	 * <a href="./package-summary.html#events">Event Handling</a>
	 * section of the package summary,
	 * the methods that deliver event notifications to the application
	 * are all called serially. The call to <code>r.run()</code> will
	 * be serialized along with
	 * the event calls into the application. The <code>run()</code>
	 * method will be called exactly once for each call to
	 * <code>callSerially()</code>. Calls to <code>run()</code> will
	 * occur in the order in which they were requested by calls to
	 * <code>callSerially()</code>.
	 * 
	 * <p> If the current <code>Displayable</code> is a <code>Canvas</code>
	 * that has a repaint pending at the time of a call to
	 * <code>callSerially()</code>, the <code>paint()</code> method of the
	 * <code>Canvas</code> will be called and
	 * will return, and a buffer switch will occur (if double buffering is in
	 * effect), before the <code>run()</code> method of the
	 * <code>Runnable</code> is called.
	 * If the current <code>Displayable</code> contains one or more
	 * <code>CustomItems</code> that have repaints pending at the time
	 * of a call to <code>callSerially()</code>, the <code>paint()</code>
	 * methods of the <code>CustomItems</code> will be called and will
	 * return before the <code>run()</code> method of the
	 * <code>Runnable</code> is called.
	 * Calls to the
	 * <code>run()</code> method will occur in a timely fashion, but
	 * they are not guaranteed
	 * to occur immediately after the repaint cycle finishes, or even before
	 * the next event is delivered. </p>
	 * 
	 * <p> The <code>callSerially()</code> method may be called from
	 * any thread. The call to
	 * the <code>run()</code> method will occur independently of the
	 * call to <code>callSerially()</code>.
	 * In particular, <code>callSerially()</code> will <em>never</em>
	 * block waiting
	 * for <code>r.run()</code>
	 * to return. </p>
	 * 
	 * <p> As with other callbacks, the call to <code>r.run()</code>
	 * must return quickly. If
	 * it is necessary to perform a long-running operation, it may be initiated
	 * from within the <code>run()</code> method. The operation itself
	 * should be performed
	 * within another thread, allowing <code>run()</code> to return. </p>
	 * 
	 * <p> The <code>callSerially()</code> facility may be used by
	 * applications to run an
	 * animation that is properly synchronized with the repaint cycle. A
	 * typical application will set up a frame to be displayed and then call
	 * <code>repaint()</code>.  The application must then wait until
	 * the frame is actually
	 * displayed, after which the setup for the next frame may occur.  The call
	 * to <code>run()</code> notifies the application that the
	 * previous frame has finished
	 * painting.  The example below shows <code>callSerially()</code>
	 * being used for this
	 * purpose. </p>
	 * <TABLE BORDER="2">
	 * <TR>
	 * <TD ROWSPAN="1" COLSPAN="1">
	 * <pre><code>
	 * class Animation extends Canvas
	 * implements Runnable {
	 * 
	 * // paint the current frame
	 * void paint(Graphics g) { ... }
	 * 
	 * Display display; // the display for the application
	 * 
	 * void paint(Graphics g) { ... } // paint the current frame
	 * 
	 * void startAnimation() {
	 * // set up initial frame
	 * repaint();
	 * display.callSerially(this);
	 * }
	 * 
	 * // called after previous repaint is finished
	 * void run() {
	 * if ( &#47;* there are more frames *&#47; ) {
	 * // set up the next frame
	 * repaint();
	 * display.callSerially(this);
	 * }
	 * }
	 * }    </code></pre>
	 * </TD>
	 * </TR>
	 * </TABLE>
	 * 
	 * @param r - instance of interface Runnable to be called
	 */
	public void callSerially( Runnable r)
	{
		this.nativeDisplay.callSerially(r);
	}

	/**
	 * Requests a flashing effect for the device's backlight.  The flashing
	 * effect is intended to be used to attract the user's attention or as a
	 * special effect for games.  Examples of flashing are cycling the
	 * backlight on and off or from dim to bright repeatedly.
	 * The return value indicates if the flashing of the backlight
	 * can be controlled by the application.
	 * 
	 * <p>The flashing effect occurs for the requested duration, or it is
	 * switched off if the requested duration is zero.  This method returns
	 * immediately; that is, it must not block the caller while the flashing
	 * effect is running.</p>
	 * 
	 * <p>Calls to this method are honored only if the
	 * <code>Display</code> is in the
	 * foreground.  This method MUST perform no action
	 * and return <CODE>false</CODE> if the
	 * <code>Display</code> is in the background.
	 * 
	 * <p>The device MAY limit or override the duration. For devices
	 * that do not include a controllable backlight, calls to this
	 * method return <CODE>false</CODE>.
	 * 
	 * @param duration - the number of milliseconds the backlight should be flashed, or zero if the flashing should be stopped
	 * @return true if the backlight can be controlled by the application and this display is in the foreground, false otherwise
	 * @throws IllegalArgumentException - if duration is negative
	 * @since  MIDP 2.0
	 */
	public boolean flashBacklight(int duration)
	{
		return this.nativeDisplay.flashBacklight(duration);
	}

	/**
	 * Requests operation of the device's vibrator.  The vibrator is
	 * intended to be used to attract the user's attention or as a
	 * special effect for games.  The return value indicates if the
	 * vibrator can be controlled by the application.
	 * 
	 * <p>This method switches on the vibrator for the requested
	 * duration, or switches it off if the requested duration is zero.
	 * If this method is called while the vibrator is still activated
	 * from a previous call, the request is interpreted as setting a
	 * new duration. It is not interpreted as adding additional time
	 * to the original request. This method returns immediately; that
	 * is, it must not block the caller while the vibrator is
	 * running. </p>
	 * 
	 * <p>Calls to this method are honored only if the
	 * <code>Display</code> is in the foreground.  This method MUST
	 * perform no action and return <CODE>false</CODE> if the
	 * <code>Display</code> is in the background.</p>
	 * 
	 * <p>The device MAY limit or override the duration.  For devices
	 * that do not include a controllable vibrator, calls to this
	 * method return <CODE>false</CODE>.</p>
	 * 
	 * @param duration - the number of milliseconds the vibrator should be run, or zero if the vibrator should be turned off
	 * @return true if the vibrator can be controlled by the application and this display is in the foreground, false otherwise
	 * @throws IllegalArgumentException - if duration is negative
	 * @since  MIDP 2.0
	 */
	public boolean vibrate(int duration)
	{
		return this.nativeDisplay.vibrate(duration);
	}

	/**
	 * Returns the best image width for a given image type.
	 * The image type must be one of
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#LIST_ELEMENT"><CODE>LIST_ELEMENT</CODE></A>,
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#CHOICE_GROUP_ELEMENT"><CODE>CHOICE_GROUP_ELEMENT</CODE></A>, or
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#ALERT"><CODE>ALERT</CODE></A>.
	 * 
	 * @param imageType - the image type
	 * @return the best image width for the image type, may be zero if there is no best size; must not be negative
	 * @throws IllegalArgumentException - if imageType is illegal
	 * @since  MIDP 2.0
	 */
	public int getBestImageWidth(int imageType)
	{
		return this.nativeDisplay.getBestImageWidth(imageType);
	}

	/**
	 * Returns the best image height for a given image type.
	 * The image type must be one of
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#LIST_ELEMENT"><CODE>LIST_ELEMENT</CODE></A>,
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#CHOICE_GROUP_ELEMENT"><CODE>CHOICE_GROUP_ELEMENT</CODE></A>, or
	 * <A HREF="../../../javax/microedition/lcdui/Display.html#ALERT"><CODE>ALERT</CODE></A>.
	 * 
	 * @param imageType - the image type
	 * @return the best image height for the image type, may be zero if there is no best size; must not be negative
	 * @throws IllegalArgumentException - if imageType is illegal
	 * @since  MIDP 2.0
	 */
	public int getBestImageHeight(int imageType)
	{
		return this.nativeDisplay.getBestImageHeight(imageType);
	}
	
	/**
	 * Determines whether the given key is really a Canvas.FIRE game action
	 * @param keyCode the key code
	 * @param gameAction the game action
	 * @return true when the gameAction is Canvas.FIRE and the given key is not '5' or a soft key
	 */
	public boolean isGameActionFire(int keyCode, int gameAction)
	{
		return gameAction == FIRE && keyCode != KEY_NUM5
		//#if polish.Bugs.SoftKeyMappedToFire
			&& ( !(isSoftKeyLeft(keyCode, gameAction) || isSoftKeyRight(keyCode, gameAction)))
		//#endif
		;
	}
	
	/**
	 * Checks if the given keycode is the left softkey
	 * @param keyCode the key code
	 * @param gameAction the associated game action
	 * @return true when the key is the left soft key
	 */
	public final boolean isSoftKeyLeft( int keyCode, int gameAction ) {
		if (gameAction == LEFT || gameAction == RIGHT || gameAction == UP || gameAction == DOWN) {
			return false;
		}
		int expected = 
		//#ifdef polish.key.LeftSoftKey:defined
			//#=  ${polish.key.LeftSoftKey};
		//#else
			-6;
		//#endif
		//#if tmp.screenOrientation && polish.key.TopLeftSoftKey:defined
			if (this.screenOrientationDegrees == 90) {
				//#= expected = ${polish.key.TopLeftSoftKey};
			}
			//#if polish.key.TopRightSoftKey:defined
			else if (this.screenOrientationDegrees == 180) {
				//#= expected = ${polish.key.TopRightSoftKey};
			} else if (this.screenOrientationDegrees == 270) {
				expected = 
				//#ifdef polish.key.RightSoftKey:defined
					//#=  ${polish.key.RightSoftKey};
				//#else
					-7;
				//#endif
			}
			//#endif
		//#endif
		boolean result;
		//#if ! polish.key.LeftSoftKeys:defined
			result = (keyCode == expected);
		//#else
			result = false;
			//#foreach key in polish.key.LeftSoftKeys
				//#= expected = ${key};
				if ( keyCode == expected ) {
					return true;
				}
			//#next key
		//#endif
		return result;
	}
	
	/**
	 * Checks if the given keycode is the right softkey
	 * @param keyCode the key code
	 * @param gameAction the associated game action
	 * @return true when the key is the right soft key
	 */
	public final boolean isSoftKeyRight( int keyCode, int gameAction ) {
		if (gameAction == LEFT || gameAction == RIGHT || gameAction == UP || gameAction == DOWN) {
			return false;
		}
		int expected = 
		//#ifdef polish.key.RightSoftKey:defined
			//#=  ${polish.key.RightSoftKey};
		//#else
			-7;
		//#endif
		//#if tmp.screenOrientation && polish.key.TopLeftSoftKey:defined
			if (this.screenOrientationDegrees == 90) {
				expected = 
				//#ifdef polish.key.LeftSoftKey:defined
					//#=  ${polish.key.LeftSoftKey};
				//#else
					-6;
				//#endif
			//#if polish.key.TopRightSoftKey:defined
			} else if (this.screenOrientationDegrees == 180) {
				//#= expected = ${polish.key.TopLeftSoftKey};
			} else if (this.screenOrientationDegrees == 270) {
				//#= expected = ${polish.key.TopRightSoftKey};
			//#endif
			}
		//#endif
		boolean result;
		//#if ! polish.key.RightSoftKeys:defined
			result = (keyCode == expected);
		//#else
			result = false;
			//#foreach key in polish.key.RightSoftKeys
				//#= expected = ${key};
				if ( keyCode == expected ) {
					return true;
				}
			//#next key
		//#endif
		return result;
	}
	
	/**
	 * Checks if the given keycode is the middle softkey
	 * @param keyCode the key code
	 * @param gameAction the associated game action
	 * @return true when the key is the middle soft key
	 */
	public final boolean isSoftKeyMiddle( int keyCode, int gameAction ) {
		if (gameAction == LEFT || gameAction == RIGHT || gameAction == UP || gameAction == DOWN) {
			return false;
		}
		int expected = 
		//#ifdef polish.key.MiddleSoftKey:defined
			//#=  ${polish.key.MiddleSoftKey};
		//#elifdef polish.key.CenterSoftKey:defined
			//#=  ${polish.key.CenterSoftKey};
		//#else
			//#define tmp.hasNoMiddleSoftKey
			0;
			//# return false;
		//#endif
		//#if !tmp.hasNoMiddleSoftKey
		return (keyCode == expected);
		//#endif
	}
	
	
	/**
	 * Determines if the given keycode belongs to a softkey
	 * 
	 * @param keyCode the keycode
	 * @return true when the key code represents a softkey
	 */
	public boolean isSoftKey( int keyCode ) {
		int gameAction = 0;
		try {
			gameAction = getGameAction(keyCode);
		} catch (Exception e) {
			// could be an illegal key code
		}
		return isSoftKey( keyCode, gameAction );
	}
	


	/**
	 * Determines if the given keycode belongs to a soft key
	 * @param keyCode the key code
	 * @param gameAction the associated game action
	 * @return true when the given key is a keycode	
	 */
	public boolean isSoftKey(int keyCode, int gameAction)
	{
		return  isSoftKeyLeft(keyCode, gameAction) || isSoftKeyRight(keyCode, gameAction) || isSoftKeyMiddle(keyCode, gameAction);
	}
	
	//#if tmp.screenOrientation || polish.Bugs.SoftKeyMappedToFire || polish.Bugs.NormalKeyMappedToFire
	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#getGameAction(int)
	 */
	public int getGameAction(int keyCode)
	{
		int gameAction = super.getGameAction(keyCode);
		//#if polish.vendor == Nokia || polish.vendor == Generic
			if (gameAction == 0 && keyCode == -5
					//#if polish.vendor == Generic
						&& DeviceInfo.getVendor() == DeviceInfo.VENDOR_NOKIA
					//#endif
			) {
				gameAction = Canvas.FIRE;
			}
		//#endif
		//#if polish.Bugs.SoftKeyMappedToFire
			if (gameAction == FIRE && ( isSoftKeyLeft( keyCode, gameAction) || isSoftKeyRight(keyCode, gameAction))) {
				gameAction = 0;
			}
		//#endif
		//#if polish.Bugs.NormalKeyMappedToFire
			if ((gameAction == FIRE && (keyCode == Canvas.KEY_POUND || keyCode == Canvas.KEY_STAR || keyCode == 'a' || keyCode == 'j'))
				|| (gameAction == UP && (keyCode == 'r' || keyCode == 'p'))
				|| (gameAction == DOWN && (keyCode == 'v' || keyCode == 'y' || keyCode == 'z' || keyCode == 'c'))
				|| (gameAction == LEFT && (keyCode == 'd' || keyCode == 'l'))
				|| (gameAction == RIGHT && keyCode == 'g')
				|| (gameAction == GAME_A && keyCode == 'h')
				|| (gameAction == GAME_B && (keyCode == 'k' || keyCode == 's'))
				|| (gameAction == GAME_C && (keyCode == 'd' || keyCode == 'q'))
				|| (gameAction == GAME_D && (keyCode == 'm' || keyCode == 'y' || keyCode == 'z'))
				) {
				gameAction = 0;
			}
		//#endif
		//#if tmp.screenOrientation
			if (this.screenOrientationDegrees == 90) {
				switch (gameAction) {
				case UP: gameAction = LEFT; break;
				case LEFT: gameAction = DOWN; break;
				case RIGHT: gameAction = UP; break;
				case DOWN: gameAction = RIGHT; break;
				}
			} else if (this.screenOrientationDegrees == 180) {
				switch (gameAction) {
				case UP: gameAction = DOWN; break;
				case LEFT: gameAction = RIGHT; break;
				case RIGHT: gameAction = LEFT; break;
				case DOWN: gameAction = UP; break;
				}
			} else if (this.screenOrientationDegrees == 270) {
				switch (gameAction) {
				case UP: gameAction = RIGHT; break;
				case LEFT: gameAction = UP; break;
				case RIGHT: gameAction = DOWN; break;
				case DOWN: gameAction = LEFT; break;
				}
			}
		//#endif
		return gameAction;
	}	
	//#endif



	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#paint(javax.microedition.lcdui.Graphics)
	 */
	protected void paint(Graphics g)
	{
		
		//#if tmp.displayInfo
			if (this.showInfo) {
				int col = this.currentInfoColor;
				g.setColor(col);
				g.fillRect(0, 0, this.screenWidth, this.screenHeight );
				g.setColor( 0 );
				Font font = g.getFont();
				g.drawString("powered by", this.screenWidth/2, this.screenHeight/2 - 2, Graphics.BOTTOM | Graphics.HCENTER );
				g.drawString("J2ME Polish", this.screenWidth/2, this.screenHeight/2 + font.getHeight() + 2, Graphics.BOTTOM | Graphics.HCENTER );
				this.nativeDisplay.callSerially(this);
				return;
			}
		//#endif
		//#if tmp.fullScreen && polish.FullCanvasSize:defined && polish.Bugs.setClipForFullScreenNeeded
			g.translate( -g.getTranslateX(), -g.getTranslateY() );
			//#= g.setClip( 0, 0, ${polish.FullCanvasWidth}, ${polish.FullCanvasHeight} );
		//#endif
		if (this.currentCanvas != null) {
			//#if tmp.screenOrientation
				Graphics originalGraphics = null;
				int clipX = 0;
				int clipY = 0;
				int clipWidth = 0;
				int clipHeight = 0;
				int rotatedClipX = 0;
				int rotatedClipY = 0;
				int rotatedClipWidth = 0;
				int rotatedClipHeight = 0;
				//#if !tmp.RemoteScreen
				if (this.screenOrientationDegrees != 0) {
				//#endif
					Image buffer = this.screenOrientationBuffer;
					if (buffer == null || buffer.getWidth() != getScreenWidth() ) {
						int w = getScreenWidth();
						int h = getScreenHeight();
						buffer = Image.createImage( w, h );
						this.screenOrientationBuffer = buffer;
					}
					clipX = g.getClipX();
					clipY = g.getClipY();
					clipWidth = g.getClipWidth();
					clipHeight = g.getClipHeight();
					
					
					int sh = this.originalScreenHeight;
					int sw = this.originalScreenWidth;
					
					if (this.screenOrientationDegrees == 90) {
						rotatedClipX = clipY;
						rotatedClipY = sw - (clipX + clipWidth);
						rotatedClipWidth = clipHeight;
						rotatedClipHeight = clipWidth;
					} else if (this.screenOrientationDegrees == 180) {
						rotatedClipX = sw - (clipX + clipWidth);
						rotatedClipY = sh - (clipY + clipHeight);
						rotatedClipWidth = clipWidth;
						rotatedClipHeight = clipHeight;
					} else if (this.screenOrientationDegrees == 270) {
						rotatedClipX = sh - (clipY + clipHeight);
						rotatedClipY = clipX;
						rotatedClipWidth = clipHeight;
						rotatedClipHeight = clipWidth;
					}
					//#if tmp.RemoteScreen
						else {
							rotatedClipX = clipX;
							rotatedClipY = clipY;
							rotatedClipWidth = clipWidth;
							rotatedClipHeight = clipHeight;
						}
					//#endif
					originalGraphics = g;
					g = buffer.getGraphics();
					g.setClip( rotatedClipX, rotatedClipY, rotatedClipWidth, rotatedClipHeight );
					//#debug
					System.out.println("translating clipping from " + clipX + ", " + clipY + ", " + clipWidth + ", " + clipHeight 
							+ " to "
							+ rotatedClipX + ", " + rotatedClipY + ", " + rotatedClipWidth + ", " + rotatedClipHeight);
				//#if !tmp.RemoteScreen
				}
				//#endif
			//#endif
//				int clipX = g.getClipX();
//				int clipY = g.getClipY();
//				int clipWidth = g.getClipWidth();
//				int clipHeight = g.getClipHeight();
				
				
				this.currentCanvas.paint(g);
//				g.setClip( 0, 0, screenWidth, screenHeight);
//				g.setColor( 0xff);
//				g.drawRect( clipX + 1, clipY + 1, clipWidth - 2, clipHeight  -2 );
//				g.drawLine( clipX, clipY, clipX + clipWidth, clipY + clipHeight );
				//System.out.println("clip=" + clipX + ", " + clipY + ", " + clipWidth + ", " + clipHeight);
			
			//#if tmp.screenOrientation
				if (originalGraphics != null) {
					Image bufferImage = this.screenOrientationBuffer;
					if (bufferImage != null) {
						originalGraphics.drawRegion(bufferImage, rotatedClipX, rotatedClipY, rotatedClipWidth, rotatedClipHeight, getSpriteTransform(this.screenOrientationDegrees),  clipX, clipY, Graphics.LEFT | Graphics.TOP );
						//System.out.println("bufferImage.width=" + bufferImage.getWidth() + "x" + bufferImage.getHeight() );
						//originalGraphics.drawRGB( targetRgb, 0, clipWidth, clipX, clipY, clipWidth, clipHeight, false);
						//#if tmp.RemoteScreen
							int[] rgb = new int[ rotatedClipWidth * rotatedClipHeight ];
							bufferImage.getRGB(rgb, 0, rotatedClipWidth, rotatedClipX, rotatedClipY, rotatedClipWidth, rotatedClipHeight );
							int[] targetRgb;
							if (this.screenOrientationDegrees == 0) {
								targetRgb = rgb;
							} else {
								targetRgb = new int[ rgb.length ];
								ImageUtil.rotateSimple(rgb, targetRgb, rotatedClipWidth, rotatedClipHeight, this.screenOrientationDegrees );
							}
							this.remoteScreen.updateScreen(rotatedClipX, rotatedClipY, rotatedClipWidth, rotatedClipHeight,rgb);
						//#endif
					}
					//#if tmp.layer
						g = originalGraphics;
					//#endif
				}
			//#endif
		}
		//#if tmp.layer
			if (this.layers != null) {
				Object[] layerObjects = this.layers.getInternalArray();
				for (int i = 0; i < layerObjects.length; i++)
				{
					Canvas canvas = (Canvas) layerObjects[i];
					if (canvas == null) {
						break;
					}
					canvas.paint(g);
				}
			}
		//#endif
	}

	private int getSpriteTransform(int degrees) {
		switch (degrees) {
		case 0: return Sprite.TRANS_NONE;
		case 90: return Sprite.TRANS_ROT90;
		case 180: return Sprite.TRANS_ROT180;
		case 270: return Sprite.TRANS_ROT270;
		default: return Sprite.TRANS_NONE;
		}
	}

	/**
	 * @return the native display
	 */
	public NativeDisplay getNativeDisplay()
	{
		return this.nativeDisplay;
	}

	/**
	 * @return the singleton instance of this class
	 */
	public static Display getInstance()
	{
		return instance;
	}

	/**
	 * @param mode
	 */
	public static void _setFullScreenMode(boolean mode)
	{
		//#if !polish.midp1
		if (instance != null) {
			instance.setFullScreenMode(mode);
		}
		//#endif
	}

	/**
	 * @return <code>true</code> if the display is shown currently,
	 * <code>false</code> otherwise.
	 */
	public static boolean _isShown()
	{
		if (instance != null) {
			return instance.isShown();
		}
		return false;
	}

	public void setCommandListener( CommandListener listener) {
		this.commandListener = listener;
		super.setCommandListener(this);
	}
	
	
	/********************** MIDP Event Forwarding *********************************************************************/

	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#hideNotify()
	 */
	protected void hideNotify() {
		//#debug
		System.out.println("Display.hideNotify()");
		//#if tmp.wrapperScreen
			if (this.ignoreShowHide) {
				return;
			}
		//#endif
		if (this.currentCanvas != null) { 
			this.currentCanvas._hideNotifyExternal();
		}
	}
	
	
	
	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#showNotify()
	 */
	protected void showNotify() {
		//#debug
		System.out.println("Display.showNotify()");
		this.hasBeenShown = true;
		//#if tmp.wrapperScreen
			if (this.ignoreShowHide) {
				return;
			}
		//#endif
		//#if polish.css.mediaquery
			StyleSheet.showNotify();
		//#endif
		if (this.nonFullScreenHeight == 0) {
			this.nonFullScreenHeight = getHeight();
		}
		//#if polish.midp2 && tmp.fullScreen
			setFullScreenMode( true );
		//#endif
		boolean startAnimationThread = false;
		if (StyleSheet.animationThread == null) {
			StyleSheet.animationThread = new AnimationThread();
			startAnimationThread = true;
		}
		getScreenWidth();
		int h = getScreenHeight();
		//#if polish.blackberry && polish.hasPointerEvents
			if (h > this.bbMaxScreenHeight) {
				this.bbMaxScreenHeight = h;
			}
			if (h < this.bbMinScreenHeight) {
				this.bbMinScreenHeight = h;
			}
		//#endif
		if (this.currentCanvas != null) { 
			this.currentCanvas._showNotify();
			if (this.screenWidth != 0) {
				this.currentCanvas.sizeChanged( this.screenWidth, this.screenHeight );
			}
		}
		if (startAnimationThread) {
			StyleSheet.animationThread.start();
		}
	}

	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#keyPressed(int)
	 */
	protected void keyPressed(int keyCode) {
		//#if polish.blackberry
		if ((this.inputMethod == INPUT_METHOD_TOUCH) 
			//#if polish.JavaPlatform >= BlackBerry/4.2
			&& (Keypad.key(keyCode) != Keypad.KEY_MENU)
			//#endif
			&& (Keypad.key(keyCode) != Keypad.KEY_ESCAPE))
		//#endif
		{
			setInputMethod(INPUT_METHOD_KEY);
		}
		
		//#if polish.Display.useUserInputValidation
		if(this.validator != null && !this.validator.isKeyPressValid(keyCode)) {
			return;
		}
		//#endif
		if (this.emitNotifyOnUserEvent) {
			this.emitNotifyOnUserEvent = false;
			synchronized (this) {
				this.notifyAll();
			}
		}
		
		//#debug
		System.out.println("Display.keyPressed " + keyCode);
		//#if tmp.keyRepeatOverload
			this.keyRepeatCurrentKeyCode = keyCode;
		//#endif
		//#if polish.Bugs.noSoftKeyReleasedEvents
			this.isIgnoreReleasedEvent = false;
		//#endif
		if (this.currentCanvas != null) { 
			this.isLastEventProcessed = this.currentCanvas._keyPressed( keyCode );
		}
		
		//#if polish.Display.idleEvent
		this.idle.setTime(System.currentTimeMillis());
		//#endif
	}
	
	
	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#keyRepeated(int)
	 */
	protected void keyRepeated(int keyCode) {
		//#if polish.Display.useUserInputValidation
		if(this.validator != null && !this.validator.isKeyRepeatedValid(keyCode)) {
			return;
		}
		//#endif
		
		//#debug
		System.out.println("Display.keyRepeated " + keyCode );
		if (this.currentCanvas != null) { 
			//#if polish.Bugs.noSoftKeyReleasedEvents
				if (this.isIgnoreReleasedEvent) {
					// also ignore repeated events:
					return;
				}
			//#endif
			//#if tmp.keyRepeatOverload
				if (keyCode != this.keyRepeatCurrentKeyCode) {
					this.keyRepeatCurrentKeyCode = Integer.MAX_VALUE;
					if (!this.keyRepeatBugCounterResetDone) {
						this.keyRepeatBugCounter++;
						if (this.keyRepeatBugCounter > 100) {
							this.keyRepeatBugCounterResetDone = true;
							(new Thread() {
								public void run() {
									//#debug
									System.out.println("toggle screen for keyRepeat bug");
									toggleScreen();
									Display.this.keyRepeatBugCounter = 0;
									Display.this.keyRepeatBugCounterResetDone = false;
									//#debug
									System.out.println("screen reset finished");
								}
							}).start();
							toggleScreen();
						}
					}
					return;
				}
			//#endif
				this.isLastEventProcessed = this.currentCanvas._keyRepeated( keyCode );
		}
	}

	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#keyReleased(int)
	 */
	protected void keyReleased(int keyCode) {
		//#if polish.Display.useUserInputValidation
		if(this.validator != null && !this.validator.isKeyReleaseValid(keyCode)) {
			return;
		}
		//#endif
		
		//#debug
		System.out.println("Display.keyReleased " + keyCode);
		//#if tmp.keyRepeatOverload
			this.keyRepeatCurrentKeyCode = Integer.MAX_VALUE;
		//#endif
		//#if polish.Bugs.noSoftKeyReleasedEvents
			if (this.isIgnoreReleasedEvent) {
				this.isIgnoreReleasedEvent = false;
				return;
			}
		//#endif
		if (this.currentCanvas != null) {
			this.isLastEventProcessed = this.currentCanvas._keyReleased( keyCode );
		}
	}
	

	//#if polish.hasPointerEvents
	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#pointerPressed(int,int)
	 */
	protected void pointerPressed(int x, int y) {
		setInputMethod(INPUT_METHOD_TOUCH);
		//#if polish.Display.useUserInputValidation
		if(this.validator != null && !this.validator.isPointerPressValid(x, y)) {
			return;
		}
		//#endif
		if (this.emitNotifyOnUserEvent) {
			this.emitNotifyOnUserEvent = false;
			synchronized (this) {
				this.notifyAll();
			}
		}

		
		if (this.currentCanvas != null) { 
			//#if tmp.screenOrientation
				Point p = translatePoint( x, y );
				x = p.x;
				y = p.y;
			//#endif
			this.isLastEventProcessed = this.currentCanvas._pointerPressed( x, y );
		}
	}
	//#endif
	
	//#if polish.hasPointerEvents
	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#pointerPressed(int,int)
	 */
	protected void pointerReleased(int x, int y) {
		//#if polish.Display.useUserInputValidation
		if(this.validator != null && !this.validator.isPointerReleaseValid(x, y)) {
			return;
		}
		//#endif
		
		if (this.currentCanvas != null) { 
			//#if tmp.screenOrientation
				Point p = translatePoint( x, y );
				x = p.x;
				y = p.y;
			//#endif
			this.isLastEventProcessed = this.currentCanvas._pointerReleased( x, y );
		}
	}
	//#endif

	//#if polish.hasPointerEvents
	/* (non-Javadoc)
	 * @see javax.microedition.lcdui.Canvas#pointerPressed(int,int)
	 */
	protected void pointerDragged(int x, int y) {
		//#if polish.Display.useUserInputValidation
		if(this.validator != null && !this.validator.isPointerDragValid(x, y)) {
			return;
		}
		//#endif
		
		if (this.currentCanvas != null) {
			//#if tmp.screenOrientation
				Point p = translatePoint( x, y );
				x = p.x;
				y = p.y;
			//#endif
			this.isLastEventProcessed = this.currentCanvas._pointerDragged(x, y);
		}
	}
	//#endif
	
	//#if polish.blackberry
	 /**
     * Called when a key is pressed.
     * For backwards compatibility this method calls keyPressed(int).
     * 
     * @param keyCode the key code of the key that was pressed
     * @return true when the event was handled
     */
    protected boolean _keyPressed(int keyCode)
    {
    	keyPressed(keyCode);
    	return true;
    }

    /**
     * Called when a key is repeated (held down).
     * For backwards compatibility this method calls keyRepeated(int).
     * 
     * @param keyCode the key code of the key that was repeated
     * @see #hasRepeatEvents()
     */
    protected boolean _keyRepeated(int keyCode)
    {
    	keyRepeated(keyCode);
    	return true;
    }

    /**
     * Called when a key is released.
     * For backwards compatibility this method calls keyReleased(int).
     * 
     * @param keyCode the key code of the key that was released
     */
    protected boolean _keyReleased(int keyCode)
    {
    	keyReleased(keyCode);
    	return true;
    }
    
    /**
     * Called when the pointer is pressed.
     * For backwards compatibility this method calls pointerPressed(int,int).
     * 
     * @param x - the horizontal location where the pointer was pressed (relative to the Canvas)
     * @param y - the vertical location where the pointer was pressed (relative to the Canvas)
     */
    protected boolean _pointerPressed(int x, int y)
    {
    	pointerPressed(x, y);
    	return true;
    }

    /**
     * Called when the pointer is released.
     * For backwards compatibility this method calls pointerReleased(int,int).
     * 
     * @param x the horizontal location where the pointer was released (relative to the Canvas)
     * @param y the vertical location where the pointer was released (relative to the Canvas)
     */
    protected boolean _pointerReleased(int x, int y)
    {
    	pointerReleased(x, y);
    	return true;
    }

    /**
     * Called when the pointer is dragged.
     * For backwards compatibility this method calls pointerDragged(int,int).
     * 
     * @param x the horizontal location where the pointer was dragged (relative to the Canvas)
     * @param y the vertical location where the pointer was dragged (relative to the Canvas)
     */
    protected boolean _pointerDragged(int x, int y)
    {
    	pointerDragged(x, y);
    	return true;
    }

    //#endif
	
	
	//#ifdef polish.hasTouchEvents
	/**
	 * Handles a touch down/press event. 
	 * This is similar to a pointerPressed event, however it is only available on devices with screens that differentiate
	 * between press and touch events (read: BlackBerry Storm).
	 * 
	 * @param x the absolute horizontal pixel position of the touch event 
	 * @param y  the absolute vertical pixel position of the touch event
	 * @return true when the event was handled
	 */
	public boolean handlePointerTouchDown( int x, int y ) {
		setInputMethod(INPUT_METHOD_TOUCH);
		if (this.emitNotifyOnUserEvent) {
			this.emitNotifyOnUserEvent = false;
			synchronized (this) {
				this.notifyAll();
			}
		}
		if (this.currentCanvas != null) {
			//#if tmp.screenOrientation
				Point p = translatePoint( x, y );
				x = p.x;
				y = p.y;
			//#endif
			return this.currentCanvas.handlePointerTouchDown(x, y);
		}
		return false;
	}
	//#endif
	

	//#ifdef polish.hasTouchEvents
	/**
	 * Handles a touch up/release event. 
	 * This is similar to a pointerReleased event, however it is only available on devices with screens that differentiate
	 * between press and touch events (read: BlackBerry Storm).
	 * 
	 * @param x the absolute horizontal pixel position of the touch event 
	 * @param y  the absolute vertical pixel position of the touch event
	 * @return true when the event was handled
	 */
	public boolean handlePointerTouchUp( int x, int y ) {
		if (this.currentCanvas != null) {
			//#if tmp.screenOrientation
				Point p = translatePoint( x, y );
				x = p.x;
				y = p.y;
			//#endif
			return this.currentCanvas.handlePointerTouchUp(x, y);
		}
		return false;
	}
	//#endif
	
	private Point translatePoint( int x, int y ) { 
		//#if tmp.screenOrientation && 	polish.hasPointerEvents
			if (this.screenOrientationDegrees != 0) {
				//System.out.println("pointer event at " + x + ", " + y);
				int sh = this.screenHeight;
				int sw = this.screenWidth;
				if (this.screenOrientationDegrees == 90) {
					int t = x;
					x = y;
					y = sh - t;
				} else if (this.screenOrientationDegrees == 180) {
					x = sw - x;
					y = sh - y;
				} else if (this.screenOrientationDegrees == 270) {
					int t = x;
					x = sw - y;
					y = t;
				}
				//System.out.println("translated event at " + x + ", " + y);
			}
			this.pointerEventPoint.x = x;
			this.pointerEventPoint.y = y;
			return this.pointerEventPoint;
		//#else
			//# return null;
		//#endif

	}

	/**
	 * Notifies this display and the currently shown screen about a size change
	 * @param width the new width in pixels
	 * @param height the new height in pixels
	 */
	public void sizeChanged(int width, int height) {
		sizeChanged( width, height, false);
	}
	
	/**
	 * Notifies this display and the currently shown screen about a size change
	 * @param width the new width in pixels
	 * @param height the new height in pixels
	 * @param isRotated true if the given values have been rotated already
	 */
	public void sizeChanged(int width, int height, boolean isRotated) {
		//#debug
		System.out.println("sizeChanged=" + width +"x" + height);
		//#if polish.blackberry && polish.hasPointerEvents
			if (width == 360) {
				this.bbMaxScreenHeight = 480;
				this.bbMinScreenHeight = 248;
			} else if (width == 480) {
				this.bbMaxScreenHeight = 360;
				this.bbMinScreenHeight = 156;
			} else {
				if (height > this.bbMaxScreenHeight) {
					this.bbMaxScreenHeight = height;
				}
				if (height < this.bbMinScreenHeight) {
					this.bbMinScreenHeight = height;
				}
			}
		//#endif
		//try { throw new RuntimeException(); } catch (Exception e) { e.printStackTrace(); }
		//#if tmp.screenOrientation
			//#debug
			System.out.println("sizeChanged: orientation=" + this.screenOrientationDegrees + ", original=" + this.originalScreenWidth + "x" + this.originalScreenHeight);
			if (!isRotated && (this.screenOrientationDegrees == 90 || this.screenOrientationDegrees == 270)) {
				int t = width;
				width = height;
				height = t;
			}
		//#endif
		this.screenWidth = width;
		this.screenHeight = height;
		if (this.currentCanvas != null && this.hasBeenShown) {
			//#debug
			System.out.println("Calling sizeChanged " + width + "x" + height + " on "+ this.currentCanvas);
			this.currentCanvas.sizeChanged( width, height );
		}
		//#if tmp.remoteScreen
			this.remoteScreen.init(width, height, this.screenOrientationDegrees);
		//#endif
		repaint();
	}

	//#if polish.LibraryBuild 
	/**
	 * @param item
	 */
	protected void notifyFocusSet(Item item)
	{
		// ignore
	}
	//#endif
	
	//#if !polish.blackberry
	/**
	 * Determines whether a native UI component is shown for the specified item.
	 * This is currently only implemented for BlackBerry platforms - check for the preprocesing
	 * symbol polish.blackberry.
	 * 
	 * @param item the item that has been focused
	 */
	protected boolean isNativeUiShownFor( Item item ) {
		return false;
	}
	//#endif


	//#if polish.LibraryBuild 
	/**
	 * @param screen
	 * @param keyCode
	 * @return <code>true</code> if the event was handled, <code>false</code> otherwise.
	 */
	protected boolean forwardEventToNativeField(Screen screen, int keyCode)
	{
		// this is just a fake implementation, this method is used for BlackBerry support
		return false;
	}
	//#endif
	
	/**
	 * Retrieves the height of screens including space used for title and menubar (when in fullscreen mode).
	 * @return the height in pixels
	 */
	public static int getScreenHeight() {
		int h = 0;
		if (instance != null) {
			h = instance.screenHeight;
			if (h == 0
				//#if tmp.screenOrientation
					|| instance.originalScreenHeight == 0
				//#endif
					) {
				h = instance.getHeight();
				instance.screenHeight = h;
				//#if tmp.screenOrientation
					instance.originalScreenHeight = h;
					if (instance.screenOrientationDegrees == 90 || instance.screenOrientationDegrees == 270) {
						h = instance.getWidth();
						instance.screenHeight = h;
					}
				//#endif
				//#if polish.blackberry
					if (h == 0) {
						h = net.rim.device.api.ui.Graphics.getScreenHeight();
					}
				//#endif
			}
		} else {
			//#if polish.blackberry
				h = net.rim.device.api.ui.Graphics.getScreenHeight();
			//#elif polish.midp
				h = (new javax.microedition.lcdui.Canvas(){
					protected void paint(javax.microedition.lcdui.Graphics g)
					{
						// just a dummy
					}
				}).getHeight();
			//#endif

		}
		return h;
	}
	
	/**
	 * Retrieves the width of screens including space used for a scrollbar (when used).
	 * @return the width in pixels
	 */
	public static int getScreenWidth() {
		int w = 0;
		if (instance != null) {
			w = instance.screenWidth;
			if (w == 0
				//#if tmp.screenOrientation
					|| instance.originalScreenWidth == 0
				//#endif
					) 
			{
				w = instance.getWidth();
				instance.screenWidth = w;
				//#if tmp.screenOrientation
					instance.originalScreenWidth = w;
					if (instance.screenOrientationDegrees == 90 || instance.screenOrientationDegrees == 270) {
						w = instance.getHeight();
						instance.screenWidth = w;
					}
				//#endif
				//#if polish.blackberry
					if (w == 0) {
						w = net.rim.device.api.ui.Graphics.getScreenWidth();
					}
				//#endif
			}
		} else {
			//#if polish.blackberry
				w = net.rim.device.api.ui.Graphics.getScreenWidth();
			//#elif polish.midp
				w = (new javax.microedition.lcdui.Canvas(){
					protected void paint(javax.microedition.lcdui.Graphics g)
					{
						// just a dummy
					}
				}).getWidth();
			//#endif
		}
		return w;
	}

	/**
	 * Sets the screen orientation in degrees.
	 * 
	 * @param degrees the orientation - either 0, 90, 180 or 270 degrees
	 */
	public static void setScreenOrientation(int degrees)
	{
		//#if tmp.screenOrientation
			if (instance != null) {
				instance.setScreenOrientationImpl(degrees);
			} else {
				staticScreenOrientationDegrees = degrees;
			}
		//#endif
	}

	/**
	 * Sets the screen orientation in degrees.
	 * 
	 * @param degrees the orientation - either 0, 90, 180 or 270 degrees
	 */
	private void setScreenOrientationImpl(int degrees)
	{
		//#if tmp.screenOrientation
			//#debug
			System.out.println("Setting screenOrientation from " + this.screenOrientationDegrees + " to " + degrees);
			int prev = this.screenOrientationDegrees;
			if (degrees == prev) {
				return;
			}
//			//#if polish.css.screen-orientation-change-animation
//				Image beforeImage = null;
//				if (this.screenOrientationAnimation != null) {
//					beforeImage = Image.createImage( getScreenFullWidth(), getScreenFullHeight() );
//					paint( beforeImage.getGraphics() );
//				}
//			//#endif
			this.screenOrientationDegrees = degrees;
			this.screenOrientationBuffer = null;
			if (this.originalScreenWidth > 0 && ((prev + 180) % 360 != degrees )) {
				//#debug
				System.out.println("about to call sizeChanged - ((prev + 180) % 360)=" + ((prev + 180) % 360) + ", screen=" + this.originalScreenWidth + "x" + this.originalScreenHeight );
				if ((degrees == 90) || (degrees == 270)) {
					sizeChanged( this.originalScreenHeight, this.originalScreenWidth, true );
				} else {
					sizeChanged( this.originalScreenWidth, this.originalScreenHeight, true );
				}
			}
//			//#if polish.css.screen-orientation-change-animation
//				if (this.screenOrientationAnimation != null) {
//					boolean isForward = (degrees == 90 || degrees == 270);
//					Image afterImage = Image.createImage( getScreenFullWidth(), getScreenFullHeight() );
//					paint( afterImage.getGraphics() );
//					this.screenOrientationAnimation.show( this.style, StyleSheet.display, getScreenFullWidth(), getScreenFullHeight(),
//							beforeImage, afterImage, this, this, isForward );
//				} else {
//			//#endif
					if (isShown()) {
						repaint();
					}
//			//#if polish.css.screen-orientation-change-animation
//				}
//			//#endif
			//#if tmp.handleEvents
				EventManager.fireEvent("screen-orientation-change", this, new Integer(degrees));
			//#endif
		//#endif
	}
	
	/**
	 * Requests a repaint for the specified area
	 * 
	 * @param x the horizontal start in pixels
	 * @param y the vertical start in pixels
	 * @param width the width in pixels
	 * @param height the height in pixels
	 */
	public void requestRepaint( int x, int y, int width, int height ) {
		//#if tmp.screenOrientation
			int sw = this.originalScreenWidth;
			int sh = this.originalScreenHeight;
			//System.out.println("original repaint area: " + x + ", " + y + ", " + width + ", " + height + ", sw=" + sw + ", sh=" + sh);
			if (this.screenOrientationDegrees == 90) {
				int t = x;
				x = sw - (y + height);
				y = t;
				t = width;
				width = height;
				height = t;
			} else if (this.screenOrientationDegrees == 180) {
				x = sw - (x + width);
				y = sh - (y + height);
			} else if (this.screenOrientationDegrees == 270) {
				int t = x;
				x = y;
				y = sh - (t + width);
				t = width;
				width = height;
				height = t;
			}
			//System.out.println("adjusted repaint area: " + x + ", " + y + ", " + width + ", " + height + " for " + this.screenOrientationDegrees);
		//#endif
//		System.out.println("reqestRepaint area: " + x + ", " + y + ", " + width + ", " + height );
		repaint( x, y, width, height );
	}
	
	/**
	 * Requests a repaint for the complete screen
	 */
	public void requestRepaint() {
//		System.out.println("*** req full repaint ***");
		repaint();
	}
	
	//#if tmp.automaticScreenOrientation
	class ScreenOrientationDetector implements AccelerationListener {
		/* (non-Javadoc)
		 * @see de.enough.polish.util.sensor.AccelerationListener#notifyAcceleration(int, int, int, int, int, int, int, int, int)
		 */
		public void notifyAcceleration(int x, int minimumX, int maximumX,
				int y, int minimumY, int maximumY, int z, int minimumZ,
				int maximumZ)
		{
			if (x > 800 && y < 250) {
				setScreenOrientationImpl( 90 ); 
			} else if (x < 200 && y > 750) {
				setScreenOrientationImpl( 0 ); 
			} else if (x < 200 && y < -800) {
				setScreenOrientationImpl( 180 );
			} else if (x < -800 && y < 250) {
				setScreenOrientationImpl( 270 );
			}
		}		
	}
	//#endif
	
	//#if polish.Display.idleEvent
	/**
	 * Runs a thread and fires an event if the application is idle
	 */
	public class Idle extends Thread implements Runnable{
		
		/**
		 * the event that is fired
		 */
		public static final String EVENT = "Idle.event";
		
		//#if polish.Display.idleEvent.interval:defined
		//#	final static int interval = ${polish.Display.idleEvent.interval};
		//#else
			final static int interval = 60000;
		//#endif
		
		/**
		 * the time of the last keypress
		 */
		long time;
		
		/**
		 * Constructs a new Idle instance. Starts the thread.
		 */
		public Idle()
		{
			this.time = System.currentTimeMillis();
			start();
		}
		
		/* (non-Javadoc)
		 * @see java.lang.Thread#run()
		 */
		public void run()
		{
			while(true)
			{
				try {
					Thread.sleep(1000);
				}
				catch (InterruptedException e) {
					// Ignored.
				}
				
				long current = System.currentTimeMillis();
				
				if((current - this.time) > interval)
				{
					this.time = current;
					
					EventManager.fireEvent(EVENT, null, null);
				}
			}
		}
		
		/**
		 * Sets the last time the user pressed a button. Used in Display.keyPressed().
		 * @param time the time to set
		 */
		public void setTime(long time)
		{
			this.time = time;
		}
	}
	//#endif

	/**
	 * Retrieves the MIDlet.
	 * @return the MIDlet that is currently using the display.
	 */
	public MIDlet getMidlet()
	{
		return this.midlet;
	}

	//#if tmp.layer
	/**
	 * Adds a displayable, non interactive layer.
	 * This is only supported when you set the preprocessing variable 
	 * <code>polish.Display.supportLayers</code> to <code>true</code>.
	 * 
	 * @param canvas the canvas that should be shown.
	 */
	public void addLayer( Canvas canvas )
	{
		if (this.layers == null) {
			this.layers = new ArrayList();
		}
		this.layers.add( canvas );
		repaint();
	}
	//#endif
	
	//#if tmp.layer
	/**
	 * Removes a displayable, non interactive layer.
	 * 
	 * @param canvas the canvas that should be shown.
	 */
	public void removeLayer( Canvas canvas ) {
		this.layers.remove(canvas);
		repaint();
	}
	//#endif

	//#if polish.midp && !polish.android
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.CommandListener#commandAction(de.enough.polish.ui.Command, de.enough.polish.ui.Displayable)
	 */
	public void commandAction(javax.microedition.lcdui.Command c, javax.microedition.lcdui.Displayable d)
	{
		if (c instanceof Command) {
			if (this.commandListener != null) {
				this.commandListener.commandAction((Command)c, this.currentDisplayable );
			} else if (this.currentCanvas instanceof Screen) {
                            	((Screen)this.currentCanvas).handleCommand( (Command)c);
			}
		}
	}
	//#endif
	
	//#if polish.android
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.CommandListener#commandAction(de.enough.polish.ui.Command, de.enough.polish.ui.Displayable)
	 */
	public void commandAction(Command c, Displayable d)
	{
		if (this.commandListener != null) {
			this.commandListener.commandAction(c, this.currentDisplayable );
		} else if (this.currentCanvas instanceof Screen) {
			((Screen)this.currentCanvas).handleCommand( c );
		}
	}
	//#endif
	
	//#if polish.android
	public void shutdown() {
		instance = null;
	}
	//#endif
	
	public void toggleScreen() {
		//#if tmp.wrapperScreen
			//#debug
			System.out.println("toggle screen");
			this.ignoreShowHide = true;
			WrapperCanvas canvas = new WrapperCanvas();
			((de.enough.polish.midp.ui.NativeDisplayImpl)this.nativeDisplay).setCurrentNative( canvas );
			try {
				Thread.sleep(500);
			} catch (Exception e) {
				// ignore
			}
			this.nativeDisplay.setCurrent( this );
			try {
				Thread.sleep(100);
			} catch (Exception e) {
				// ignore
			}
			this.ignoreShowHide = false;
			//#debug
			System.out.println("screen toggle finished");
		//#endif
	}
	
	//#if polish.Display.useUserInputValidation
	
	/**
	 * The key validator
	 */
	UserInputValidator validator;
	
	/**
	 * Sets the key validator for this display
	 * @param validator
	 */
	public void setKeyValidator(UserInputValidator validator) {
		this.validator = validator;
	}
	
	/**
	 * An interface to implement to filter certain key actions
	 * @author Andre
	 *
	 */
	public interface UserInputValidator {
		boolean isKeyPressValid(int keyCode);
		boolean isKeyReleaseValid(int keyCode);
		boolean isKeyRepeatedValid(int keyCode);
		boolean isPointerPressValid(int x, int y);
		boolean isPointerReleaseValid(int x, int y);
		boolean isPointerDragValid(int x, int y);
	}
	//#endif
	
	//#if tmp.wrapperScreen
	class WrapperCanvas extends javax.microedition.lcdui.Canvas {
		
		public WrapperCanvas() {
			//#if tmp.fullScreen && polish.midp2
				setFullScreenMode(true);
			//#endif
		}
		
		//#if tmp.fullScreen && polish.midp2
			public void showNotify() {
				setFullScreenMode(true);
			}
		//#endif

		/* (non-Javadoc)
		 * @see javax.microedition.lcdui.Canvas#paint(javax.microedition.lcdui.Graphics)
		 */
		protected void paint(Graphics g)
		{
			Display.this.paint(g);
		}

		/* (non-Javadoc)
		 * @see javax.microedition.lcdui.Canvas#keyPressed(int)
		 */
		protected void keyPressed(int keyCode)
		{
			Display.this.keyPressed(keyCode);
		}

		/* (non-Javadoc)
		 * @see javax.microedition.lcdui.Canvas#keyReleased(int)
		 */
		protected void keyReleased(int keyCode)
		{
			Display.this.keyReleased(keyCode);
		}

		/* (non-Javadoc)
		 * @see javax.microedition.lcdui.Canvas#keyRepeated(int)
		 */
		protected void keyRepeated(int keyCode)
		{
			Display.this.keyRepeated(keyCode);
		}

		//#if polish.hasPointerEvents
		/* (non-Javadoc)
		 * @see javax.microedition.lcdui.Canvas#pointerDragged(int, int)
		 */
		protected void pointerDragged(int x, int y)
		{
			Display.this.pointerDragged(x, y);
		}

		/* (non-Javadoc)
		 * @see javax.microedition.lcdui.Canvas#pointerPressed(int, int)
		 */
		protected void pointerPressed(int x, int y)
		{
			Display.this.pointerPressed(x, y);
		}

		/* (non-Javadoc)
		 * @see javax.microedition.lcdui.Canvas#pointerReleased(int, int)
		 */
		protected void pointerReleased(int x, int y)
		{
			Display.this.pointerPressed(x, y);
		}
		//#endif
	}
	//#endif
	
	//#if tmp.displayInfo
	public void run() {
		int col = this.currentInfoColor + 0x030303;
		if (col >= 0xffffff || (System.currentTimeMillis() - this.infoStartTime) > 1500) {
			this.showInfo = false;
			if (this.infoNextDisplayable != null) {
				setCurrent( this.infoNextDisplayable );
				this.infoNextDisplayable = null;
			}
		} else {
			this.currentInfoColor = col;
			repaint();
		}
	}
	//#endif

	public void setMidlet(MIDlet midlet) {
		this.midlet = midlet;
	}

	/**
	 * Emits a notify on this instance when there are new user events.
	 * This is used by the AnimationThread to hold the animation thread completely after a time of inactivity
	 * @param emitNotify true when this.notifyAll() should be called after receiving an input event.
	 */
	protected void emitNotifyOnUserEvents(boolean emitNotify) {
		this.emitNotifyOnUserEvent = emitNotify;
	}
	

    /**
     * Determines the current input method.
     * When the user's last action was using keys, INPUT_METHOD_KEY is returned. When the last action was a pointer event, INPUT_METHOD_TOUCH is returned.
     * @return the current input method
     * @see #INPUT_METHOD_KEY
     * @see #INPUT_METHOD_TOUCH
     */
    public int getInputMethod() {
    	return this.inputMethod; 
    }
    
    /**
     * Returns true if the given input method equals the current input method
     * @param method the input method
     * @return true if the given input method equals the current input method otherwise false
	 * @see #INPUT_METHOD_KEY
	 * @see #INPUT_METHOD_TOUCH
     */
    public boolean isInputMethod(int method) {
    	return (this.inputMethod == method);
    }
    
    /**
     * Sets the current input method
     * @param inputMethod the current input method
     * @see #INPUT_METHOD_KEY
     * @see #INPUT_METHOD_TOUCH
     */
    private void setInputMethod(int inputMethod) {
    	//#debug debug
    	System.out.println("input method set : " + inputMethod);
    	this.inputMethod = inputMethod;
    }

}
