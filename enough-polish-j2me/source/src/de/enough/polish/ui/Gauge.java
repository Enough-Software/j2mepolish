//#condition polish.usePolishGui
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2004-2005 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.ui;

import java.io.IOException;

import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Font;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;

import de.enough.polish.ui.backgrounds.ImageBackground;
import de.enough.polish.ui.backgrounds.SimpleBackground;
import de.enough.polish.ui.backgrounds.VerticalStripesBackground;

/**
 * Implements a graphical display, such as a bar graph, of an integer
 * value.  The <code>Gauge</code> contains a <em>current value</em>
 * that lies between zero and the <em>maximum value</em>, inclusive.
 * The application can control the current value and maximum value.
 * The range of values specified by the application may be larger than
 * the number of distinct visual states possible on the device, so
 * more than one value may have the same visual representation.
 * 
 * <P>For example, consider a <code>Gauge</code> object that has a
 * range of values from zero to <code>99</code>, running on a device
 * that displays the <code>Gauge's</code> approximate value using a
 * set of one to ten bars. The device might show one bar for values
 * zero through nine, two bars for values ten through <code>19</code>,
 * three bars for values <code>20</code> through <code>29</code>, and
 * so forth. </p>
 * 
 * <P>A <code>Gauge</code> may be interactive or
 * non-interactive. Applications may set or retrieve the
 * <code>Gauge's</code> value at any time regardless of the
 * interaction mode.  The implementation may change the visual
 * appearance of the bar graph depending on whether the object is
 * created in interactive mode. </p>
 * 
 * <P>In interactive mode, the user is allowed to modify the
 * value. The user will always have the means to change the value up
 * or down by one and may also have the means to change the value in
 * greater increments.  The user is prohibited from moving the value
 * outside the established range. The expected behavior is that the
 * application sets the initial value and then allows the user to
 * modify the value thereafter. However, the application is not
 * prohibited from modifying the value even while the user is
 * interacting with it. </p>
 * 
 * <p> In many cases the only means for the user to modify the value
 * will be to press a button to increase or decrease the value by one
 * unit at a time.  Therefore, applications should specify a range of
 * no more than a few dozen values. </p>
 * 
 * <P>In non-interactive mode, the user is prohibited from modifying
 * the value.  Non-interactive mode is used to provide feedback to the
 * user on the state of a long-running operation. One expected use of
 * the non-interactive mode is as a &quot;progress indicator&quot; or
 * &quot;activity indicator&quot; to give the user some feedback
 * during a long-running operation. The application may update the
 * value periodically using the <code>setValue()</code> method. </P>
 * 
 * <P>A non-interactive <code>Gauge</code> can have a definite or
 * indefinite range.  If a <code>Gauge</code> has definite range, it
 * will have an integer value between zero and the maximum value set
 * by the application, inclusive.  The implementation will provide a
 * graphical representation of this value such as described above.</p>
 * 
 * <P>A non-interactive <code>Gauge</code> that has indefinite range
 * will exist in one of four states: continuous-idle,
 * incremental-idle, continuous-running, or incremental-updating.
 * These states are intended to indicate to the user that some level
 * of activity is occurring.  With incremental-updating, progress can
 * be indicated to the user even though there is no known endpoint to
 * the activity.  With continuous-running, there is no progress that
 * gets reported to the user and there is no known endpoint;
 * continuous-running is merely a busy state indicator. The
 * implementation should use a graphical display that shows this
 * appropriately.  The implementation may use different graphics for
 * indefinite continuous gauges and indefinite incremental gauges.
 * Because of this, separate idle states exist for each mode.  For
 * example, the implementation might show an hourglass or spinning
 * watch in the continuous-running state, but show an animation with
 * different states, like a beach ball or candy-striped bar, in the
 * incremental-updating state.</p>
 * 
 * <p>In the continuous-idle or incremental-idle state, the
 * <code>Gauge</code> indicates that no activity is occurring. In the
 * incremental-updating state, the <code>Gauge</code> indicates
 * activity, but its graphical representation should be updated only
 * when the application requests an update with a call to
 * <code>setValue()</code>.  In the continuous-running state, the
 * <code>Gauge</code> indicates activity by showing an animation that
 * runs continuously, without update requests from the
 * application.</p>
 * 
 * <p>The values <code>CONTINUOUS_IDLE</code>,
 * <code>INCREMENTAL_IDLE</code>, <code>CONTINUOUS_RUNNING</code>, and
 * <code>INCREMENTAL_UPDATING</code> have their special meaning only
 * when the <code>Gauge</code> is non-interactive and has been set to
 * have indefinite range.  They are treated as ordinary values if the
 * <code>Gauge</code> is interactive or if it has been set to have a
 * definite range.</p>
 * 
 * <P>An application using the <code>Gauge</code> as a progress
 * indicator should typically also attach a <A HREF="../../../javax/microedition/lcdui/Command.html#STOP"><CODE>STOP</CODE></A>
 * command to the container containing the <code>Gauge</code> to allow
 * the user to halt the operation in progress.</p>
 * 
 * <h3>Notes for Application Developers</h3>
 * 
 * <P>As mentioned above, a non-interactive <code>Gauge</code> may be
 * used to give user feedback during a long-running operation.  If the
 * application can observe the progress of the operation as it
 * proceeds to an endpoint known in advance, then the application
 * should use a non-interactive <code>Gauge</code> with a definite
 * range.  For example, consider an application that is downloading a
 * file known to be <code>20</code> kilobytes in size.  The
 * application could set the <code>Gauge's</code> maximum value to be
 * <code>20</code> and set its value to the number of kilobytes
 * downloaded so far.  The user will be presented with a
 * <code>Gauge</code> that shows the portion of the task completed at
 * any given time.</P>
 * 
 * <P>If, on the other hand, the application is downloading a file of
 * unknown size, it should use a non-interactive <code>Gauge</code>
 * with indefinite range.  Ideally, the application should call
 * <CODE>setValue(INCREMENTAL_UPDATING)</CODE> periodically, perhaps
 * each time its input buffer has filled.  This will give the user an
 * indication of the rate at which progress is occurring.</P>
 * 
 * <P>Finally, if the application is performing an operation but has
 * no means of detecting progress, it should set a non-interactive
 * <code>Gauge</code> to have indefinite range and set its value to
 * <CODE>CONTINUOUS_RUNNING</CODE> or <CODE>CONTINUOUS_IDLE</CODE> as
 * appropriate.  For example, if the application has issued a request
 * to a network server and is about to block waiting for the server to
 * respond, it should set the <code>Gauge's</code> state to
 * <CODE>CONTINUOUS_RUNNING</CODE> before awaiting the response, and it
 * should set the state to <CODE>CONTINUOUS_IDLE</CODE> after it has
 * received the response.</P>
 * <HR>
 * 
 * @author Robert Virkus, robert@enough.de
 * @since MIDP 1.0
 */
public class Gauge extends Item
//#ifdef polish.images.backgroundLoad
implements ImageConsumer
//#endif
{
	private static int ANIMATION_MODE_BACKANDFORTH = 1;
	
	/**
	 * A special value used for the maximum value in order to indicate that
	 * the <code>Gauge</code> has indefinite range.  This value may be
	 * used as the <code>maxValue</code>
	 * parameter to the constructor, the parameter passed to
	 * <code>setMaxValue()</code>, and
	 * as the return value of <code>getMaxValue()</code>.
	 * <P>
	 * The value of <code>INDEFINITE</code> is <code>-1</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int INDEFINITE = -1;

	/**
	 * The value representing the continuous-idle state of a
	 * non-interactive <code>Gauge</code> with indefinite range.  In
	 * the continuous-idle state, the gauge shows a graphic
	 * indicating that no work is in progress.
	 * 
	 * <p>This value has special meaning only for non-interactive
	 * gauges with indefinite range.  It is treated as an ordinary
	 * value for interactive gauges and for non-interactive gauges
	 * with definite range.</p>
	 * 
	 * <p>The value of <code>CONTINUOUS_IDLE</code> is
	 * <code>0</code>.</p>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int CONTINUOUS_IDLE = 0;

	/**
	 * The value representing the incremental-idle state of a
	 * non-interactive <code>Gauge</code> with indefinite range.  In
	 * the incremental-idle state, the gauge shows a graphic
	 * indicating that no work is in progress.
	 * 
	 * <p>This value has special meaning only for non-interactive
	 * gauges with indefinite range.  It is treated as an ordinary
	 * value for interactive gauges and for non-interactive gauges
	 * with definite range.</p>
	 * 
	 * <p>The value of <code>INCREMENTAL_IDLE</code> is
	 * <code>1</code>.</p>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int INCREMENTAL_IDLE = 1;

	/**
	 * The value representing the continuous-running state of a
	 * non-interactive <code>Gauge</code> with indefinite range.  In
	 * the continuous-running state, the gauge shows a
	 * continually-updating animation sequence that indicates that
	 * work is in progress.  Once the application sets a gauge into
	 * the continuous-running state, the animation should proceed
	 * without further requests from the application.
	 * 
	 * <p>This value has special meaning only for non-interactive
	 * gauges with indefinite range.  It is treated as an ordinary
	 * value for interactive gauges and for non-interactive gauges
	 * with definite range.</p>
	 * 
	 * <p>The value of <code>CONTINUOUS_RUNNING</code> is
	 * <code>2</code>.</p>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int CONTINUOUS_RUNNING = 2;

	/**
	 * The value representing the incremental-updating state of a
	 * non-interactive <code>Gauge</code> with indefinite range.  In
	 * the incremental-updating state, the gauge shows a graphic
	 * indicating that work is in progress, typically one frame of an
	 * animation sequence.  The graphic should be updated to the next
	 * frame in the sequence only when the application calls
	 * <code>setValue(INCREMENTAL_UPDATING)</code>.
	 * 
	 * <p>This value has special meaning only for non-interactive
	 * gauges with indefinite range.  It is treated as an ordinary
	 * value for interactive gauges and for non-interactive gauges
	 * with definite range.</p>
	 * 
	 * <p> The value of <code>INCREMENTAL_UPDATING</code> is
	 * <code>3</code>.</p>
	 * 
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int INCREMENTAL_UPDATING = 3;
	
	private static final int MODE_CONTINUOUS = 0; 
	private static final int MODE_CHUNKED = 1;
	
	private static final int POSITION_LEFT = 0;
	private static final int POSITION_RIGHT = 1;
	private static final int POSITION_CENTER = 2;

	private int value;
	private String valueString;
	private int maxValue;
	private boolean isInteractive;
	private Color color = new Color( 0x0000FF ); //default color is blue
	private int mode = MODE_CHUNKED;
	private Dimension chunkWidth = new Dimension(6);
	private Dimension gapWidth = new Dimension(3);
	private Color gapColor = new Color( 0xFFFFFF ); // default gap color is white
	private Image image;
	//#if polish.css.gauge-button-image
		private boolean useImageAsButton;
		private int sliderWidth;
	//#endif
	//#if polish.css.gauge-slider-image
		private Image sliderImage;
	//#endif
	private int imageYOffset;
	private boolean isIndefinite;
	private int indefinitePos;
	private boolean showValue = true;
	private int fontColor;
	private Font font;
	private int valueWidth;

	//#if polish.css.gauge-animation-speed
		private int animationSpeed = 1;
	//#endif
	//#if polish.css.gauge-animation-mode
		private int animationMode;
		private boolean animationDirectionDownwards;
	//#endif
	//#if polish.css.gauge-inactive-image
		private Image inactiveImage;
	//#endif
	//#if polish.css.gauge-is-percent
		private boolean isPercent;
	//#endif
	private int valuePosition = POSITION_LEFT;
	//private boolean isShown;
	private Background sliderBackground;
	private Background slider;

	private int indefinitePosMax;

	private boolean isDefaultChunkedSliderUsed;


	/**
	 * Creates a new <code>Gauge</code> object with the given
	 * label, in interactive or non-interactive mode, with the given
	 * maximum and initial values.  In interactive mode (where
	 * <code>interactive</code> is <code>true</code>) the maximum
	 * value must be greater than zero, otherwise an exception is
	 * thrown.  In non-interactive mode (where
	 * <code>interactive</code> is <code>false</code>) the maximum
	 * value must be greater than zero or equal to the special value
	 * <code>INDEFINITE</code>, otherwise an exception is thrown.
	 * 
	 * <p>If the maximum value is greater than zero, the gauge has
	 * definite range.  In this case the initial value must be within
	 * the range zero to <code>maxValue</code>, inclusive.  If the
	 * initial value is less than zero, the value is set to zero.  If
	 * the initial value is greater than <code>maxValue</code>, it is
	 * set to <code>maxValue</code>.</p>
	 * 
	 * <p>If <code>interactive</code> is <code>false</code> and the
	 * maximum value is <code>INDEFINITE</code>, this creates a
	 * non-interactive gauge with indefinite range. The initial value
	 * must be one of <code>CONTINUOUS_IDLE</code>,
	 * <code>INCREMENTAL_IDLE</code>, <code>CONTINUOUS_RUNNING</code>,
	 * or <code>INCREMENTAL_UPDATING</code>.</p>
	 * 
	 * @param label the Gauge's label
	 * @param interactive tells whether the user can change the value
	 * @param maxValue the maximum value, or INDEFINITE
	 * @param initialValue the initial value in the range [0..maxValue], or one of CONTINUOUS_IDLE, INCREMENTAL_IDLE, CONTINUOUS_RUNNING, or INCREMENTAL_UPDATING if maxValue is INDEFINITE.
	 * @throws IllegalArgumentException if maxValue is not positive for interactive gauges
	 * 												  or if maxValue is neither positive nor INDEFINITE for non-interactive gauges
	 * 												  or if initialValue is not one of CONTINUOUS_IDLE, INCREMENTAL_IDLE, CONTINUOUS_RUNNING, or INCREMENTAL_UPDATING for a non-interactive gauge with indefinite range
	 * @see #INDEFINITE
	 * @see #CONTINUOUS_IDLE
	 * @see #INCREMENTAL_IDLE
	 * @see #CONTINUOUS_RUNNING
	 * @see #INCREMENTAL_UPDATING
	 */
	public Gauge( String label, boolean interactive, int maxValue, int initialValue)
	{
		this( label, interactive, maxValue, initialValue, null );
	}

	/**
	 * Creates a new <code>Gauge</code> object with the given
	 * label, in interactive or non-interactive mode, with the given
	 * maximum and initial values.  In interactive mode (where
	 * <code>interactive</code> is <code>true</code>) the maximum
	 * value must be greater than zero, otherwise an exception is
	 * thrown.  In non-interactive mode (where
	 * <code>interactive</code> is <code>false</code>) the maximum
	 * value must be greater than zero or equal to the special value
	 * <code>INDEFINITE</code>, otherwise an exception is thrown.
	 * 
	 * <p>If the maximum value is greater than zero, the gauge has
	 * definite range.  In this case the initial value must be within
	 * the range zero to <code>maxValue</code>, inclusive.  If the
	 * initial value is less than zero, the value is set to zero.  If
	 * the initial value is greater than <code>maxValue</code>, it is
	 * set to <code>maxValue</code>.</p>
	 * 
	 * <p>If <code>interactive</code> is <code>false</code> and the
	 * maximum value is <code>INDEFINITE</code>, this creates a
	 * non-interactive gauge with indefinite range. The initial value
	 * must be one of <code>CONTINUOUS_IDLE</code>,
	 * <code>INCREMENTAL_IDLE</code>, <code>CONTINUOUS_RUNNING</code>,
	 * or <code>INCREMENTAL_UPDATING</code>.</p>
	 * 
	 * @param label the Gauge's label
	 * @param interactive tells whether the user can change the value
	 * @param maxValue the maximum value, or INDEFINITE
	 * @param initialValue the initial value in the range [0..maxValue], or one of CONTINUOUS_IDLE, INCREMENTAL_IDLE, CONTINUOUS_RUNNING, or INCREMENTAL_UPDATING if maxValue is INDEFINITE.
	 * @param style the CSS style for this item
	 * @throws IllegalArgumentException if maxValue is not positive for interactive gauges
	 * 												  or if maxValue is neither positive nor INDEFINITE for non-interactive gauges
	 * 												  or if initialValue is not one of CONTINUOUS_IDLE, INCREMENTAL_IDLE, CONTINUOUS_RUNNING, or INCREMENTAL_UPDATING for a non-interactive gauge with indefinite range
	 * @see #INDEFINITE
	 * @see #CONTINUOUS_IDLE
	 * @see #INCREMENTAL_IDLE
	 * @see #CONTINUOUS_RUNNING
	 * @see #INCREMENTAL_UPDATING
	 */
	public Gauge( String label, boolean interactive, int maxValue, int initialValue, Style style )
	{
		super( label, Item.LAYOUT_DEFAULT, Item.PLAIN, style );
		// check values:
		//#ifndef polish.skipArgumentCheck
			if (interactive) {
				if (maxValue < 0 ) {
					//#ifdef polish.debugVerbose
						throw new IllegalArgumentException("Invalid maxValue for interactive Gauge: " + maxValue );
					//#else
						//# throw new IllegalArgumentException();
					//#endif
				}
				if (initialValue < 0 || initialValue > maxValue) {
					//#ifdef polish.debugVerbose
						throw new IllegalArgumentException("Invalid initialValue for interactive Gauge: " + initialValue );
					//#else
						//# throw new IllegalArgumentException();
					//#endif
				}
			} else {
				if (maxValue == INDEFINITE) {
					this.isIndefinite = true;
					this.maxValue = 20;
					if ( !( initialValue == CONTINUOUS_IDLE 
							|| initialValue == CONTINUOUS_RUNNING
							|| initialValue == INCREMENTAL_IDLE
							|| initialValue == INCREMENTAL_UPDATING ) ) {
						//#ifdef polish.debugVerbose
							throw new IllegalArgumentException("Invalid initialValue for indefinite Gauge: " + initialValue );
						//#else
							//# throw new IllegalArgumentException();
						//#endif
					}
				} else if (maxValue < 0 ) {
					//#ifdef polish.debugVerbose
						throw new IllegalArgumentException("Invalid maxValue for Gauge: " + maxValue );
					//#else
						//# throw new IllegalArgumentException();
					//#endif
				} else if (initialValue < 0 || initialValue > maxValue) {
					//#ifdef polish.debugVerbose
						throw new IllegalArgumentException("Invalid initialValue for Gauge: " + initialValue );
					//#else
						//# throw new IllegalArgumentException();
					//#endif
				}			
			}
		//#endif
		// set values
		this.isInteractive = interactive;
		if (interactive) {
			this.appearanceMode = Item.INTERACTIVE;
		}
		this.maxValue = maxValue;
		this.isIndefinite = (maxValue == INDEFINITE);
		setValue( initialValue );
	}


	/**
	 * Sets the current value of this <code>Gauge</code> object.
	 * 
	 * <p>If the gauge is interactive, or if it is non-interactive with
	 * definite range, the following rules apply.  If the value is less than
	 * zero, zero is used. If the current value is greater than the maximum
	 * value, the current value is set to be equal to the maximum value. </p>
	 * 
	 * <p> If this <code>Gauge</code> object is a non-interactive
	 * gauge with indefinite
	 * range, then value must be one of <code>CONTINUOUS_IDLE</code>,
	 * <code>INCREMENTAL_IDLE</code>, <code>CONTINUOUS_RUNNING</code>, or
	 * <code>INCREMENTAL_UPDATING</code>.
	 * Other values will cause an exception to be thrown.</p>
	 * 
	 * @param value the new value
	 * @throws IllegalArgumentException if value is not one of CONTINUOUS_IDLE,  INCREMENTAL_IDLE, CONTINUOUS_RUNNING, or INCREMENTAL_UPDATING for non-interactive gauges with indefinite range
	 * @see #INDEFINITE
	 * @see #CONTINUOUS_IDLE
	 * @see #INCREMENTAL_IDLE
	 * @see #CONTINUOUS_RUNNING
	 * @see #INCREMENTAL_UPDATING
	 */
	public void setValue(int value)
	{
		if (this.isIndefinite) {
			if (this.value == CONTINUOUS_RUNNING  && value != CONTINUOUS_RUNNING) {
				// when the value WAS continuous-running, remove this gauge from 
				// the animations:
				AnimationThread.removeAnimationItem( this );
			}
			if (value == CONTINUOUS_IDLE) {
				this.indefinitePos = 0;
			} else if (value == CONTINUOUS_RUNNING) {
				if (this.isShown && this.value != CONTINUOUS_RUNNING) {
					AnimationThread.addAnimationItem( this );
				}
			} else if ( value == INCREMENTAL_IDLE ) {
				this.indefinitePos = 0;
			} else if ( value == INCREMENTAL_UPDATING ) {
				this.indefinitePos++;
				if (this.indefinitePos > this.maxValue ) {
					this.indefinitePos = 0;				
				}
			} else {
				//#ifdef polish.debugVerbose
					throw new IllegalArgumentException("Invalid value for indefinite Gauge: " + value );
				//#else
					//# throw new IllegalArgumentException();
				//#endif
			}
		} else if (value < 0  ) {
			value = 0;
		} else  if (value > this.maxValue) {
			value = this.maxValue;
		}
		this.value = value;
		this.valueString = Integer.toString( value );
		//#if polish.css.gauge-is-percent
			if (this.isPercent) {
				this.valueString += '%';
			}
		//#endif
		if (this.isShown) {
			repaint();
		}
	}


	/**
	 * Gets the current value of this <code>Gauge</code> object.
	 * 
	 * <p> If this <code>Gauge</code> object is a non-interactive
	 * gauge with indefinite
	 * range, the value returned will be one of <code>CONTINUOUS_IDLE</code>,
	 * <code>INCREMENTAL_IDLE</code>, <code>CONTINUOUS_RUNNING</code>, or
	 * <code>INCREMENTAL_UPDATING</code>.  Otherwise, it will be an integer
	 * between zero and the gauge's maximum value, inclusive.</p>
	 * 
	 * @return current value of the Gauge
	 * @see #INDEFINITE
	 * @see #CONTINUOUS_IDLE
	 * @see #INCREMENTAL_IDLE
	 * @see #CONTINUOUS_RUNNING
	 * @see #INCREMENTAL_UPDATING
	 */
	public int getValue()
	{
		return this.value;
	}

	/**
	 * Sets the maximum value of this <code>Gauge</code> object.
	 * 
	 * <p>For interactive gauges, the new maximum value must be greater than
	 * zero, otherwise an exception is thrown.  For non-interactive gauges,
	 * the new maximum value must be greater than zero or equal to the special
	 * value <code>INDEFINITE</code>, otherwise an exception is thrown.  </p>
	 * 
	 * <p>If the new maximum value is greater than zero, this provides the
	 * gauge with a definite range.  If the gauge previously had a definite
	 * range, and if the current value is greater than new maximum value, the
	 * current value is set to be equal to the new maximum value.  If the
	 * gauge previously had a definite range, and if the current value is less
	 * than or equal to the new maximum value, the current value is left
	 * unchanged. </p>
	 * 
	 * <p>If the new maximum value is greater than zero, and if the gauge had
	 * previously had indefinite range, this new maximum value provides it
	 * with a definite range.  Its graphical representation must change
	 * accordingly, the previous state of <code>CONTINUOUS_IDLE</code>,
	 * <code>INCREMENTAL_IDLE</code>, <code>CONTINUOUS_RUNNING</code>, or
	 * <code>INCREMENTAL_UPDATING</code> is ignored, and the current value
	 * is set to zero. </p>
	 * 
	 * <p>If this gauge is non-interactive and the new maximum value is
	 * <code>INDEFINITE</code>, this gives the gauge indefinite range.
	 * If the gauge
	 * previously had a definite range, its graphical representation must
	 * change accordingly, the previous value is ignored, and the current
	 * state is set to <code>CONTINUOUS_IDLE</code>.  If the gauge previously
	 * had an indefinite range, setting the maximum value to
	 * <code>INDEFINITE</code> will have no effect. </p>
	 * 
	 * @param maxValue the new maximum value
	 * @throws IllegalArgumentException if maxValue is invalid
	 * @see #INDEFINITE
	 * @see #getMaxValue()
	 */
	public void setMaxValue(int maxValue)
	{
		setInitialized(false);
		if (maxValue == INDEFINITE) {
			if (this.maxValue != maxValue) {
				this.value = CONTINUOUS_IDLE;
			}
			this.isIndefinite = true;
			//#ifndef polish.skipArgumentCheck
				} else if (maxValue < 0) {
					//#ifdef polish.verboseDebug
						throw new IllegalArgumentException("Invalid maxValue for Gauge: " + maxValue );
					//#else
						//# throw new IllegalArgumentException();
					//#endif
			//#endif
		} else if (this.value == CONTINUOUS_RUNNING) {
			this.isIndefinite = false;
			AnimationThread.removeAnimationItem( this );
		}
		this.maxValue = maxValue;
		setInitialized(false);
	}

	/**
	 * Gets the maximum value of this <code>Gauge</code> object.
	 * 
	 * <p>If this gauge is interactive, the maximum value will be a positive
	 * integer.  If this gauge is non-interactive, the maximum value will be a
	 * positive integer (indicating that the gauge has definite range)
	 * or the special value <code>INDEFINITE</code> (indicating that
	 * the gauge has indefinite range).</p>
	 * 
	 * @return the maximum value of the Gauge, or INDEFINITE
	 * @see #INDEFINITE
	 * @see #setMaxValue(int)
	 */
	public int getMaxValue()
	{
		return this.maxValue;
	}

	/**
	 * Tells whether the user is allowed to change the value of the
	 * <code>Gauge</code>.
	 * 
	 * @return a boolean indicating whether the Gauge is interactive
	 */
	public boolean isInteractive()
	{
		return this.isInteractive;
	}

	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#paint(int, int, javax.microedition.lcdui.Graphics)
	 */
	public void paintContent(int x, int y, int leftBorder, int rightBorder, Graphics g) {
		int sliderWidth = this.contentWidth;
		int valueX = x;
		int valueAnchor = Graphics.BOTTOM | Graphics.LEFT;
		if (this.showValue) {
			if (this.valuePosition == POSITION_LEFT) {
				x += this.valueWidth;
				sliderWidth -= this.valueWidth;
			} else	if (this.valuePosition == POSITION_RIGHT) {
				valueX = rightBorder;
				valueAnchor = Graphics.BOTTOM | Graphics.RIGHT;
				sliderWidth -= this.valueWidth;
			} else if (this.valuePosition == POSITION_CENTER) {
				valueX = leftBorder + ((rightBorder - leftBorder)/2);
				valueAnchor = Graphics.BOTTOM | Graphics.HCENTER;
			} 

		}
		//#ifdef polish.css.gauge-inactive-image
			if (this.inactiveImage != null) {
				g.drawImage(this.inactiveImage, x, y + this.imageYOffset, Graphics.TOP | Graphics.LEFT );
			}
		//#endif
		if (this.isIndefinite) {
			if (this.image != null) {
				g.drawImage( this.image, x + this.indefinitePos, y + this.imageYOffset,  Graphics.TOP | Graphics.LEFT );
			} else {
				int clipX = g.getClipX();
				int clipY = g.getClipX();
				int clipWidth = g.getClipWidth();
				int clipHeight = g.getClipHeight();
				g.clipRect( x, y, this.contentWidth, this.contentHeight );
				int gapPlusChunkWidth = this.indefinitePosMax; 
				int sliderX = x + this.indefinitePos - gapPlusChunkWidth;
				this.slider.paint( sliderX, y, this.contentWidth + this.indefinitePosMax, this.contentHeight, g );
				g.setClip( clipX, clipY, clipWidth, clipHeight );
			}
		} else if (this.image != null) {
			//#if polish.css.gauge-button-image
				if (this.value != 0 || this.useImageAsButton) {
			//#else
				//# if (this.value != 0) {
			//#endif
				//#if polish.css.gauge-button-image
					//#if polish.css.gauge-slider-image
						if (this.sliderImage != null) {
							g.drawImage(this.sliderImage, x, y + this.contentHeight / 2, Graphics.LEFT | Graphics.VCENTER);
						}
					//#endif
					if (this.useImageAsButton) {
						int xPos = (this.sliderWidth * this.value) / this.maxValue;
						g.drawImage( this.image, x + xPos, y + this.imageYOffset, Graphics.LEFT | Graphics.TOP );
					} else {
				//#endif
						int width = (this.image.getWidth() * this.value) / this.maxValue;
						int clipX = g.getClipX();
						int clipY = g.getClipY();
						int clipWidth = g.getClipWidth();
						int clipHeight = g.getClipHeight();
						g.clipRect(x, clipY, width, clipHeight );
						g.drawImage(this.image, x, y + this.imageYOffset, Graphics.TOP | Graphics.LEFT );
						
						g.setClip(clipX, clipY, clipWidth, clipHeight);
				//#if polish.css.gauge-button-image
					}
				//#endif
			}
		} else {
			if (this.sliderBackground != null) {
				this.sliderBackground.paint(x, y, sliderWidth, this.contentHeight, g );
			}
			int w = (sliderWidth * this.value) / this.maxValue;
			this.slider.paint(x, y, w, this.contentHeight, g );
		}
		if (this.showValue) {
			g.setFont( this.font );
			g.setColor( this.fontColor );
			g.drawString( this.valueString, valueX, y + this.font.getHeight(), valueAnchor );
		}
	}

	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#initItem()
	 */
	protected void initContent(int firstLineWidth, int availWidth, int availHeight) {
		this.valueWidth = 0;
		int valueHeight = 0;
		if (this.isIndefinite) {
			this.showValue = false;
		}
		if ( this.showValue) {
			if (this.font == null) {
				this.font = Font.getDefaultFont();
			}
			valueHeight = this.font.getHeight();
			this.valueWidth = this.font.stringWidth( "" + this.maxValue ) + this.paddingHorizontal;
		}
		// setting height:
		if (this.preferredHeight > 0 ) {
			this.contentHeight = this.preferredHeight;
			if (this.image != null) {
				int imageHeight = this.image.getHeight();
				if ( (this.layout & LAYOUT_BOTTOM) == LAYOUT_BOTTOM ) {
					this.imageYOffset = this.preferredHeight - imageHeight;
				} else if ( (this.layout & LAYOUT_VCENTER) == LAYOUT_VCENTER ) {
					this.imageYOffset = (this.preferredHeight - imageHeight) / 2;
				}
			}
		} else if (this.image != null) {
			this.contentHeight = this.image.getHeight();
		} else {
			this.contentHeight = 10;
		}
		if (this.contentHeight < valueHeight) {
			this.contentHeight = valueHeight;
		}
		// setting width:
		if (this.image != null 
				&& !this.isIndefinite 
				&& this.preferredWidth == 0 ) {
			//#if polish.css.gauge-button-image
				if (this.useImageAsButton) {
				//#if polish.css.gauge-slider-image
					if (this.sliderImage != null ) {
						this.contentWidth = this.sliderImage.getWidth() + this.valueWidth;
						this.sliderWidth = this.sliderImage.getWidth() - this.image.getWidth();
					} else {
				//#endif
						if (this.preferredWidth > 0) {
							this.contentWidth = this.preferredWidth + this.valueWidth;
						} else if (this.isLayoutExpand) {
							this.contentWidth = availWidth;
						} else {
							this.contentWidth = firstLineWidth;
						}
						this.sliderWidth = this.contentWidth - (this.valueWidth + this.image.getWidth());
				//#if polish.css.gauge-slider-image
					}
				//#endif
				} else {
			//#endif
					this.contentWidth = this.image.getWidth() + this.valueWidth;
			//#if polish.css.gauge-button-image
				}
			//#endif			
		} else if (this.preferredWidth > 0) {
			this.contentWidth = this.preferredWidth + this.valueWidth;
		} else if (this.isLayoutExpand) {
			this.contentWidth = availWidth;
		} else if ((this.layout & LAYOUT_SHRINK) == LAYOUT_SHRINK) {
			this.contentWidth = Math.max( availWidth / 3, 10 );
		} else {
			this.contentWidth = firstLineWidth;
		}
		
		// update other settings:
		if (this.isIndefinite) {
			if (this.image != null ) {
				if (this.value == CONTINUOUS_IDLE  || this.value == CONTINUOUS_RUNNING ) {
					this.maxValue = this.contentWidth;
				} else {
					this.maxValue = this.contentWidth / this.image.getWidth();
				}
			} else {
				this.maxValue = 20;
				this.indefinitePosMax = this.contentWidth;
				if (this.isDefaultChunkedSliderUsed) {
					this.indefinitePosMax = this.gapWidth.getValue(this.contentWidth) + this.chunkWidth.getValue(this.contentWidth);
				}
			}
		}
		if (this.slider == null) {
			this.slider = new SimpleBackground( this.color);
		}
	}

	//#ifdef polish.useDynamicStyles
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#getCssSelector()
	 */
	protected String createCssSelector() {
		return "gauge";
	}
	//#endif
	
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#setStyle(de.enough.polish.ui.Style)
	 */
	public void setStyle(Style style) {
		super.setStyle(style);
		//#ifdef polish.css.gauge-mode
			Integer modeInt = style.getIntProperty( "gauge-mode");
			if (modeInt != null) {
				if (modeInt.intValue() == 0) {
					this.mode = MODE_CHUNKED;
				} else {
					this.mode = MODE_CONTINUOUS;
				}					
			}
		//#endif
		//#ifdef polish.css.gauge-image
			String imageStr = style.getProperty( "gauge-image");
			if (imageStr != null) {
				try {
					this.image = StyleSheet.getImage( imageStr, this, false );
				} catch (IOException e) {
					//#debug error
					System.out.println("unable to load gauge-image [" + imageStr + "]: " + e );
				}
			}
		//#endif
		//#ifdef polish.css.gauge-inactive-image
			String inactiveImageStr = style.getProperty( "gauge-inactive-image");
			if (inactiveImageStr != null) {
				try {
					this.inactiveImage = StyleSheet.getImage( inactiveImageStr, null, false );
				} catch (IOException e) {
					//#debug error
					System.out.println("unable to load gauge-inactive-image [" + inactiveImageStr + "]: " + e );
				}
			}
		//#endif
		if (this.maxValue != INDEFINITE) {
			//#ifdef polish.css.gauge-show-value
				Boolean showValueBool = style.getBooleanProperty("gauge-show-value");
				if (showValueBool != null) {
					this.showValue = showValueBool.booleanValue();
				}
			//#endif
			if (style.getFont() != null) {
				this.font = style.getFont();
			}
			this.fontColor = style.getFontColor();
			//#ifdef polish.css.gauge-value-align
				Integer valuePositionInt =  style.getIntProperty( "gauge-value-align" );
				if (valuePositionInt != null) {
					this.valuePosition = valuePositionInt.intValue();
				}
			//#endif
		}
		//#if polish.css.gauge-animation-mode
			Integer animationModeInt = style.getIntProperty( "gauge-animation-mode" );
			if (animationModeInt != null) {
				this.animationMode = animationModeInt.intValue();
			}
		//#endif
		//#if polish.css.gauge-button-image
			String buttonImageUrl = style.getProperty("gauge-button-image");
			if (buttonImageUrl != null) {
				try {
					this.image = StyleSheet.getImage( buttonImageUrl, this, false );
					this.useImageAsButton = true;
				} catch (IOException e) {
					//#debug error
					System.out.println("unable to load gauge-button-image [" + buttonImageUrl + "]: " + e );
				}
			}
		//#endif
		//#if polish.css.gauge-slider-image
			String sliderImageUrl = style.getProperty("gauge-slider-image");
			if (sliderImageUrl != null) {
				try {
					this.sliderImage = StyleSheet.getImage( sliderImageUrl, this, false );
					this.slider = new ImageBackground(Color.TRANSPARENT, this.sliderImage, Graphics.TOP | Graphics.LEFT);
				} catch (IOException e) {
					//#debug error
					System.out.println("unable to load gauge-slider-image [" + sliderImageUrl + "]: " + e );
				}
			}
		//#endif
		//#if polish.css.gauge-is-percent
			Boolean isPercentBool = style.getBooleanProperty( "gauge-is-percent");
			if (isPercentBool != null) {
				this.isPercent = isPercentBool.booleanValue();
			}
		//#endif
		//#ifdef polish.css.gauge-background
			Background gaugeBackgroundObj = (Background) style.getObjectProperty("gauge-background");
			if (gaugeBackgroundObj != null) {
				this.sliderBackground = gaugeBackgroundObj;
			}
		//#endif
		//#ifdef polish.css.gauge-slider
			Background gaugeSliderObj = (Background) style.getObjectProperty("gauge-slider");
			if (gaugeSliderObj != null) {
				this.slider = gaugeSliderObj;
			}
		//#endif

		if (this.mode == MODE_CHUNKED && this.slider == null) {
			this.isDefaultChunkedSliderUsed = true;
			Color[] stripeColors = new Color[]{ this.color, this.gapColor };
			Dimension[] stripeWidhs = new Dimension[]{ this.chunkWidth, this.gapWidth };
			this.slider = new VerticalStripesBackground(stripeColors, stripeWidhs);
		}
	}
	
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#setStyle(de.enough.polish.ui.Style)
	 */
	public void setStyle(Style style, boolean resetStyle ) {
		super.setStyle(style, resetStyle);
		//#ifdef polish.css.gauge-color
			Color gaugeColorObj = (Color) style.getObjectProperty("gauge-color");
			if (gaugeColorObj != null) {
				this.color = gaugeColorObj;				
			}
		//#endif
		//#ifdef polish.css.gauge-background-color
			Color gaugeBackgroundColor = (Color) style.getObjectProperty("gauge-background-color");
			if (gaugeBackgroundColor != null) {
				this.sliderBackground = new SimpleBackground(gaugeBackgroundColor);
			}
		//#endif
		
		//#ifdef polish.css.gauge-width
			Integer width = style.getIntProperty( "gauge-width");
			if (width != null) {
				this.preferredWidth = width.intValue();
			}
		//#endif
		//#ifdef polish.css.gauge-height
			Integer height = style.getIntProperty( "gauge-height");
			if (height != null) {
				this.preferredHeight = height.intValue();
			}
		//#endif
		//#ifdef polish.css.gauge-gap-color
			Color gapColorObj = (Color) style.getObjectProperty( "gauge-gap-color");
			if (gapColorObj != null) {
				this.gapColor = gapColorObj;
			}
		//#endif
		//#ifdef polish.css.gauge-gap-width
			Dimension gapWidthDim = (Dimension) style.getObjectProperty( "gauge-gap-width");
			if (gapWidthDim != null) {
				this.gapWidth = gapWidthDim;
			}
		//#endif
		//#ifdef polish.css.gauge-chunk-width
			Dimension chunkWidtDim = (Dimension) style.getObjectProperty( "gauge-chunk-width");
			if (chunkWidtDim != null) {
				this.chunkWidth = chunkWidtDim;
			}
		//#endif
		
		//#if polish.css.gauge-animation-speed
			Integer animationSpeedInt = style.getIntProperty( "gauge-animation-speed" );
			if (animationSpeedInt != null) {
				this.animationSpeed = animationSpeedInt.intValue();
			}
		//#endif
	}

	//#ifdef polish.images.backgroundLoad
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.ImageConsumer#setImage(java.lang.String, javax.microedition.lcdui.Image)
	 */
	public void setImage(String name, Image image) {
		this.image = image;
		setInitialized(false);
		repaint();
	}
	//#endif
	
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#handleKeyPressed(int, int)
	 */
	protected boolean handleKeyPressed(int keyCode, int gameAction) {
		if (!this.isInteractive) {
			return false;
		}
		if (gameAction == Canvas.RIGHT) {
			if (this.value < this.maxValue) {
				setValue( ++ this.value );
				notifyStateChanged();
				return true;
			} else {
				//#if polish.blackberry
					//# return false;
				//#else
					// silently supress the event and stay in max position:
					return true;
				//#endif
			}			
		} else if (gameAction == Canvas.LEFT) {
			if (this.value > 0) {
				setValue( -- this.value );
				notifyStateChanged();
				return true;
			} else {
				//#if polish.blackberry
					//# return false;
				//#else
					// silently supress the event and stay in min position:
					return true;
				//#endif
			}
		} else {
			return false;
		}
	}
	
	//#ifdef polish.hasPointerEvents
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#handlePointerPressed(int, int)
	 */
	protected boolean handlePointerPressed(int x, int y) {
		if (this.isIndefinite || !this.isInteractive || !isInContentArea(x, y)) {
			return super.handlePointerPressed(x, y );
		}
		//#if polish.css.view-type
			if (this.view != null && this.view.handlePointerPressed(x, y)) {
				return true;
			}
		//#endif
		int cw = this.contentWidth;
		if (this.showValue && this.valuePosition == POSITION_LEFT) {
			x -= this.valueWidth;
			cw -= this.valueWidth;
		}
		x -= this.contentX - (cw / (this.maxValue * 2));
		int val = (x * this.maxValue) / cw;
		if (val != this.value) {
			setValue( val );
			notifyStateChanged();
		}
		return true;
	}
	//#endif
	
	//#ifdef polish.hasPointerEvents
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#handlePointerDragged(int, int, ClippingRegion)
	 */
	protected boolean handlePointerDragged(int x, int y, ClippingRegion repaintRegion ) {
		if (this.isIndefinite || !this.isInteractive || !isInContentArea(x, y)) {
			return super.handlePointerDragged(x, y, repaintRegion);
		}
		//#if polish.css.view-type
			if (this.view != null && this.view.handlePointerDragged(x, y, repaintRegion)) {
				return true;
			}
		//#endif
		int cw = this.contentWidth;
		if (this.showValue && this.valuePosition == POSITION_LEFT) {
			x -= this.valueWidth;
			cw -= this.valueWidth;
		}
		x -= this.contentX - (cw / (this.maxValue * 2));
		int val = (x * this.maxValue) / cw;
		if (val != this.value) {
			setValue( val );
			notifyStateChanged();
			addRepaintArea(repaintRegion);
		}		
		return true;
	}
	//#endif
	
	/* (non-Javadoc)
	 * @see de.enough.polish.ui.Item#animate()
	 */
	public boolean animate() {
		boolean animated = super.animate();
		//#if polish.css.view-type
			if (this.view != null) {
				// skip animation when there is a view present in this gauge
				return animated;
			}
		//#endif
		if (this.isIndefinite && this.value == CONTINUOUS_RUNNING && isInitialized()) {
			//#if polish.css.gauge-animation-mode
				if ( this.image != null && this.animationMode == ANIMATION_MODE_BACKANDFORTH ) {
					if (this.animationDirectionDownwards) {
						//#if polish.css.gauge-animation-speed
							this.indefinitePos -= this.animationSpeed;
						//#else
							this.indefinitePos--;
						//#endif
						if (this.indefinitePos <= 0) {
							this.indefinitePos = 0;
							this.animationDirectionDownwards = false;
						}
					} else {
						//#if polish.css.gauge-animation-speed
							this.indefinitePos += this.animationSpeed;
						//#else
							this.indefinitePos++;
						//#endif
						if (this.indefinitePos >= this.contentWidth - this.image.getWidth()) {				
							this.indefinitePos = this.contentWidth - this.image.getWidth();
							this.animationDirectionDownwards = true;
						}
					}
					return true;
				}
			//#endif
			//#if polish.css.gauge-animation-speed
				this.indefinitePos += this.animationSpeed;
			//#else
				this.indefinitePos++;
			//#endif
			if (this.image == null) {
				if (this.indefinitePos > this.indefinitePosMax) {
					this.indefinitePos = 0;
				}
			} else if (this.indefinitePos > this.maxValue) {				
				this.indefinitePos = -this.image.getWidth();
			}
			return true;
		}
		return animated;
	}
	
	

	/* (non-Javadoc)
	 * @see de.enough.polish.ui.FakeStringCustomItem#hideNotify()
	 */
	protected void hideNotify() {
		super.hideNotify();
		if (this.isIndefinite && this.value == CONTINUOUS_RUNNING) {
			AnimationThread.removeAnimationItem( this );
		}
		this.isShown = false;
	}

	/* (non-Javadoc)
	 * @see de.enough.polish.ui.FakeStringCustomItem#showNotify()
	 */
	protected void showNotify() {
		super.showNotify();
		if (this.isIndefinite && this.value == CONTINUOUS_RUNNING) {
			AnimationThread.addAnimationItem( this );
		}
		this.isShown = true;
	}
}
