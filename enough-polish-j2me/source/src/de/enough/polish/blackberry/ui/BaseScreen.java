//#condition polish.usePolishGui && polish.blackberry

// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sun Feb 29 19:10:57 CET 2004
package de.enough.polish.blackberry.ui; 

import net.rim.device.api.system.Application;
import net.rim.device.api.system.DeviceInfo;
import net.rim.device.api.system.KeypadListener;
import net.rim.device.api.system.TrackwheelListener;
import net.rim.device.api.ui.ContextMenu;
import net.rim.device.api.ui.Keypad;
import net.rim.device.api.ui.Field;
import net.rim.device.api.ui.Manager;
import net.rim.device.api.ui.component.Menu;
//#if polish.hasPointerEvents
	import net.rim.device.api.ui.TouchEvent; 
//#endif
import de.enough.polish.blackberry.midlet.MIDlet;
import de.enough.polish.ui.Command;
import de.enough.polish.ui.Item;
import de.enough.polish.ui.Screen;
import de.enough.polish.ui.Canvas;
import de.enough.polish.ui.Display;
import de.enough.polish.ui.Displayable;
import de.enough.polish.ui.UiAccess;
import de.enough.polish.util.ArrayList;
import de.enough.polish.util.Arrays;
import de.enough.polish.util.Comparator;
import de.enough.polish.util.DeviceControl;

/**
 * Provides the base screen / displayable implementation for BlackBerry devices.
 * 
 * @since J2ME Polish 2.1
 * @author robert virkus, j2mepolish@enough.de 
 */
public abstract class BaseScreen
//#if polish.useFullScreen
	//#define tmp.fullscreen
	//# extends net.rim.device.api.ui.container.FullScreen
//#else
	extends net.rim.device.api.ui.container.FullScreen //net.rim.device.api.ui.container.MainScreen
//#endif

{
	//#if polish.key.Menu:defined
		//#= private final static int MENU_KEY = ${polish.key.Menu};
	//#else
		private final static int MENU_KEY = 268566528;
	//#endif
	private static final int KEY_BB_UP = -1200;
    private static final int KEY_BB_DOWN = -1201;
    private static final int KEY_BB_LEFT = -1202;
    private static final int KEY_BB_RIGHT = -1203;
	private static final int KEY_BB_FIRE = -1204;

//    private static final int KEY_BB_0 = 2097152;
//    private static final int KEY_BB_1 = 4521984;
//    private static final int KEY_BB_2 = 5505024;
//    private static final int KEY_BB_3 = 5570560;
//    private static final int KEY_BB_4 = 4456448;
//    private static final int KEY_BB_5 = 4653056;
//    private static final int KEY_BB_6 = 4849664;
//    private static final int KEY_BB_7 = 4390912;
//    private static final int KEY_BB_8 = 4325376;
//    private static final int KEY_BB_9 = 5046272;

	//#if !tmp.fullscreen
		private final ArrayList addedMenuItems = new ArrayList();
	//#endif

    
    private final Graphics graphics;
    private final DummyField dummyField;
    final ArrayList addedItems;
    private Field menuField;

	private boolean isObscured;
	public Item currentItem;
	private int lastWidth;
	private int lastHeight;
	private boolean ignoreObscureEvent;
	protected boolean isLastEventProcessed;
	
    /**
     * Constructs a new <code>Canvas</code> object.
     */
    protected BaseScreen()
    {
    	//#if polish.useFullScreen
    		//# this( BaseScreenManager.getInstance(), 0 );
    	//#else
    		this( BaseScreenManager.getInstance(), DEFAULT_MENU );
    	//#endif
    }
    
    /**
     * Constructs a new <code>Canvas</code> object.
     */
    protected BaseScreen(Manager manager, long style)
    {
		super( manager, style );
    	//#if !polish.useFullScreen && polish.BlackBerry.addDefaultClose != true
			super.setDefaultClose(false);
    	//#endif
    	this.addedItems = new ArrayList();
        this.graphics = new Graphics();
        this.dummyField = new DummyField(); 
        add( this.dummyField );
        BaseScreenManager.getInstance().setBaseScreen(this);
    }
    

    /**
     * Checks if the software version of this device is higher than the specified one
     * @param version the version as double value, e.g. 4.7
     * @return true when the software version of this device is higher than the specified one
     */
    private static boolean checkSoftwareVersionHigherThan(double version) {
    	//#if polish.JavaPlatform >= BlackBerry/4.3
    		String versionStr = DeviceInfo.getSoftwareVersion();
    		if (versionStr != null && versionStr.length() > 0) {
    			double foundVersion = -1D;
    			try {
    				foundVersion = Double.parseDouble(versionStr);
    			} catch (Exception e) {
    				// this could be because softeware version returns '4.7.1' or similar - try to make it easier to parse ('4.7 in that case)
    				boolean allowDot = true;
    				StringBuffer buffer = new StringBuffer();
    				versionStr = versionStr.trim();
    				for (int i=0; i<versionStr.length(); i++) {
    					char c = versionStr.charAt(i);
    					if (Character.isDigit(c)) {
    						buffer.append(c);
    					} else if (allowDot && c == '.') {
    						buffer.append(c);
    						allowDot = false;
    					} else {
    						break;
    					}
    				}
        			try {
        				foundVersion = Double.parseDouble(buffer.toString());
        			} catch (Exception e2) {
        				// ok, give up, unable to parse
        				return false;
        			}
    			}
    			return foundVersion > version;
    		}
    	//#endif
		return false;
	}

	/**
     * Checks if the <code>Canvas</code> is double buffered by the
     * implementation.
     * 
     * @return true if double buffered, false otherwise
     */
    public boolean isDoubleBuffered()
    {
            return true;
    }

    /**
     * Checks if the platform supports pointer press and release events.
     * 
     * @return true if the device supports pointer events
     */
    public boolean hasPointerEvents()
    {
    	boolean result = false;
    	//#if polish.hasPointerEvents
    		//#if polish.JavaPlatform >= BlackBerry/4.7
    			result = net.rim.device.api.ui.Touchscreen.isSupported();
    		//#else
    			result = true;
    		//#endif
        //#endif
        return result;
    }

    /**
     * Checks if the platform supports pointer motion events (pointer dragged).
     * Applications may use this method to determine if the platform is capable
     * of supporting motion events.
     * 
     * @return true if the device supports pointer motion events
     */
    public boolean hasPointerMotionEvents()
    {
    	//#if polish.hasPointerEvents
			//# return true;
		//#else
	        return false;
	    //#endif
    }

    /**
     * Checks if the platform can generate repeat events when key
     * is kept down.
     * 
     * @return true if the device supports repeat events
     */
    public boolean hasRepeatEvents()
    {
            return true;
    }

    /**
     * Gets a key code that corresponds to the specified game action on the
     * device.  The implementation is required to provide a mapping for every
     * game action, so this method will always return a valid key code for
     * every game action.  See <a href="#gameactions">above</a> for further
     * discussion of game actions.  There may be multiple keys associated
     * with the same game action; however, this method will return only one of
     * them.  Applications should translate the key code of every key event
     * into a game action using <A HREF="../../../javax/microedition/lcdui/Canvas.html#getGameAction(int)"><CODE>getGameAction(int)</CODE></A> and then interpret the
     * resulting game action, instead of generating a table of key codes at
     * using this method during initialization.
     * 
     * <P>The mapping between key codes and game actions
     * will not change during the execution of the application.</P>
     * 
     * @param gameAction - the game action
     * @return a key code corresponding to this game action
     * @throws IllegalArgumentException - if gameAction  is not a valid game action
     */
    public int getKeyCode(int gameAction)
    {
        switch ( gameAction ) {
        case Canvas.FIRE: return Keypad.KEY_ENTER;
        case Canvas.UP: return KEY_BB_UP;
        case Canvas.DOWN: return KEY_BB_DOWN;
        case Canvas.LEFT: return KEY_BB_LEFT;
        case Canvas.RIGHT: return KEY_BB_RIGHT;
        }
        return 0;
    }

    /**
     * Gets an informative key string for a key. The string returned will
     * resemble the text physically printed on the key.  This string is
     * suitable for displaying to the user.  For example, on a device
     * with function keys <code>F1</code> through <code>F4</code>,
     * calling this method on the <code>keyCode</code> for
     * the <code>F1</code> key will return the string
     * &quot;<code>F1</code>&quot;. A typical use for this string
     * will be to compose help text such as &quot;Press
     * <code>F1</code> to proceed.&quot;
     * 
     * <p> This method will return a non-empty string for every valid key code.
     * </p>
     * 
     * <p> There is no direct mapping from game actions to key names. To get
     * the string name for a game action <code>GAME_A</code>, the
     * application must call </p>
     * 
     * <TABLE BORDER="2">
     * <TR>
     * <TD ROWSPAN="1" COLSPAN="1">
     * <pre><code>
     * getKeyName(getKeyCode(GAME_A));    </code></pre>
     * </TD>
     * </TR>
     * </TABLE>
     * 
     * @param keyCode - the key code being requested
     * @return a string name for the key
     * @throws IllegalArgumentException - if keyCode  is not a valid key code
     */
    public String getKeyName(int keyCode)
    {
            return "" + Keypad.getUnaltedChar( (char) keyCode );
    }

    /**
     * Gets the game action associated with the given key code of the
     * device.  Returns zero if no game action is associated with this key
     * code.  See <a href="#gameactions">above</a> for further discussion of
     * game actions.
     * 
     * <P>The mapping between key codes and game actions
     * will not change during the execution of the application.</P>
     * 
     * @param keyCode - the key code
     * @return the game action corresponding to this key, or  0 if none
     * @throws IllegalArgumentException - if keyCode is not a valid key code
     */
    public int getGameAction(int keyCode)
    {
        switch (keyCode) {
        case KEY_BB_UP: 	return Canvas.UP;
        case KEY_BB_DOWN:	return Canvas.DOWN;
        case KEY_BB_LEFT: 	return Canvas.LEFT;
        case KEY_BB_RIGHT: 	return Canvas.RIGHT;
        case KEY_BB_FIRE: 	return Canvas.FIRE;
        case Canvas.KEY_NUM2: 		return Canvas.UP; // 2
        case Canvas.KEY_NUM4: 		return Canvas.LEFT; // 4
        case Canvas.KEY_NUM6: 		return Canvas.RIGHT; // 6
        case Canvas.KEY_NUM8: 		return Canvas.DOWN; // 8
        }
        int key = Keypad.key( keyCode );
        switch ( key ) {
        case Keypad.KEY_ENTER: return Canvas.FIRE;
        //#if polish.BlackBerry.mapSpaceToFire
        	case Keypad.KEY_SPACE: return Canvas.FIRE;
        //#endif
        case Keypad.KEY_NEXT: return Canvas.DOWN;
        }
            
        //#if polish.key.EnterKey:defined
        	//#if false
        		int enterKey = 999;
        	//#else
        		//#= int enterKey = ${polish.key.EnterKey};
        	//#endif
            if (keyCode == enterKey) { 
            	return Canvas.FIRE; 
            } 
        //#endif
        return 0;
    }

    /**
     * Controls whether the <code>Canvas</code> is in full-screen mode
     * or in normal mode.
     * 
     * @param mode true if the Canvas is to be in full screen mode, false otherwise
     * @since  MIDP 2.0
     */
    public void setFullScreenMode(boolean mode)
    {
    	//this.fullScreenMode = mode;
    }
    
 
    /**
     * Called when a key is pressed.
     * 
     * <P>The <code>getGameAction()</code> method can be called to
     * determine what game action, if any, is mapped to the key.
     * Class <code>Canvas</code> has an empty implementation of this method, and
     * the subclass has to redefine it if it wants to listen this method.
     * 
     * @param keyCode - the key code of the key that was pressed
     */
    protected void keyPressed(int keyCode)
    {
            // do nothing
    }

    /**
     * Called when a key is repeated (held down).
     * 
     * <P>The <code>getGameAction()</code> method can
     * be called to determine what game action,
     * if any, is mapped to the key.
     * Class <code>Canvas</code> has an empty implementation of this method, and
     * the subclass has to redefine it if it wants to listen this method.
     * </P>
     * 
     * @param keyCode - the key code of the key that was repeated
     * @see #hasRepeatEvents()
     */
    protected void keyRepeated(int keyCode)
    {
            // do nothing
    }

    /**
     * Called when a key is released.
     * <P>
     * The <code>getGameAction()</code> method can be called to
     * determine what game action, if any, is mapped to the key.
     * Class <code>Canvas</code> has an empty implementation of this method, and
     * the subclass has to redefine it if it wants to listen this method.
     * </P>
     * 
     * @param keyCode - the key code of the key that was released
     */
    protected void keyReleased(int keyCode)
    {
            // do nothing
    }

    /**
     * Called when the pointer is pressed.
     * 
     * <P>
     * The <A HREF="../../../javax/microedition/lcdui/Canvas.html#hasPointerEvents()"><CODE>hasPointerEvents()</CODE></A>
     * method may be called to determine if the device supports pointer events.
     * Class <code>Canvas</code> has an empty implementation of this method, and
     * the subclass has to redefine it if it wants to listen this method.
     * </P>
     * 
     * @param x - the horizontal location where the pointer was pressed (relative to the Canvas)
     * @param y - the vertical location where the pointer was pressed (relative to the Canvas)
     */
    protected void pointerPressed(int x, int y)
    {
            // do nothing
    }

    /**
     * Called when the pointer is released.
     * 
     * <P>
     * The <A HREF="../../../javax/microedition/lcdui/Canvas.html#hasPointerEvents()"><CODE>hasPointerEvents()</CODE></A>
     * method may be called to determine if the device supports pointer events.
     * Class <code>Canvas</code> has an empty implementation of this method, and
     * the subclass has to redefine it if it wants to listen this method.
     * </P>
     * 
     * @param x - the horizontal location where the pointer was released (relative to the Canvas)
     * @param y - the vertical location where the pointer was released (relative to the Canvas)
     */
    protected void pointerReleased(int x, int y)
    {
            // do nothing
    }

    /**
     * Called when the pointer is dragged.
     * 
     * <P>
     * The <A HREF="../../../javax/microedition/lcdui/Canvas.html#hasPointerMotionEvents()"><CODE>hasPointerMotionEvents()</CODE></A>
     * method may be called to determine if the device supports pointer events.
     * Class <code>Canvas</code> has an empty implementation of this method, and
     * the subclass has to redefine it if it wants to listen this method.
     * </P>
     * 
     * @param x - the horizontal location where the pointer was dragged (relative to the Canvas)
     * @param y - the vertical location where the pointer was dragged (relative to the Canvas)
     */
    protected void pointerDragged(int x, int y)
    {
            // do nothing
    }
    
    /**
	 * Handles a touch down/press event. 
	 * This is similar to a pointerPressed event, however it is only available on devices with screens that differentiate
	 * between press and touch events (read: BlackBerry Storm).
	 * 
	 * @param x the absolute horizontal pixel position of the touch event 
	 * @param y  the absolute vertical pixel position of the touch event
	 * @return true when the event was handled
	 */
	public boolean handlePointerTouchDown( int x, int y ) {
		return false;
	}
	

	/**
	 * Handles a touch up/release event. 
	 * This is similar to a pointerReleased event, however it is only available on devices with screens that differentiate
	 * between press and touch events (read: BlackBerry Storm).
	 * 
	 * @param x the absolute horizontal pixel position of the touch event 
	 * @param y  the absolute vertical pixel position of the touch event
	 * @return true when the event was handled
	 */
	public boolean handlePointerTouchUp( int x, int y ) {
		return false;
	}
	

    /**
     * Requests a repaint for the specified region of the <code>Canvas</code>. 
     * Calling
     * this method may result in subsequent call to
     * <code>paint()</code>, where the passed
     * <code>Graphics</code> object's clip region will include at
     * least the specified
     * region.
     * 
     * <p> If the canvas is not visible, or if width and height are zero or
     * less, or if the rectangle does not specify a visible region of
     * the display, this call has no effect. </p>
     * 
     * <p> The call to <code>paint()</code> occurs asynchronously of
     * the call to <code>repaint()</code>.
     * That is, <code>repaint()</code> will not block waiting for
     * <code>paint()</code> to finish. The
     * <code>paint()</code> method will either be called after the
     * caller of <code>repaint(</code>)
     * returns
     * to the implementation (if the caller is a callback) or on another thread
     * entirely. </p>
     * 
     * <p> To synchronize with its <code>paint()</code> routine,
     * applications can use either
     * <A HREF="../../../javax/microedition/lcdui/Display.html#callSerially(java.lang.Runnable)"><CODE>Display.callSerially()</CODE></A> or
     * <A HREF="../../../javax/microedition/lcdui/Canvas.html#serviceRepaints()"><CODE>serviceRepaints()</CODE></A>, or they can code explicit
     * synchronization into their <code>paint()</code> routine. </p>
     * 
     * <p> The origin of the coordinate system is above and to the left of the
     * pixel in the upper left corner of the displayable area of the
     * <code>Canvas</code>.
     * The X-coordinate is positive right and the Y-coordinate is
     * positive downwards.
     * </p>
     * 
     * @param x - the x coordinate of the rectangle to be repainted
     * @param y - the y coordinate of the rectangle to be repainted
     * @param width - the width of the rectangle to be repainted
     * @param height - the height of the rectangle to be repainted
     * @see Display#callSerially(Runnable)
     * @see #serviceRepaints()
     */
    public final void repaint(int x, int y, int width, int height)
    {
        invalidate( x, y, width, height );
    }

    /**
     * Requests a repaint for the entire <code>Canvas</code>. The
     * effect is identical to
     * <p><code>repaint(0, 0, getWidth(), getHeight());</code>
     * 
     */
    public final void repaint()
    {
        invalidate();
    }

    /**
     * Forces any pending repaint requests to be serviced immediately. This
     * method blocks until the pending requests have been serviced. If
     * there are
     * no pending repaints, or if this canvas is not visible on the display,
     * this call does nothing and returns immediately.
     * 
     * <p><strong>Warning:</strong> This method blocks until the call to the
     * application's <code>paint()</code> method returns. The
     * application has no
     * control over
     * which thread calls <code>paint()</code>; it may vary from
     * implementation to
     * implementation. If the caller of <code>serviceRepaints()</code>
     * holds a lock that the
     * <code>paint()</code> method acquires, this may result in
     * deadlock. Therefore, callers
     * of <code>serviceRepaints()</code> <em>must not</em> hold any
     * locks that might be
     * acquired within the <code>paint()</code> method. The
     * <A HREF="../../../javax/microedition/lcdui/Display.html#callSerially(java.lang.Runnable)"><CODE>Display.callSerially()</CODE></A>
     * method provides a facility where an application can be called back after
     * painting has completed, avoiding the danger of deadlock.
     * </p>
     * 
     * @see Display#callSerially(Runnable)
     */
    public final void serviceRepaints()
    {
            //TODO implement serviceRepaints
    }

    /**
     * The implementation calls <code>showNotify()</code>
     * immediately prior to this <code>Canvas</code> being made
     * visible on the display.
     * Canvas subclasses may override
     * this method to perform tasks before being shown, such
     * as setting up animations, starting timers, etc.
     * 
     */
    protected void showNotify()
    {
    	// do nothing
    }

    /**
     * The implementation calls <code>hideNotify()</code> shortly
     * after the <code>Canvas</code> has been
     * removed from the display.
     * <code>Canvas</code> subclasses may override this method in
     * order to pause
     * animations,
     * revoke timers, etc.  The default implementation of this
     * method in class <code>Canvas</code> is empty.
     * 
     */
    protected void hideNotify()
    {
    	// do nothing

    }

    /**
     * Renders the <code>Canvas</code>. The application must implement
     * this method in
     * order to paint any graphics.
     * 
     * <p>The <code>Graphics</code> object's clip region defines the
     * area of the screen
     * that is considered to be invalid. A correctly-written
     * <code>paint()</code> routine
     * must paint <em>every</em> pixel within this region. This is necessary
     * because the implementation is not required to clear the region prior to
     * calling <code>paint()</code> on it.  Thus, failing to paint
     * every pixel may result
     * in a portion of the previous screen image remaining visible. </p>
     * 
     * <p>Applications <em>must not</em> assume that
     * they know the underlying source of the <code>paint()</code>
     * call and use this
     * assumption
     * to paint only a subset of the pixels within the clip region. The
     * reason is
     * that this particular <code>paint()</code> call may have
     * resulted from multiple
     * <code>repaint()</code>
     * requests, some of which may have been generated from outside the
     * application. An application that paints only what it thinks is
     * necessary to
     * be painted may display incorrectly if the screen contents had been
     * invalidated by, for example, an incoming telephone call. </p>
     * 
     * <p>Operations on this graphics object after the <code>paint()
     * </code>call returns are
     * undefined. Thus, the application <em>must not</em> cache this
     * <code>Graphics</code>
     * object for later use or use by another thread. It must only be
     * used within
     * the scope of this method. </p>
     * 
     * <p>The implementation may postpone visible effects of
     * graphics operations until the end of the paint method.</p>
     * 
     * <p> The contents of the <code>Canvas</code> are never saved if
     * it is hidden and then
     * is made visible again. Thus, shortly after
     * <code>showNotify()</code> is called,
     * <code>paint()</code> will always be called with a
     * <code>Graphics</code> object whose clip region
     * specifies the entire displayable area of the
     * <code>Canvas</code>.  Applications
     * <em>must not</em> rely on any contents being preserved from a previous
     * occasion when the <code>Canvas</code> was current. This call to
     * <code>paint()</code> will not
     * necessarily occur before any other key or pointer
     * methods are called on the <code>Canvas</code>.  Applications
     * whose repaint
     * recomputation is expensive may create an offscreen
     * <code>Image</code>, paint into it,
     * and then draw this image on the <code>Canvas</code> when
     * <code>paint()</code> is called. </p>
     * 
     * <P>The application code must never call <code>paint()</code>;
     * it is called only by
     * the implementation.</P>
     * 
     * <P>The <code>Graphics</code> object passed to the
     * <code>paint()</code> method has the following
     * properties:</P>
     * <UL>
     * <LI>the destination is the actual display, or if double buffering is in
     * effect, a back buffer for the display;</LI>
     * <LI>the clip region includes at least one pixel
     * within this <code>Canvas</code>;</LI>
     * <LI>the current color is black;</LI>
     * <LI>the font is the same as the font returned by
     * <A HREF="../../../javax/microedition/lcdui/Font.html#getDefaultFont()"><CODE>Font.getDefaultFont()</CODE></A>;</LI>
     * <LI>the stroke style is <A HREF="../../../javax/microedition/lcdui/Graphics.html#SOLID"><CODE>SOLID</CODE></A>;</LI>
     * <LI>the origin of the coordinate system is located at the upper-left
     * corner of the <code>Canvas</code>; and</LI>
     * <LI>the <code>Canvas</code> is visible, that is, a call to
     * <code>isShown()</code> will return
     * <code>true</code>.</LI>
     * </UL>
     * 
     * @param g - the Graphics object to be used for rendering the Canvas
     */
    protected abstract void paint( Graphics g);

    /**
     * Called when the drawable area of the <code>Canvas</code> has
     * been changed.  This
     * method has augmented semantics compared to <A HREF="../../../javax/microedition/lcdui/Displayable.html#sizeChanged(int, int)"><CODE>Displayable.sizeChanged</CODE></A>.
     * 
     * <p>In addition to the causes listed in
     * <code>Displayable.sizeChanged</code>, a size change can occur on a
     * <code>Canvas</code> because of a change between normal and
     * full-screen modes.</p>
     * 
     * <p>If the size of a <code>Canvas</code> changes while it is
     * actually visible on the
     * display, it may trigger an automatic repaint request.  If this occurs,
     * the call to <code>sizeChanged</code> will occur prior to the call to
     * <code>paint</code>.  If the <code>Canvas</code> has become smaller, the
     * implementation may choose not to trigger a repaint request if the
     * remaining contents of the <code>Canvas</code> have been
     * preserved.  Similarly, if
     * the <code>Canvas</code> has become larger, the implementation
     * may choose to trigger
     * a repaint only for the new region.  In both cases, the preserved
     * contents must remain stationary with respect to the origin of the
     * <code>Canvas</code>.  If the size change is significant to the
     * contents of the
     * <code>Canvas</code>, the application must explicitly issue a
     * repaint request for the
     * changed areas.  Note that the application's repaint request should not
     * cause multiple repaints, since it can be coalesced with repaint
     * requests that are already pending.</p>
     * 
     * <p>If the size of a <code>Canvas</code> changes while it is not
     * visible, the
     * implementation may choose to delay calls to <code>sizeChanged</code>
     * until immediately prior to the call to <code>showNotify</code>.  In
     * that case, there will be only one call to <code>sizeChanged</code>,
     * regardless of the number of size changes.</p>
     * 
     * <p>An application that is sensitive to size changes can update instance
     * variables in its implementation of <code>sizeChanged</code>.  These
     * updated values will be available to the code in the
     * <code>showNotify</code>, <code>hideNotify</code>, and
     * <code>paint</code> methods.</p>
     * 
     * @param w - the new width in pixels of the drawable area of the Canvas
     * @param h - the new height in pixels of the drawable area of the Canvas
     * @see Displayable#sizeChanged in class Displayable
     * @since  MIDP 2.0
     */
    protected void sizeChanged(int w, int h)
    {
            // do nothing
    }

//    protected void paint( net.rim.device.api.ui.Graphics g ) {
//      // do nothing..
//    }
    
 

    protected void paintBackground( net.rim.device.api.ui.Graphics g ) {
        //System.out.println("Canvas.paintBackground(): enter");
    	try {
	        this.graphics.setGraphics( g );
	    	paint( this.graphics );
    	} catch (Exception e) {
    		//#debug error
    		System.out.println("unable to paint screen " + this + e );
    	}
    }
    
	/* (non-Javadoc)
	 * @see net.rim.device.api.ui.Screen#onExposed()
	 */
	protected void onExposed() {
		this.isObscured = false;
		super.onExposed();
		if (!this.ignoreObscureEvent) {
			showNotify();
		}
	}
	
	/* (non-Javadoc)
	 * @see net.rim.device.api.ui.Screen#onObscured()
	 */
	protected void onObscured() {
		this.isObscured = true;
		super.onObscured();
		if (!this.ignoreObscureEvent) {
			hideNotify();
		}
	}

	//#if polish.JavaPlatform >= BlackBerry/4.3
	protected void onUiEngineAttached(boolean attached) {
		if (attached) {
			showNotify();
		} else {
			hideNotify();
		}
		super.onUiEngineAttached(attached);
	}
	//#else
	protected void onDisplay() {
		super.onDisplay();
		showNotify();
	}
    protected void onUndisplay() {
        super.onUndisplay();
        hideNotify();
    }
    //#endif


	/* (non-Javadoc)
     * @see net.rim.device.api.ui.container.FullScreen#sublayout(int, int)
     */
    protected void sublayout(int width, int height) {
            super.sublayout(width, height);
            int w = net.rim.device.api.ui.Graphics.getScreenWidth();
            int h = net.rim.device.api.ui.Graphics.getScreenHeight();
            if (w != this.lastWidth || h != this.lastHeight) {
            	this.lastWidth = w;
            	this.lastHeight = h;
            	setExtent( w,  h );
            	sizeChanged( w, h );
            }
    }

    /* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#onMenu(int)
     */
    public boolean onMenu( int instance ) {
    	//#if !polish.useFullScreen
    		this.ignoreObscureEvent = true;
    		//# return super.onMenu(instance);
    	//#else
            boolean processed = super.onMenu( instance );
            if (processed) {
            	return true;
            }
            Object o = this;
            if (o instanceof Screen) {
                Screen screen = (Screen)o;
                if (!screen.isMenuOpened()) {
                    // unfocus the current item
                    Field nativeFocusedField = super.getFieldWithFocus();
                    if (nativeFocusedField != this.dummyField) {
                        Object lock = MIDlet.getEventLock();
                        synchronized (lock) {
                            setFocus( this.dummyField, 0, 0, 0, 0 );
                            this.menuField = nativeFocusedField;
                        }
                    }
                } else if (this.menuField != null) {
                    Object lock = MIDlet.getEventLock();
                    synchronized (lock) {
                        setFocus( this.menuField, 0, 0, 0, 0 );
                        this.menuField = null;
                    }
                }
            }
            //#if polish.key.LeftSoftKey:defined
                    //#= keyPressed( ${polish.key.LeftSoftKey} );
            		//#= keyReleased( ${polish.key.LeftSoftKey} );
            //#else
            		keyPressed( MENU_KEY );
                    keyReleased( MENU_KEY );
            //#endif
            return true;
        //#endif
    }
    
    //#if !polish.useFullScreen
    
    /* (non-Javadoc)
	 * @see net.rim.device.api.ui.Screen#onMenuDismissed(net.rim.device.api.ui.component.Menu)
	 */
	protected void onMenuDismissed(Menu m) {
		super.onMenuDismissed(m);
		this.ignoreObscureEvent = false;
	}
    //#endif

    /* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#trackwheelRoll(int, int, int)
     */
    protected boolean trackwheelRoll( int amount, int status, int time ) {
    	try {
	        boolean callSuper = false;
	        Screen screen = null;
	        Object o = this;
	        if (o instanceof Screen) {
	            screen = (Screen)o;
	            Item item = screen.getCurrentItem();
	            callSuper = !screen.isMenuOpened() 
	                    && item != null 
	                    && item._bbField != null;
	        }
	        boolean processed = false;
	        if (callSuper) {
	        	try {
	        		processed = super.trackwheelRoll(amount, status, time);
	        		if (processed) {
		        		if (focusChangeDetected(screen)) {
		        			processed = false;
		        		} else {
		                	//#debug
		                    System.out.println("Canvas.trackwheel-roll: super processed the call.");
		        			return true;
		        		}
	        		}
	     	   } catch (Exception e) {
	    		   //#debug error
	    		   System.out.println("super.trackwheelRoll(" + amount + ", " + status + ", " + time + ") failed" + e );        		   
	    	   }
	        	
	        }
            int keyCode;
            if ( amount < 0 ) {
                    amount *= -1;
                    if ( status == TrackwheelListener.STATUS_ALT ) {
                            keyCode = KEY_BB_UP;
                    } else {
                            keyCode = KEY_BB_LEFT;
                    }
            } else {
                    if ( status == TrackwheelListener.STATUS_ALT ) {
                            keyCode = KEY_BB_DOWN;
                    } else {
                            keyCode = KEY_BB_RIGHT;
                    }
            }
            // for loop outcommented, so that only one scroll step within each event is processed
            //for (; --amount >= 0; ) {
                    keyPressed( keyCode );
                    processed |= this.isLastEventProcessed;
                    keyReleased( keyCode );
                    processed |= this.isLastEventProcessed;
            //}
            return processed;
    	} catch (Exception e) {
    		//#debug error
    		System.out.println("error while processing trackwheel roll" + e);
    		return true;
    	}
    }
    

	/**
     * Detects a focus change and focuses the dummy field if a focus change occured.
     * @param screen the J2ME Polish screen
     * @return true when the focus has changed
     */
    private boolean focusChangeDetected(Screen screen) {
    	if (screen != null) {
            Item focusedItem = this.currentItem;
            Field nativeFocusedItem = super.getFieldWithFocus();
            if ( focusedItem != null && focusedItem._bbField != nativeFocusedItem) {
            	//#debug
                System.out.println("Canvas: super event processing changed the focus.");
                setFocus( focusedItem._bbField, focusedItem.getAbsoluteX(), focusedItem.getAbsoluteY(), 0, 0 );                return true;
            }
        }
    	return false;
	}
    
    
/*
	protected boolean keyChar(char c, int arg1, int arg2) {
		boolean processed = super.keyChar(c, arg1, arg2);
		System.out.println("keyChar: char=" + c + ", processed=" + processed);
		return processed;
	}

	protected boolean keyCharUnhandled(char c, int arg1, int arg2) {
		boolean processed = super.keyCharUnhandled(c, arg1, arg2);
		System.out.println("keyCharUnhandled: char=" + c + ", processed=" + processed);
		return processed;
	}
	*/

	/* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#keyDown(int, int)
     */
    protected boolean keyDown(int keyCode, int time) {
    	// note: the BlackBerry JavaDocs say that true is returned, when the event is consumed.
    	// This is correct, but it seems that native components do not return true,
    	// even though they (should have) handled the event. Text entry, for example, works
    	// only ok, when we return false, so that the Blackberry is forwarding the event
    	// to the corresponding consumer. Weird, really. This means that text input seems
    	// to be handled differently from keyDown. And it's not keyChar.
        Screen screen = getPolishScreen();
        //#debug
        System.out.println("keyDown: keyCode=" + keyCode + ", key=" + Keypad.key( keyCode) + ", char=" + Keypad.map( keyCode ) );
        //#if polish.JavaPlatform < BlackBerry/6.0
        keyCode = getMidpKeyCode(keyCode);
        //#endif
        
        if ( screen != null ) {
           if (forwardEventToNativeField( screen, keyCode) 
        		   && (Keypad.map( keyCode ) != Keypad.KEY_ESCAPE))
           {
        	   try {
        		   // if the current item is valid ... 
        		   if(this.currentItem != null) {
        			   int gameAction = getGameAction(keyCode);
        			   // forward the key event to the current item
        			   UiAccess.handleKeyPressed(this.currentItem, keyCode, gameAction);
        		   }
        		   return super.keyDown(keyCode, time);                	   
        	   } catch (Exception e) {
        		   //#debug error
        		   System.out.println("super.keyDown(" + keyCode + ", " + time + ") failed" + e );
        	   }
           }
        }
        keyPressed( keyCode );
        return this.isLastEventProcessed;
    }

	Screen getPolishScreen() {
		Displayable dis = Display.getInstance().getCurrent();
		if (dis instanceof Screen) {
			return (Screen)dis;
		} else {
			return null;
		}
	}

	/**
	 * Translates a BlackBerry key event into a MIDP event
	 * @param keyCode the BlackBerry key
	 * @param status the status of the BlackBerry keyboard
	 * @return the MIDP equivalent of the key event
	 */
	private int getMidpKeyCode(int keyCode)
	{
		int key = Keypad.key( keyCode );
		int status = Keypad.status(keyCode);
        switch ( Keypad.map( key, status ) ) { 
	        case '0': keyCode = Canvas.KEY_NUM0; break;
	        case '1': keyCode = Canvas.KEY_NUM1; break;
	        case '2': keyCode = Canvas.KEY_NUM2; break;
	        case '3': keyCode = Canvas.KEY_NUM3; break;
	        case '4': keyCode = Canvas.KEY_NUM4; break;
	        case '5': keyCode = Canvas.KEY_NUM5; break;
	        case '6': keyCode = Canvas.KEY_NUM6; break;
	        case '7': keyCode = Canvas.KEY_NUM7; break;
	        case '8': keyCode = Canvas.KEY_NUM8; break;
	        case '9': keyCode = Canvas.KEY_NUM9; break;
        }
        return keyCode;
	}
	    

    /**
     * Decides if a key command should be forwarded to the currently focused native BlackBerry field of this screen.
     * @param screen this canvas as a J2ME Polish Screen
     * @param keyCode the blackberry key code
     * @return true when the event should be forwarded
     */
    public boolean forwardEventToNativeField(Screen screen, int keyCode) {
    	boolean forwardEvent = !( 
    			(keyCode == MENU_KEY) 
    			|| (BaseScreenManager.getInstance().getFieldWithFocus() == this.dummyField)
    			//#if !tmp.fullscreen
    			|| screen.isMenuOpened()
    			//#endif
    	);
		return forwardEvent; 
	}

	/* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#keyUp(int, int)
     */ 
	protected boolean keyUp(int keyCode, int time) {
		Screen screen = getPolishScreen();
		 //#debug
    	System.out.println("keyUp: keyCode=" + keyCode + ", key=" + Keypad.key( keyCode) + ", char=" + Keypad.map( keyCode ) );
    	//#if polish.JavaPlatform < BlackBerry/6.0
    	keyCode = getMidpKeyCode(keyCode);
    	//#endif
        if ( screen != null ) {
           if (forwardEventToNativeField( screen, keyCode) 
        		   && (Keypad.map( keyCode ) != Keypad.KEY_ESCAPE))
           {
        	   try {
        		   // if the current item is valid ... 
        		   if(this.currentItem != null) {
        			   int gameAction = getGameAction(keyCode);
        			   // forward the key event to the current item
        			   UiAccess.handleKeyReleased(this.currentItem, keyCode, gameAction);
        		   }
        		   return super.keyUp(keyCode, time);                	   
        	   } catch (Exception e) {
        		   //#debug error
        		   System.out.println("super.keyUp(" + keyCode + ", " + time + ") failed" + e );
        	   }
           }
        }
       
        keyReleased( keyCode );
        if ( screen != null ) {
        	boolean handled = this.isLastEventProcessed; 
    		//#if !tmp.fullscreen
	        	if (!handled && (Keypad.map( keyCode ) == Keypad.KEY_ESCAPE)) {
	        		if (this.addedMenuItems.size() == 1) {
        				CommandMenuItem item = (CommandMenuItem) this.addedMenuItems.get(0);
        				item.run();
        				handled = true;
	        		}
	        	}
        	//#endif
        	return handled;
        } else { 
        	return true; // consume the key event
        } 
   }

	/* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#keyRepeat(int, int)
     */
    protected boolean keyRepeat(int keyCode, int time) {
        Screen screen = getPolishScreen();
        if ( screen != null ) {
           if (forwardEventToNativeField( screen, keyCode) 
        		   && (Keypad.map( keyCode ) != Keypad.KEY_ESCAPE))
           {
        	   try {
        		   return super.keyRepeat(keyCode, time);                	   
        	   } catch (Exception e) {
        		   //#debug error
        		   System.out.println("super.keyRepeat(" + keyCode + ", " + time + ") failed" + e );
        	   }
           }
        }
        //#debug
    	System.out.println("keyRepeat: keyCode=" + keyCode + ", key=" + Keypad.key( keyCode) + ", char=" + Keypad.map( keyCode ) );
    	keyCode = getMidpKeyCode(keyCode);
        keyRepeated(keyCode);
    	return true; // consume the key event
	}
    
    //#if polish.hasPointerEvents
    /**
     * Handles BlackBerry touch events.
     * @param message the touch event
     * @return true when the event was handled
     */
    protected boolean touchEvent(TouchEvent message) {
    	Screen screen = getPolishScreen();
    	boolean isSuperCalled = false;
    	int x = message.getGlobalX(1);
		int y = message.getGlobalY(1);
		int event = message.getEvent();
    	if ( screen != null && forwardEventToNativeField( screen, 0)) {
    		boolean forwardEvent = true;
    		Item item = this.currentItem;
        	Field field = item != null ? item._bbField : null;
        	boolean isTextField = field instanceof PolishTextField; 
        	if (isTextField) {
        		int absX = item.getAbsoluteX();
        		int absY = item.getAbsoluteY();
        		if ( x < absX || y < absY || x > absX + item.itemWidth || y > absY + item.itemHeight) {
        			forwardEvent = false;
        		}
        	}
        	if (forwardEvent) {
        		isSuperCalled = true;
	    		if (super.touchEvent( message ) && !focusChangeDetected(screen) && (!isTextField)) {
	    			return true;
	    		}
        	}
    	}
    	
    	if (event == TouchEvent.MOVE) {
			pointerDragged( x, y );
			invalidate();
			return true;
    	} else 
    	//#if polish.hasPointerEvents && polish.hasTouchEvents
    	if (event == TouchEvent.CLICK) {
			pointerPressed( x, y );
    		return true;
		} else if (event == TouchEvent.UNCLICK) {
			pointerReleased( x, y );
    		return true;
		} else if (event == TouchEvent.UP) {
			if (handlePointerTouchUp(x, y)) {
					invalidate();
					return true;
			} else {
				return false;
			}
		} else if (event == TouchEvent.DOWN) {
			if (handlePointerTouchDown(x, y)) {
				invalidate();
				return true;
			} else {
				return false;
			}
		}
    	//#elif polish.hasPointerEvents && !polish.hasTouchEvents
    	if (event == TouchEvent.DOWN) {
    		pointerPressed( x, y );
    		return true;
		} else if (event == TouchEvent.UP) {
			pointerReleased( x, y );
    		return true;
		}
    	//#endif
		if (isSuperCalled) {
			return false;
		}
    	return super.touchEvent(message);
    }
    //#endif

	
    /**
     * Determines whether this screen is shown
     * 
     * @return true when this screen is currently being shown.
     */
    public boolean isShown() {
    	return super.isDisplayed();
    }

	/**
	 * Notifies this screen about the new item that is focused on BlackBerry platforms.
	 * This is only called for BlackBerry platforms - check for the preprocesing
	 * symbol polish.blackberry.
	 * 
	 * @param item the item that has been focused
	 */
	public void notifyFocusSet( Item item ) {
		notifyFocusSet(item, true);
	}
    
    /**
     * Focuses an item and it's corresponding blackberry field if available.
     * If not native blackberry field is asscociated with the item, the
     * internal dummy item will be focused.
     * 
     * @param item the item that is focused
     * @param repeatSync true when the access should be tried synchronized again when the first trial fails
     */
    public void notifyFocusSet( final Item item, boolean repeatSync ) {
       	if (this.isObscured) {
    		return;
    	}
    	try {
	        if ( item != null && item._bbField != null ) {
	        	this.currentItem = item;
	            if ( !this.addedItems.contains(item) ) {
                    if (item._bbField.getManager() != null) {
                        item._bbField.getManager().delete(item._bbField);
                    }
                    add( item._bbField );
                    this.addedItems.add( item );
                    //System.out.println("Canvas.focus(): adding field " + item._bbField );
                    
	            }
	            if (getFieldWithFocus() != item._bbField) {
	            	setFocus( item._bbField, 0, 0, 0, 0 );
	            	
	            	if (item._bbField instanceof PolishOneLineField)
	            	{
	            		setFocus( ((PolishOneLineField)item._bbField).getEditField(), 0, 0, 0, 0 );
	            	}
	            }
	            //System.out.println("Canvas.focus(): focusing field " + item._bbField );
	            //#if polish.hasPointerEvents
	            	//getVirtualKeyboard().setVisibility( VirtualKeyboard.SHOW );
	            //#endif
	        } else if (BaseScreenManager.getInstance().getFieldWithFocus() != this.dummyField) {
	        	this.currentItem = null;
	            setFocus( this.dummyField, 0, 0, 0, 0 );
	            //System.out.println("Canvas.focus(): focusing dummy");
	        }
    	} catch (IllegalStateException e) {
    		// On Blackberry we need to run the following code on the UI thread
    		// to make sure we get no deadlock between Blackberry lock and lock
    		// on Container.itemsList.
    		if (repeatSync) {
	    		Display.getInstance().callSerially(new Runnable() {
	    			public void run()
	    			{
				            Object lock = MIDlet.getEventLock();
				            synchronized (lock) {
				            	notifyFocusSet(item, false);
				            }
	    			}
	    		});
    		}
    	}
    }
    
	/**
	 * Determines whether a native UI component is shown for the specified item.
	 * This is currently only implemented for BlackBerry platforms - check for the preprocesing
	 * symbol polish.blackberry.
	 * 
	 * @param item the item that has been focused
	 */
	public boolean isNativeUiShownFor( Item item ) {
		return (this.currentItem == item) && !de.enough.polish.ui.StyleSheet.currentScreen.isMenuOpened();
	}

    
	/**
	 * Notifies this screen about an item with a native componen that is removed on BlackBerry platforms.
	 * This is only called for BlackBerry platforms - check for the preprocesing
	 * symbol polish.blackberry.
	 * 
	 * @param item the item with a native component which was displayed all the time.
	 */
	public void removePermanentNativeItem(Item item) {
		BaseScreenManager.getInstance().removePermanentNativeItem(item);
	}

    
    public void addPermanentNativeItem( Item item ) {
    	BaseScreenManager.getInstance().addPermanentNativeItem(item);
    }
    
    public void clearPermanentNativeItems() {
    	BaseScreenManager.getInstance().clearPermanentNativeItems();
    }

    //#if polish.hasTrackballEvents
    /* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#navigationClick(int, int)
     */
    protected boolean navigationClick(int status, int time)
    {
    	// if no valid key event was fired (e.g. in case of a touch event) ...
    	if (status == 0) {
    		// return
    		return true;
    	}
    	
    	boolean processed = super.navigationClick(status, time);
    	if (!processed) {
    		keyPressed( KEY_BB_FIRE );
    		processed = this.isLastEventProcessed;
    	}
    	return processed;
    }
    //#endif
    
    
    
    //#if polish.hasTrackballEvents
    /* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#navigationUnclick(int, int)
     */
    protected boolean navigationUnclick(int status, int time)
    {
    	// if no valid key event was fired (e.g. in case of a touch event) ...
    	if (status == 0) {
    		// return
    		return true;
    	}
    	
    	boolean processed = super.navigationUnclick(status, time);
    	if (!processed) {
    		Screen screenBefore = getPolishScreen();
    		keyReleased(KEY_BB_FIRE );
    		processed = this.isLastEventProcessed;
    		Screen screen = getPolishScreen();
    		if (screen != screenBefore) {
    			processed = true;
			//#if !tmp.fullscreen
    			} else if (!processed && (this.currentItem._bbField != null) && (this.addedMenuItems.size() == 1)) {
    				// native fields get this event afterwards but not from the super implementation,
    				// so we only process the single screen command only when no native field is focused:
    				CommandMenuItem item = (CommandMenuItem) this.addedMenuItems.get(0);
    				item.run();
    				processed = true;
        	//#endif
    		}
    	}
    	return processed;
    }
    //#endif
    
    //#if polish.JavaPlatform >= BlackBerry/6.0
    protected boolean focusChangeNeeded(Field field) {
    	if(field instanceof PolishTextField) {
    		return ((PolishTextField)field).needsNavigationFix();
    	} else {
    		return false;
    	}
    }
    //#endif

    //#if polish.hasTrackballEvents
    /* (non-Javadoc)
     * @see net.rim.device.api.ui.Screen#navigationMovement(int, int, int, int)
     */
    protected boolean navigationMovement(int dx, int dy, int status, int time)
    {
    	boolean processed = false;
        Screen screen = getPolishScreen();
        boolean superImplementationCalled = false;
        if ( screen != null ) {
           if ( !screen.isMenuOpened() 
                   && this.currentItem != null) 
           { 
        	   try {
        		   if (this.currentItem._bbField instanceof AccessibleField) {
        			   processed = ((AccessibleField)this.currentItem._bbField).navigationMovement(dx, dy, status, time);                     
        		   } else if ((status & KeypadListener.STATUS_ALT) == KeypadListener.STATUS_ALT) {
        			   processed = super.navigationMovement(dx, dy, status, time);                     
        		   }
                   if (processed) {
                	   if (focusChangeDetected(screen)
               			   //#if polish.JavaPlatform >= BlackBerry/6.0
                  			|| focusChangeNeeded(this.currentItem._bbField)
                  			//#endif   
                	   		) {
                		   processed = false;
                	   } else {
                		   //#debug 
                		   System.out.println("super implementation handled navigationMovement()");
                		   // possiblyt adjust scrolling:
                		   Item item = this.currentItem;
                		   if (item != null) {
                			   item.updateInternalArea();
                		   }
                		   return true;
                	   }
                   }
                   superImplementationCalled = true;
        	   } catch (Exception e) {
        		   //#debug error
        		   System.out.println("super.navigationMovement(" + dx+ ", " + dy+ ", " + status+ ", " + time + ") failed" + e );
        	   }
           }
        }
        
        int absDx = dx < 0 ? -dx : dx;
        int absDy = dy < 0 ? -dy : dy;
        if (absDx > absDy) {
        	dy = 0;
        } else {
        	dx = 0;
        }
        
        int keyCode = 0;
		// Trackball up.
		if (dy < 0)
		{
			keyCode = BaseScreen.KEY_BB_UP;
		}
		// Trackball down.
		else if (dy > 0)
		{
			keyCode = BaseScreen.KEY_BB_DOWN;
		}
		// Trackball left.
		else if (dx < 0)
		{
			keyCode = BaseScreen.KEY_BB_LEFT;
		}
		// Trackball right.
		else if (dx > 0)
		{
			keyCode = BaseScreen.KEY_BB_RIGHT;
		}
		if (keyCode != 0) {
			keyPressed( keyCode );
			keyReleased( keyCode );
			// when false is returned, the BlackBerry will generate a trackwheelRoll event which we don't want,
			// so true is always returned:
			return true;
//			if ( (Object)this instanceof Screen) {
//				Screen scr = (Screen) (Object) this;
//				return scr.keyPressedProcessed || scr.keyReleasedProcessed;
//			} else {
//				return true;
//			}
		}
    	if (!superImplementationCalled) {
    		processed = super.navigationMovement(dx, dy, status, time);
    	}
		return processed;
    }
    //#endif

	public void notifyDisplayableChange(Displayable currentDisplayable, Displayable nextDisplayable) {
		notifyFocusSet(null);
    	int count = getFieldCount();
    	if (count > 1) {
    		Object lock = Application.getEventLock();
            synchronized (lock) {
            	deleteRange(1, count -1 );
            }
			this.addedItems.clear();
    	} 
    	clearPermanentNativeItems();
        //#if polish.hasPointerEvents
	        if (nextDisplayable instanceof Screen) {
	            Screen screen = (Screen) nextDisplayable;
	            if (screen.getCurrentItem() == null || screen.getCurrentItem()._bbField == null) {
	            	DeviceControl.hideSoftKeyboard();
	            }
	        } else {
            	DeviceControl.hideSoftKeyboard();
	        }
	    //#endif
		//#if !tmp.fullscreen
	    	this.addedMenuItems.clear();
//	    	
//	    	if (nextDisplayable instanceof Canvas) {
//	    		ArrayList commandsList = ((Canvas)nextDisplayable)._commands;
//	    		Object[] commands = commandsList.getInternalArray();
//	    		for (int i = 0; i < commands.length; i++) {
//					Command cmd = (Command) commands[i];
//					if (cmd == null) {
//						break;
//					}
//					if (commandsList.indexOf(cmd) == i) {
//						addCommand( cmd );
//					}
//				}
//	    	}
	    //#endif
	}

	public void addCommand( de.enough.polish.ui.Command cmd ) {
		//#if !tmp.fullscreen
			Object[] items = this.addedMenuItems.getInternalArray();
			for (int i = 0; i < items.length; i++) {
				CommandMenuItem item = (CommandMenuItem) items[i];
				if (item == null) {
					break;
				}
				if (item.cmd == cmd) {
					// ignore this command, it's been added already:
					return;
				}
			}
			CommandMenuItem item = new CommandMenuItem( cmd, Display.getInstance().getNextOrCurrent() );
			this.addedMenuItems.add(item);
		//#endif
	}

	public void removeCommand( de.enough.polish.ui.Command cmd ) {
		//#if !tmp.fullscreen
			Object[] items = this.addedMenuItems.getInternalArray();
			for (int i = 0; i < items.length; i++) {
				CommandMenuItem item = (CommandMenuItem) items[i];
				if (item == null) {
					break;
				}
				if (item.cmd == cmd) {
					this.addedMenuItems.remove(i);
					break;
				}
			}
		//#endif
	}
	
	//#if !tmp.fullscreen
	/* (non-Javadoc)
	 * @see net.rim.device.api.ui.Screen#makeMenu(net.rim.device.api.ui.component.Menu, int)
	 */
	protected void makeMenu(Menu menu, int instance) {
		super.makeMenu(menu, instance);
		Object[] objects = this.addedMenuItems.getInternalArray();
		Arrays.sort(objects, MenuItemComparator.instance );
		for (int i = 0; i < objects.length; i++) {
			CommandMenuItem item = (CommandMenuItem) objects[i];
			if (item == null) {
				break;
			}
			if (item.isSeparator) {
				menu.addSeparator();
			} else if ((instance == 0) || item.isContextMenu()) {
				menu.add(item);
			}
		}
	}	
	//#endif

	//#if !tmp.fullscreen
	/* (non-Javadoc)
	 * @see net.rim.device.api.ui.Field#makeContextMenu(net.rim.device.api.ui.ContextMenu)
	 */
	protected void makeContextMenu(ContextMenu menu) {
		super.makeContextMenu(menu);
		Object[] objects = this.addedMenuItems.getInternalArray();
		for (int i = 0; i < objects.length; i++) {
			CommandMenuItem item = (CommandMenuItem) objects[i];
			if (item == null) {
				break;
			}
			if (item.isContextMenu()) {
				menu.addItem(item);
			}
		}
	}
	//#endif

	//#if tmp.fullscreen || true
	public void setTitle( String title) {
		// ignore
	}
	//#endif

	public void setCommandListener( javax.microedition.lcdui.CommandListener l) {
		// ignore
	}

	public void setIgnoreObscureEvent(boolean ignore) {
		this.ignoreObscureEvent = ignore;
		
	}
    
}

final class MenuItemComparator implements Comparator{
	static MenuItemComparator instance = new MenuItemComparator();

	public int compare(Object o1, Object o2) {
		if(o1 == null) {
			if (o2 == null) {
				return 0;
			}
			return 1;
		} else if (o2 == null) {
			return -1;
		}
		Command c1 = ((CommandMenuItem)o1).cmd;
		Command c2 = ((CommandMenuItem)o2).cmd;
		return c1.getPriority() - c2.getPriority();
	}
}
