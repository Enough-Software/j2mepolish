//#condition polish.javaplatform >= Android/2.0
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Tue Mar 24 10:34:27 EET 2009
package de.enough.polish.android.bluetooth;

import android.bluetooth.BluetoothAdapter;
import de.enough.polish.android.io.Connection;

/**
 * 
 * The <code>LocalDevice</code> class defines the basic functions of the
 * Bluetooth manager.  The
 * Bluetooth manager provides the lowest level of interface possible
 * into the Bluetooth stack.  It provides access to and control of the
 * local Bluetooth device.
 * <p>
 * This class produces a singleton object.
 * 
 * <DD>1.7</DD>
 * <HR>
 * 
 * 
 * <!-- ========== METHOD SUMMARY =========== -->
 * 
 * <A NAME="method_summary"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
 * <B>Method Summary</B></FONT></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;java.lang.String</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getBluetoothAddress()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getBluetoothAddress()">getBluetoothAddress</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the Bluetooth address of the local device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;<A HREF="DeviceClass.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DeviceClass.html" title="class in javax.bluetooth">DeviceClass</A></CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getDeviceClass()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getDeviceClass()">getDeviceClass</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the <code>DeviceClass</code> object that represents the
 * service classes, major device class, and minor device class of the
 * local device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getDiscoverable()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getDiscoverable()">getDiscoverable</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the local device's discoverable mode.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;<A HREF="DiscoveryAgent.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html" title="class in javax.bluetooth">DiscoveryAgent</A></CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getDiscoveryAgent()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getDiscoveryAgent()">getDiscoveryAgent</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the discovery agent for this device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;java.lang.String</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getFriendlyName()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getFriendlyName()">getFriendlyName</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the name of the local device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;<A HREF="LocalDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html" title="class in javax.bluetooth">LocalDevice</A></CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getLocalDevice()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getLocalDevice()">getLocalDevice</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the <code>LocalDevice</code> object for the local Bluetooth
 * device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getProperty(java.lang.String)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getProperty(java.lang.String)">getProperty</A></B>(java.lang.String&nbsp;property)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves Bluetooth system properties.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;<A HREF="ServiceRecord.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html" title="interface in javax.bluetooth">ServiceRecord</A></CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#getRecord(Connection)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getRecord(Connection)">getRecord</A></B>(Connection&nbsp;notifier)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the service record corresponding to a <code>btspp</code>,
 * <code>btl2cap</code>, or <code>btgoep</code> notifier.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#isPowerOn()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#isPowerOn()">isPowerOn</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries the power state of the Bluetooth device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#setDiscoverable(int)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#setDiscoverable(int)">setDiscoverable</A></B>(int&nbsp;mode)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the discoverable mode of the device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;void</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="LocalDevice.html#updateRecord(javax.bluetooth.ServiceRecord)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#updateRecord(javax.bluetooth.ServiceRecord)">updateRecord</A></B>(<A HREF="ServiceRecord.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html" title="interface in javax.bluetooth">ServiceRecord</A>&nbsp;srvRecord)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates the service record in the local SDDB that corresponds
 * to the <code>ServiceRecord</code> parameter.</TD>
 * </TR>
 * </TABLE>
 * &nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
 * <TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
 * </TR>
 * </TABLE>
 * &nbsp;
 * 
 * <!-- ============ METHOD DETAIL ========== -->
 * 
 * <A NAME="method_detail"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
 * <B>Method Detail</B></FONT></TH>
 * </TR>
 * </TABLE>
 * 
 * <A NAME="getLocalDevice()"><!-- --></A><H3>
 * getLocalDevice</H3>
 * <PRE>
 * public static <A HREF="LocalDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html" title="class in javax.bluetooth">LocalDevice</A> <B>getLocalDevice</B>()
 * throws <A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></PRE>
 * <DD>Retrieves the <code>LocalDevice</code> object for the local Bluetooth
 * device. Multiple calls to this method will return the same
 * object. This method will never return <code>null</code>.
 * 
 * <DD><CODE><A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></CODE> - if the Bluetooth system could not be
 * initialized</DL>
 * <HR>
 * 
 * <A NAME="getDiscoveryAgent()"><!-- --></A><H3>
 * getDiscoveryAgent</H3>
 * <PRE>
 * public <A HREF="DiscoveryAgent.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html" title="class in javax.bluetooth">DiscoveryAgent</A> <B>getDiscoveryAgent</B>()</PRE>
 * <DD>Returns the discovery agent for this device.  Multiple calls
 * to this method will return the same object.  This method will
 * never return <code>null</code>.
 * 
 * <HR>
 * 
 * <A NAME="getFriendlyName()"><!-- --></A><H3>
 * getFriendlyName</H3>
 * <PRE>
 * public java.lang.String <B>getFriendlyName</B>()</PRE>
 * <DD>Retrieves the name of the local device.  The Bluetooth
 * specification calls this name the "Bluetooth device name" or the
 * "user-friendly name".
 * 
 * name could not be retrieved</DL>
 * <HR>
 * 
 * <A NAME="getDeviceClass()"><!-- --></A><H3>
 * getDeviceClass</H3>
 * <PRE>
 * public <A HREF="DeviceClass.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DeviceClass.html" title="class in javax.bluetooth">DeviceClass</A> <B>getDeviceClass</B>()</PRE>
 * <DD>Retrieves the <code>DeviceClass</code> object that represents the
 * service classes, major device class, and minor device class of the
 * local device.  This method will return <code>null</code> if the
 * service classes, major device class, or minor device class could not
 * be determined.
 * 
 * class of the local device, or <code>null</code> if the service
 * classes, major device class or minor device class could not be
 * determined</DL>
 * <HR>
 * 
 * <A NAME="getProperty(java.lang.String)"><!-- --></A><H3>
 * getProperty</H3>
 * <PRE>
 * public static java.lang.String <B>getProperty</B>(java.lang.String&nbsp;property)</PRE>
 * <DD>Retrieves Bluetooth system properties.  The following properties
 * must be supported, but additional values are allowed:
 * <TABLE>
 * <TR><TH>Property Name</TH><TH>Description</TH></TR>
 * <TR><TD>bluetooth.api.version</TD><TD>The version of the Java
 * API for Bluetooth wireless technology that is supported. For this
 * version it will be set to "1.0".</TD></TR>
 * <TR><TD>bluetooth.master.switch</TD><TD>Is master/slave switch
 * allowed?
 * Valid values are either "true" or "false".</TD></TR>
 * <TR><TD>bluetooth.sd.attr.retrievable.max</TD><TD>Maximum number of
 * service attributes to be retrieved per service record. The string
 * will be in Base 10 digits.</TD></TR>
 * <TR><TD>bluetooth.connected.devices.max</TD><TD>The maximum number
 * of connected devices supported. This number may be greater than 7 if
 * the implementation handles parked connections.  The string will be
 * in Base 10 digits. </TD></TR>
 * <TR><TD>bluetooth.l2cap.receiveMTU.max</TD><TD>The maximum ReceiveMTU
 * size in bytes supported in L2CAP. The string will be in Base 10
 * digits, e.g. "32".</TD></TR>
 * <TR><TD>bluetooth.sd.trans.max</TD><TD>Maximum
 * number of concurrent service discovery transactions. The string
 * will be in Base 10 digits. </TD></TR>
 * <TR><TD>bluetooth.connected.inquiry.scan</TD><TD>Is Inquiry scanning
 * allowed
 * during connection? Valid values are either "true" or "false".</TD></TR>
 * <TR><TD>bluetooth.connected.page.scan</TD><TD>Is Page
 * scanning allowed during connection? Valid values are either "true"
 * or "false".</TD></TR>
 * <TR><TD>bluetooth.connected.inquiry</TD><TD>Is Inquiry allowed during a
 * connection?  Valid values are either "true" or "false".</TD></TR>
 * <TR><TD>bluetooth.connected.page</TD><TD>Is paging allowed during a
 * connection?  In other words, can a connection be established to one
 * device if it is already connected to another device.  Valid values are
 * either "true" or "false".</TD></TR>
 * </TABLE>
 * the <code>property</code> is not defined</DL>
 * <HR>
 * 
 * <A NAME="getDiscoverable()"><!-- --></A><H3>
 * getDiscoverable</H3>
 * <PRE>
 * public int <B>getDiscoverable</B>()</PRE>
 * <DD>Retrieves the local device's discoverable mode.  The return value
 * will be <code>DiscoveryAgent.GIAC</code>,
 * <code>DiscoveryAgent.LIAC</code>,
 * <code>DiscoveryAgent.NOT_DISCOVERABLE</code>, or a value in the
 * range 0x9E8B00 to 0x9E8B3F.
 * 
 * <A HREF="DiscoveryAgent.html#LIAC" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#LIAC"><CODE>DiscoveryAgent.LIAC</CODE></A>,
 * <A HREF="DiscoveryAgent.html#NOT_DISCOVERABLE" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#NOT_DISCOVERABLE"><CODE>DiscoveryAgent.NOT_DISCOVERABLE</CODE></A>,
 * <A HREF="LocalDevice.html#setDiscoverable(int)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#setDiscoverable(int)"><CODE>setDiscoverable(int)</CODE></A></DL>
 * <HR>
 * 
 * <A NAME="getBluetoothAddress()"><!-- --></A><H3>
 * getBluetoothAddress</H3>
 * <PRE>
 * public java.lang.String <B>getBluetoothAddress</B>()</PRE>
 * <DD>Retrieves the Bluetooth address of the local device.  The
 * Bluetooth address will never be <code>null</code>.  The Bluetooth address
 * will be 12 characters long.  Valid characters are 0-9 and A-F.
 * 
 * <HR>
 * 
 * <A NAME="setDiscoverable(int)"><!-- --></A><H3>
 * setDiscoverable</H3>
 * <PRE>
 * public boolean <B>setDiscoverable</B>(int&nbsp;mode)
 * throws <A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></PRE>
 * <DD>Sets the discoverable mode of the device.  The <code>mode</code> may be
 * any number in the range 0x9E8B00 to 0x9E8B3F as defined by the Bluetooth
 * Assigned Numbers Document.  When this specification was defined, only
 * GIAC (<code>DiscoveryAgent.GIAC</code>) and
 * LIAC (<code>DiscoveryAgent.LIAC</code>) were defined, but Bluetooth
 * profiles
 * may add additional access codes in the future.  To determine what values
 * may be used, check the Bluetooth Assigned Numbers document at
 * <A HREF="http://www.bluetooth.org/assigned-numbers/baseband.htm">
 * http://www.bluetooth.org/assigned-numbers/baseband.htm</A>.  If
 * <code>DiscoveryAgent.GIAC</code> or <code>DiscoveryAgent.LIAC</code> are
 * provided, then this method will attempt to put the device into general or
 * limited discoverable mode, respectively.  To take a device out of
 * discoverable mode, provide the
 * <code>DiscoveryAgent.NOT_DISCOVERABLE</code> flag.  The BCC decides if
 * the request will be granted.  In addition to the BCC, the Bluetooth
 * system could effect the discoverability of a device.
 * <p>
 * According to the Bluetooth Specification, a device should only be
 * limited discoverable (<code>DiscoveryAgent.LIAC</code>) for 1 minute.
 * This is handled by the implementation of the API.  After the minute is
 * up, the device will revert back to the previous discoverable mode.
 * <code>DiscoveryAgent.GIAC</code>, <code>DiscoveryAgent.LIAC</code>,
 * <code>DiscoveryAgent.NOT_DISCOVERABLE</code> and any value in the
 * range 0x9E8B00 to 0x9E8B3F
 * <code>false</code> if the request failed because the BCC denied
 * the request; <code>false</code> if the Bluetooth system does not
 * support the access mode specified in <code>mode</code>
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>mode</code> is
 * not <code>DiscoveryAgent.GIAC</code>, <code>DiscoveryAgent.LIAC</code>,
 * <code>DiscoveryAgent.NOT_DISCOVERABLE</code>, or in the range
 * 0x9E8B00 to 0x9E8B3F
 * <DD><CODE><A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></CODE> - if the Bluetooth system is in
 * a state that does not allow the discoverable mode to be changed<DT><B>See Also:</B><DD><A HREF="DiscoveryAgent.html#GIAC" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#GIAC"><CODE>DiscoveryAgent.GIAC</CODE></A>,
 * <A HREF="DiscoveryAgent.html#LIAC" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#LIAC"><CODE>DiscoveryAgent.LIAC</CODE></A>,
 * <A HREF="DiscoveryAgent.html#NOT_DISCOVERABLE" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#NOT_DISCOVERABLE"><CODE>DiscoveryAgent.NOT_DISCOVERABLE</CODE></A>,
 * <A HREF="LocalDevice.html#getDiscoverable()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html#getDiscoverable()"><CODE>getDiscoverable()</CODE></A></DL>
 * <HR>
 * 
 * <A NAME="getRecord(Connection)"><!-- --></A><H3>
 * getRecord</H3>
 * <PRE>
 * public <A HREF="ServiceRecord.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html" title="interface in javax.bluetooth">ServiceRecord</A> <B>getRecord</B>(Connection&nbsp;notifier)</PRE>
 * <DD>Gets the service record corresponding to a <code>btspp</code>,
 * <code>btl2cap</code>, or <code>btgoep</code> notifier.  In the
 * case of a run-before-connect service, the service record
 * returned by <code>getRecord()</code> was created by the same
 * call to <code>Connector.open()</code> that created the
 * <code>notifier</code>.
 * 
 * <p> If a connect-anytime server application does not already
 * have a service record in the SDDB, either because a service
 * record for this service was never added to the SDDB or because
 * the service record was added and then removed, then the
 * <code>ServiceRecord</code> returned by <code>getRecord()</code>
 * was created by the same call to <code>Connector.open()</code>
 * that created the notifier.
 * <p> In the case of a connect-anytime service, there may be a
 * service record in the SDDB corresponding to this service prior
 * to application startup.  In this case, the
 * <code>getRecord()</code> method must return a
 * <code>ServiceRecord</code> whose contents match those of the
 * corresponding service record in the SDDB.  If a connect-anytime
 * server application made changes previously to its service record
 * in the SDDB (for example, during a previous execution of the
 * server), and that service record is still in the SDDB, then
 * those changes must be reflected in the
 * <code>ServiceRecord</code> returned by <code>getRecord()</code>.
 * 
 * <p> Two invocations of this method with the same
 * <code>notifier</code> argument return objects that describe the
 * same service attributes, but the return values may be different
 * object references.
 * to a Bluetooth service
 * <code>notifier</code>
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>notifier</code> is
 * closed, or if <code>notifier</code> does not implement one of
 * the following interfaces:
 * <code>javax.microedition.io.StreamConnectionNotifier</code>,
 * <code>javax.bluetooth.L2CapConnectionNotifier</code>, or
 * <code>javax.obex.SessionNotifier</code>.  This exception is
 * also thrown if <code>notifier</code> is not a Bluetooth
 * notifier, e.g., a <code>StreamConnectionNotifier</code> created
 * with a scheme other than <code>btspp</code>.
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>notifier</code> is
 * <code>null</code></DL>
 * <HR>
 * 
 * <A NAME="updateRecord(javax.bluetooth.ServiceRecord)"><!-- --></A><H3>
 * updateRecord</H3>
 * <PRE>
 * public void <B>updateRecord</B>(<A HREF="ServiceRecord.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html" title="interface in javax.bluetooth">ServiceRecord</A>&nbsp;srvRecord)
 * throws <A HREF="ServiceRegistrationException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRegistrationException.html" title="class in javax.bluetooth">ServiceRegistrationException</A></PRE>
 * <DD>Updates the service record in the local SDDB that corresponds
 * to the <code>ServiceRecord</code> parameter.  Updating is
 * possible only if <code>srvRecord</code> was obtained using the
 * <code>getRecord()</code> method. The service record in the SDDB
 * is modified to have the same service attributes with the same
 * contents as <code>srvRecord</code>.
 * <p>
 * If <code>srvRecord</code> was obtained from the SDDB of a
 * remote device using the service search methods, updating is not
 * possible and this method will throw an
 * <code>IllegalArgumentException</code>.
 * <p>
 * If the <code>srvRecord</code> parameter is a <code>btspp</code>
 * service record, then before the SDDB is changed the following
 * checks are performed. If any of these checks fail, then an
 * <code>IllegalArgumentException</code> is thrown.
 * <UL>
 * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory
 * service attributes for a <code>btspp</code> service record, must
 * be present in <code>srvRecord</code>.
 * <LI>L2CAP and RFCOMM must be in the ProtocolDescriptorList.
 * <LI><code>srvRecord</code> must not have changed the RFCOMM server
 * channel number from the channel number that is currently in the
 * SDDB version of this service record.
 * </UL>
 * <p>
 * If the <code>srvRecord</code> parameter is a <code>btl2cap</code>
 * service record, then before the SDDB is changed the following
 * checks are performed. If any of these checks fail, then an
 * <code>IllegalArgumentException</code> is thrown.
 * <UL>
 * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory
 * service attributes for a <code>btl2cap</code> service record,
 * must be present in <code>srvRecord</code>.
 * <LI>L2CAP must be in the ProtocolDescriptorList.
 * <LI><code>srvRecord</code> must not have changed the PSM value
 * from the PSM value that is currently in the SDDB version of this
 * service record.
 * </UL>
 * <p>
 * If the <code>srvRecord</code> parameter is a <code>btgoep</code>
 * service record, then before the SDDB is changed the following
 * checks are performed. If any of these checks fail, then an
 * <code>IllegalArgumentException</code> is thrown.
 * <UL>
 * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory
 * service attributes for a <code>btgoep</code> service record, must
 * be present in <code>srvRecord</code>.
 * <LI>L2CAP, RFCOMM and OBEX must all be in the
 * ProtocolDescriptorList.
 * <LI><code>srvRecord</code> must not have changed the RFCOMM server
 * channel number from the channel number that is currently in the
 * SDDB version of this service record.
 * </UL>
 * <p>
 * <code>updateRecord()</code> is not required to ensure that
 * <code>srvRecord</code> is a completely valid service record. It
 * is the responsibility of the application to ensure that
 * <code>srvRecord</code> follows all of the applicable syntactic
 * and semantic rules for service record correctness.
 * <p>
 * If there is currently no SDDB version of the
 * <code>srvRecord</code> service record, then this method will do
 * nothing.
 * the SDDB
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>srvRecord</code> is
 * <code>null</code>
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if the structure of the
 * <code>srvRecord</code> is  missing any mandatory service
 * attributes, or if an attempt has been made to change any of the
 * values described as fixed.
 * <DD><CODE><A HREF="ServiceRegistrationException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRegistrationException.html" title="class in javax.bluetooth">ServiceRegistrationException</A></CODE> - if the local SDDB could
 * not be updated successfully due to
 * insufficient disk space, database locks, etc.</DL>
 * <HR>
 * 
 * <A NAME="isPowerOn()"><!-- --></A><H3>
 * isPowerOn</H3>
 * <PRE>
 * public static boolean <B>isPowerOn</B>()</PRE>
 * <DD>Queries the power state of the Bluetooth device.
 * 
 * <code>false</code> otherwise.</DL>
 * <!-- ========= END OF CLASS DATA ========= -->
 * <HR>
 * 
 * 
 * <!-- ======= START OF BOTTOM NAVBAR ====== -->
 * <A NAME="navbar_bottom"><!-- --></A>
 * <A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
 * <TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
 * <TR>
 * <TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
 * <A NAME="navbar_bottom_firstrow"><!-- --></A>
 * <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
 * <TR ALIGN="center" VALIGN="top">
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
 * </TR>
 * </TABLE>
 * </TD>
 * <TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
 * <b>JSR 82</b></EM>
 * </TD>
 * </TR>
 * 
 * <TR>
 * <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 * &nbsp;<A HREF="L2CAPConnectionNotifier.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/L2CAPConnectionNotifier.html" title="interface in javax.bluetooth"><B>PREV CLASS</B></A>&nbsp;
 * &nbsp;<A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" title="class in javax.bluetooth"><B>NEXT CLASS</B></A></FONT></TD>
 * <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 * <A HREF="../../index.html-javax-bluetooth-LocalDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/index.html?javax/bluetooth/LocalDevice.html" target="_top"><B>FRAMES</B></A>  &nbsp;
 * &nbsp;<A HREF="LocalDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
 * &nbsp;<SCRIPT type="text/javascript">
 * <!--
 * if(window==top) {
 * document.writeln('<A HREF="../../allclasses-noframe.html"/tpa=http://java.sun.com/javame/reference/apis/jsr082/allclasses-noframe.html/><B>All Classes</B></A>');
 * }
 * //-->
 * </SCRIPT>
 * <NOSCRIPT>
 * <A HREF="../../allclasses-noframe.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/allclasses-noframe.html"><B>All Classes</B></A>
 * </NOSCRIPT>
 * 
 * 
 * </FONT></TD>
 * </TR>
 * <TR>
 * <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
 * SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
 * <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
 * DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
 * </TR>
 * </TABLE>
 * <A NAME="skip-navbar_bottom"></A>
 * <!-- ======== END OF BOTTOM NAVBAR ======= -->
 * 
 * <HR>
 * <small>Copyright (c) 2006 Sun Microsystems, Inc. All rights reserved. <b>Use is subject to <a href="http://java.sun.com/javame/reference/apis/license.html" target="_top">License Terms</a>.</b> Your use of this web site or any of its content or software indicates your agreement to be bound by these License Terms.<br><br>For more information, please consult the <a href="http://jcp.org/en/jsr/detail?id=82" target="_top">JSR 82 specification.</a></small>
 * </BODY>
 * <script language="JavaScript" src="../../../../../../js/omi/jsc/s_code_remote.js" tppabs="http://java.sun.com/js/omi/jsc/s_code_remote.js"></script></HTML>
 * 
 */
public class LocalDevice extends java.lang.Object
{
	//following variables are implicitely defined by getter- or setter-methods:
	private static LocalDevice instance;
	private DiscoveryAgent discoveryAgent;
	private String friendlyName;
	private DeviceClass deviceClass;
	private int discoverable;

	private LocalDevice() {
		// Hidden.
	}
	
	/**
	 * Retrieves the <code>LocalDevice</code> object for the local Bluetooth
	 * device. Multiple calls to this method will return the same
	 * object. This method will never return <code>null</code>.
	 * <P>
	 * 
	 * 
	 * @return an object that represents the local Bluetooth device
	 * @throws BluetoothStateException - if the Bluetooth system could not be initialized
	 */
	public static LocalDevice getLocalDevice() throws BluetoothStateException{
		if(instance == null) {
			instance = new LocalDevice();
		}
		return instance;
	}

	/**
	 * Returns the discovery agent for this device.  Multiple calls
	 * to this method will return the same object.  This method will
	 * never return <code>null</code>.
	 * <P>
	 * 
	 * 
	 * @return the discovery agent for the local device
	 */
	public DiscoveryAgent getDiscoveryAgent(){
		if(this.discoveryAgent == null) {
			this.discoveryAgent = new DiscoveryAgent();
		}
		return this.discoveryAgent;
	}

	/**
	 * Retrieves the name of the local device.  The Bluetooth
	 * specification calls this name the "Bluetooth device name" or the
	 * "user-friendly name".
	 * <P>
	 * 
	 * 
	 * @return the name of the local device; null if the name could not be retrieved
	 */
	public java.lang.String getFriendlyName(){
		BluetoothAdapter defaultAdapter = BluetoothAdapter.getDefaultAdapter();
		if(defaultAdapter != null) {
			return defaultAdapter.getName();
		}
		return null;
	}

	/**
	 * Retrieves the <code>DeviceClass</code> object that represents the
	 * service classes, major device class, and minor device class of the
	 * local device.  This method will return <code>null</code> if the
	 * service classes, major device class, or minor device class could not
	 * be determined.
	 * <P>
	 * 
	 * 
	 * @return the service classes, major device class, and minor device class of the local device, or null if the service classes, major device class or minor device class could not be determined
	 */
	public DeviceClass getDeviceClass()
	{
		return this.deviceClass;
	}

	/**
	 * Retrieves Bluetooth system properties.  The following properties
	 * must be supported, but additional values are allowed:
	 * <TABLE>
	 * <TR><TH>Property Name</TH><TH>Description</TH></TR>
	 * <TR><TD>bluetooth.api.version</TD><TD>The version of the Java
	 * API for Bluetooth wireless technology that is supported. For this
	 * version it will be set to "1.0".</TD></TR>
	 * <TR><TD>bluetooth.master.switch</TD><TD>Is master/slave switch
	 * allowed?
	 * Valid values are either "true" or "false".</TD></TR>
	 * <TR><TD>bluetooth.sd.attr.retrievable.max</TD><TD>Maximum number of
	 * service attributes to be retrieved per service record. The string
	 * will be in Base 10 digits.</TD></TR>
	 * <TR><TD>bluetooth.connected.devices.max</TD><TD>The maximum number
	 * of connected devices supported. This number may be greater than 7 if
	 * the implementation handles parked connections.  The string will be
	 * in Base 10 digits. </TD></TR>
	 * <TR><TD>bluetooth.l2cap.receiveMTU.max</TD><TD>The maximum ReceiveMTU
	 * size in bytes supported in L2CAP. The string will be in Base 10
	 * digits, e.g. "32".</TD></TR>
	 * <TR><TD>bluetooth.sd.trans.max</TD><TD>Maximum
	 * number of concurrent service discovery transactions. The string
	 * will be in Base 10 digits. </TD></TR>
	 * <TR><TD>bluetooth.connected.inquiry.scan</TD><TD>Is Inquiry scanning
	 * allowed
	 * during connection? Valid values are either "true" or "false".</TD></TR>
	 * <TR><TD>bluetooth.connected.page.scan</TD><TD>Is Page
	 * scanning allowed during connection? Valid values are either "true"
	 * or "false".</TD></TR>
	 * <TR><TD>bluetooth.connected.inquiry</TD><TD>Is Inquiry allowed during a
	 * connection?  Valid values are either "true" or "false".</TD></TR>
	 * <TR><TD>bluetooth.connected.page</TD><TD>Is paging allowed during a
	 * connection?  In other words, can a connection be established to one
	 * device if it is already connected to another device.  Valid values are
	 * either "true" or "false".</TD></TR>
	 * </TABLE>
	 * <P>
	 * 
	 * @param property - the property to retrieve as defined in this class.
	 * @return the value of the property specified; null if the property is not defined
	 */
	public static java.lang.String getProperty(java.lang.String property)
	{
		return null;
		//TODO implement getProperty
	}

	/**
	 * Retrieves the local device's discoverable mode.  The return value
	 * will be <code>DiscoveryAgent.GIAC</code>,
	 * <code>DiscoveryAgent.LIAC</code>,
	 * <code>DiscoveryAgent.NOT_DISCOVERABLE</code>, or a value in the
	 * range 0x9E8B00 to 0x9E8B3F.
	 * <P>
	 * 
	 * 
	 * @return the discoverable mode the device is presently in
	 * @see DiscoveryAgent#GIAC
	 * @see DiscoveryAgent#LIAC
	 * @see DiscoveryAgent#NOT_DISCOVERABLE
	 * @see #setDiscoverable(int)
	 */
	public int getDiscoverable()
	{
		return this.discoverable;
	}

	/**
	 * Retrieves the Bluetooth address of the local device.  The
	 * Bluetooth address will never be <code>null</code>.  The Bluetooth address
	 * will be 12 characters long.  Valid characters are 0-9 and A-F.
	 * <P>
	 * 
	 * 
	 * @return the Bluetooth address of the local device. Returns the empty string when bluetooth is not available.
	 */
	public String getBluetoothAddress(){
		BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
		if(adapter != null) {
			return adapter.getAddress();
		}
		return "";
	}

	/**
	 * Sets the discoverable mode of the device.  The <code>mode</code> may be
	 * any number in the range 0x9E8B00 to 0x9E8B3F as defined by the Bluetooth
	 * Assigned Numbers Document.  When this specification was defined, only
	 * GIAC (<code>DiscoveryAgent.GIAC</code>) and
	 * LIAC (<code>DiscoveryAgent.LIAC</code>) were defined, but Bluetooth
	 * profiles
	 * may add additional access codes in the future.  To determine what values
	 * may be used, check the Bluetooth Assigned Numbers document at
	 * <A HREF="http://www.bluetooth.org/assigned-numbers/baseband.htm">
	 * http://www.bluetooth.org/assigned-numbers/baseband.htm</A>.  If
	 * <code>DiscoveryAgent.GIAC</code> or <code>DiscoveryAgent.LIAC</code> are
	 * provided, then this method will attempt to put the device into general or
	 * limited discoverable mode, respectively.  To take a device out of
	 * discoverable mode, provide the
	 * <code>DiscoveryAgent.NOT_DISCOVERABLE</code> flag.  The BCC decides if
	 * the request will be granted.  In addition to the BCC, the Bluetooth
	 * system could effect the discoverability of a device.
	 * <p>
	 * According to the Bluetooth Specification, a device should only be
	 * limited discoverable (<code>DiscoveryAgent.LIAC</code>) for 1 minute.
	 * This is handled by the implementation of the API.  After the minute is
	 * up, the device will revert back to the previous discoverable mode.
	 * <P>
	 * 
	 * @param mode - the mode the device should be in; valid modes are DiscoveryAgent.GIAC, DiscoveryAgent.LIAC, DiscoveryAgent.NOT_DISCOVERABLE and any value in the range 0x9E8B00 to 0x9E8B3F
	 * @return true if the request succeeded, otherwise false if the request failed because the BCC denied the request; false if the Bluetooth system does not support the access mode specified in mode
	 * @throws java.lang.IllegalArgumentException - if the mode is not DiscoveryAgent.GIAC, DiscoveryAgent.LIAC, DiscoveryAgent.NOT_DISCOVERABLE, or in the range 0x9E8B00 to 0x9E8B3F
	 * @throws BluetoothStateException - if the Bluetooth system is in a state that does not allow the discoverable mode to be changed
	 * @see DiscoveryAgent#GIAC
	 * @see DiscoveryAgent#LIAC
	 * @see DiscoveryAgent#NOT_DISCOVERABLE
	 * @see #getDiscoverable()
	 */
	public boolean setDiscoverable(int mode) throws BluetoothStateException
	{
		return false;
		//TODO implement setDiscoverable
	}

	/**
	 * Gets the service record corresponding to a <code>btspp</code>,
	 * <code>btl2cap</code>, or <code>btgoep</code> notifier.  In the
	 * case of a run-before-connect service, the service record
	 * returned by <code>getRecord()</code> was created by the same
	 * call to <code>Connector.open()</code> that created the
	 * <code>notifier</code>.
	 * 
	 * <p> If a connect-anytime server application does not already
	 * have a service record in the SDDB, either because a service
	 * record for this service was never added to the SDDB or because
	 * the service record was added and then removed, then the
	 * <code>ServiceRecord</code> returned by <code>getRecord()</code>
	 * was created by the same call to <code>Connector.open()</code>
	 * that created the notifier.
	 * <p> In the case of a connect-anytime service, there may be a
	 * service record in the SDDB corresponding to this service prior
	 * to application startup.  In this case, the
	 * <code>getRecord()</code> method must return a
	 * <code>ServiceRecord</code> whose contents match those of the
	 * corresponding service record in the SDDB.  If a connect-anytime
	 * server application made changes previously to its service record
	 * in the SDDB (for example, during a previous execution of the
	 * server), and that service record is still in the SDDB, then
	 * those changes must be reflected in the
	 * <code>ServiceRecord</code> returned by <code>getRecord()</code>.
	 * 
	 * <p> Two invocations of this method with the same
	 * <code>notifier</code> argument return objects that describe the
	 * same service attributes, but the return values may be different
	 * object references.
	 * <P>
	 * 
	 * @param notifier - a connection that waits for clients to connect to a Bluetooth service
	 * @return the ServiceRecord associated with notifier
	 * @throws java.lang.IllegalArgumentException - if notifier is closed, or if notifier does not implement one of the following interfaces: javax.microedition.io.StreamConnectionNotifier, javax.bluetooth.L2CapConnectionNotifier, or javax.obex.SessionNotifier.  This exception is also thrown if notifier is not a Bluetooth notifier, e.g., a StreamConnectionNotifier created with a scheme other than btspp.
	 * @throws java.lang.NullPointerException - if notifier is null
	 */
	public ServiceRecord getRecord(Connection notifier)
	{
		return null;
		//TODO implement getRecord
	}

	/**
	 * Updates the service record in the local SDDB that corresponds
	 * to the <code>ServiceRecord</code> parameter.  Updating is
	 * possible only if <code>srvRecord</code> was obtained using the
	 * <code>getRecord()</code> method. The service record in the SDDB
	 * is modified to have the same service attributes with the same
	 * contents as <code>srvRecord</code>.
	 * <p>
	 * If <code>srvRecord</code> was obtained from the SDDB of a
	 * remote device using the service search methods, updating is not
	 * possible and this method will throw an
	 * <code>IllegalArgumentException</code>.
	 * <p>
	 * If the <code>srvRecord</code> parameter is a <code>btspp</code>
	 * service record, then before the SDDB is changed the following
	 * checks are performed. If any of these checks fail, then an
	 * <code>IllegalArgumentException</code> is thrown.
	 * <UL>
	 * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory
	 * service attributes for a <code>btspp</code> service record, must
	 * be present in <code>srvRecord</code>.
	 * <LI>L2CAP and RFCOMM must be in the ProtocolDescriptorList.
	 * <LI><code>srvRecord</code> must not have changed the RFCOMM server
	 * channel number from the channel number that is currently in the
	 * SDDB version of this service record.
	 * </UL>
	 * <p>
	 * If the <code>srvRecord</code> parameter is a <code>btl2cap</code>
	 * service record, then before the SDDB is changed the following
	 * checks are performed. If any of these checks fail, then an
	 * <code>IllegalArgumentException</code> is thrown.
	 * <UL>
	 * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory
	 * service attributes for a <code>btl2cap</code> service record,
	 * must be present in <code>srvRecord</code>.
	 * <LI>L2CAP must be in the ProtocolDescriptorList.
	 * <LI><code>srvRecord</code> must not have changed the PSM value
	 * from the PSM value that is currently in the SDDB version of this
	 * service record.
	 * </UL>
	 * <p>
	 * If the <code>srvRecord</code> parameter is a <code>btgoep</code>
	 * service record, then before the SDDB is changed the following
	 * checks are performed. If any of these checks fail, then an
	 * <code>IllegalArgumentException</code> is thrown.
	 * <UL>
	 * <LI>ServiceClassIDList and ProtocolDescriptorList, the mandatory
	 * service attributes for a <code>btgoep</code> service record, must
	 * be present in <code>srvRecord</code>.
	 * <LI>L2CAP, RFCOMM and OBEX must all be in the
	 * ProtocolDescriptorList.
	 * <LI><code>srvRecord</code> must not have changed the RFCOMM server
	 * channel number from the channel number that is currently in the
	 * SDDB version of this service record.
	 * </UL>
	 * <p>
	 * <code>updateRecord()</code> is not required to ensure that
	 * <code>srvRecord</code> is a completely valid service record. It
	 * is the responsibility of the application to ensure that
	 * <code>srvRecord</code> follows all of the applicable syntactic
	 * and semantic rules for service record correctness.
	 * <p>
	 * If there is currently no SDDB version of the
	 * <code>srvRecord</code> service record, then this method will do
	 * nothing.
	 * <P>
	 * 
	 * @param srvRecord - the new contents to use for the service record in the SDDB
	 * @throws java.lang.NullPointerException - if srvRecord is null
	 * @throws java.lang.IllegalArgumentException - if the structure of the srvRecord is  missing any mandatory service attributes, or if an attempt has been made to change any of the values described as fixed.
	 * @throws ServiceRegistrationException - if the local SDDB could not be updated successfully due to insufficient disk space, database locks, etc.
	 */
	public void updateRecord( ServiceRecord srvRecord) throws ServiceRegistrationException
	{
		//TODO implement updateRecord
	}

	/**
	 * Queries the power state of the Bluetooth device.
	 * <P>
	 * 
	 * 
	 * @return true is the Bluetooth device is on, false otherwise.
	 */
	public static boolean isPowerOn()
	{
		return false;
		//TODO implement isPowerOn
	}

}
