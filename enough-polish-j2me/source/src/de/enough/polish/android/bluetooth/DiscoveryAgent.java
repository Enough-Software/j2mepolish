//#condition polish.javaplatform >= Android/2.0
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Tue Mar 24 10:34:27 EET 2009
package de.enough.polish.android.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;

/**
 * 
 * The <code>DiscoveryAgent</code> class provides methods to perform
 * device and service discovery.  A local device must have only one
 * <code>DiscoveryAgent</code> object.  This object must be retrieved
 * by a call to <code>getDiscoveryAgent()</code> on the
 * <code>LocalDevice</code> object.
 * 
 * <H3>Device Discovery</H3>
 * 
 * There are two ways to discover devices.  First, an application may
 * use <code>startInquiry()</code> to start an inquiry to find devices
 * in proximity to the local device. Discovered devices are returned
 * via the <code>deviceDiscovered()</code> method of the interface
 * <code>DiscoveryListener</code>.  The second way to
 * discover devices is via the <code>retrieveDevices()</code> method.
 * This method will return devices that have been discovered via a
 * previous inquiry or devices that are classified as pre-known.
 * (Pre-known devices are those devices that are defined in the
 * Bluetooth Control Center as devices this device frequently contacts.)
 * The <code>retrieveDevices()</code> method does not perform an
 * inquiry, but provides a quick way to get a list of devices that may
 * be in the area.
 * 
 * <H3>Service Discovery</H3>
 * The <code>DiscoveryAgent</code> class also encapsulates the
 * functionality provided by the service discovery application profile.
 * The class provides an interface for an application to search and
 * retrieve attributes for a particular service.  There are two ways to
 * search for services.  To search for a service on a single device,
 * the <code>searchServices()</code> method should be used.  On the
 * other hand, if you don't care which device a service is on, the
 * <code>selectService()</code> method does a service search on a
 * set of remote devices.
 * 
 * <DD>1.5</DD>
 * <HR>
 * 
 * <!-- =========== FIELD SUMMARY =========== -->
 * 
 * <A NAME="field_summary"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
 * <B>Field Summary</B></FONT></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#CACHED" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#CACHED">CACHED</A></B></CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used with the <code>retrieveDevices()</code> method to return
 * those devices that were found via a previous inquiry.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#GIAC" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#GIAC">GIAC</A></B></CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The inquiry access code for General/Unlimited Inquiry Access Code
 * (GIAC).</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#LIAC" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#LIAC">LIAC</A></B></CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The inquiry access code for Limited Dedicated Inquiry Access Code
 * (LIAC).</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#NOT_DISCOVERABLE" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#NOT_DISCOVERABLE">NOT_DISCOVERABLE</A></B></CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Takes the device out of discoverable mode.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#PREKNOWN" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#PREKNOWN">PREKNOWN</A></B></CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used with the <code>retrieveDevices()</code> method to return
 * those devices that are defined to be pre-known devices.</TD>
 * </TR>
 * </TABLE>
 * &nbsp;
 * <!-- ========== METHOD SUMMARY =========== -->
 * 
 * <A NAME="method_summary"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
 * <B>Method Summary</B></FONT></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#cancelInquiry(javax.bluetooth.DiscoveryListener)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#cancelInquiry(javax.bluetooth.DiscoveryListener)">cancelInquiry</A></B>(<A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth">DiscoveryListener</A>&nbsp;listener)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the device from inquiry mode.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#cancelServiceSearch(int)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#cancelServiceSearch(int)">cancelServiceSearch</A></B>(int&nbsp;transID)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancels the service search transaction that has the specified
 * transaction ID.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;<A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" title="class in javax.bluetooth">RemoteDevice</A>[]</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#retrieveDevices(int)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#retrieveDevices(int)">retrieveDevices</A></B>(int&nbsp;option)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array of Bluetooth devices that have either been found
 * by the local device during previous inquiry requests or been
 * specified as a pre-known device depending on the argument.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#searchServices(int[], javax.bluetooth.UUID[], javax.bluetooth.RemoteDevice, javax.bluetooth.DiscoveryListener)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#searchServices(int[], javax.bluetooth.UUID[], javax.bluetooth.RemoteDevice, javax.bluetooth.DiscoveryListener)">searchServices</A></B>(int[]&nbsp;attrSet,
 * <A HREF="UUID.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/UUID.html" title="class in javax.bluetooth">UUID</A>[]&nbsp;uuidSet,
 * <A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" title="class in javax.bluetooth">RemoteDevice</A>&nbsp;btDev,
 * <A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth">DiscoveryListener</A>&nbsp;discListener)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches for services on a remote Bluetooth device that have all the
 * UUIDs specified in <code>uuidSet</code>.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;java.lang.String</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#selectService(javax.bluetooth.UUID, int, boolean)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#selectService(javax.bluetooth.UUID, int, boolean)">selectService</A></B>(<A HREF="UUID.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/UUID.html" title="class in javax.bluetooth">UUID</A>&nbsp;uuid,
 * int&nbsp;security,
 * boolean&nbsp;master)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to locate a service that contains <code>uuid</code> in
 * the ServiceClassIDList of its service record.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="DiscoveryAgent.html#startInquiry(int, javax.bluetooth.DiscoveryListener)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#startInquiry(int, javax.bluetooth.DiscoveryListener)">startInquiry</A></B>(int&nbsp;accessCode,
 * <A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth">DiscoveryListener</A>&nbsp;listener)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Places the device into inquiry mode.</TD>
 * </TR>
 * </TABLE>
 * &nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
 * <TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
 * </TR>
 * </TABLE>
 * &nbsp;
 * 
 * <!-- ============ FIELD DETAIL =========== -->
 * 
 * <A NAME="field_detail"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
 * <B>Field Detail</B></FONT></TH>
 * </TR>
 * </TABLE>
 * 
 * <A NAME="NOT_DISCOVERABLE"><!-- --></A><H3>
 * NOT_DISCOVERABLE</H3>
 * <PRE>
 * public static final int <B>NOT_DISCOVERABLE</B></PRE>
 * <DD>Takes the device out of discoverable mode.
 * The value of <code>NOT_DISCOVERABLE</code> is 0x00 (0).
 * <HR>
 * 
 * <A NAME="GIAC"><!-- --></A><H3>
 * GIAC</H3>
 * <PRE>
 * public static final int <B>GIAC</B></PRE>
 * <DD>The inquiry access code for General/Unlimited Inquiry Access Code
 * (GIAC). This is used to specify the type of inquiry to complete or
 * respond to.
 * The value of <code>GIAC</code> is 0x9E8B33 (10390323). This value
 * is defined in the Bluetooth Assigned Numbers document.
 * <HR>
 * 
 * <A NAME="LIAC"><!-- --></A><H3>
 * LIAC</H3>
 * <PRE>
 * public static final int <B>LIAC</B></PRE>
 * <DD>The inquiry access code for Limited Dedicated Inquiry Access Code
 * (LIAC). This is used to specify the type of inquiry to complete or
 * respond to.
 * The value of <code>LIAC</code> is 0x9E8B00 (10390272). This value
 * is defined in the Bluetooth Assigned Numbers document.
 * <HR>
 * 
 * <A NAME="CACHED"><!-- --></A><H3>
 * CACHED</H3>
 * <PRE>
 * public static final int <B>CACHED</B></PRE>
 * <DD>Used with the <code>retrieveDevices()</code> method to return
 * those devices that were found via a previous inquiry.  If no
 * inquiries have been started, this will cause the method to return
 * <code>null</code>.
 * The value of <code>CACHED</code> is 0x00 (0).
 * <A HREF="../../constant-values.html#javax.bluetooth.DiscoveryAgent.CACHED" tppabs="http://java.sun.com/javame/reference/apis/jsr082/constant-values.html#javax.bluetooth.DiscoveryAgent.CACHED">Constant Field Values</A></DL>
 * <HR>
 * 
 * <A NAME="PREKNOWN"><!-- --></A><H3>
 * PREKNOWN</H3>
 * <PRE>
 * public static final int <B>PREKNOWN</B></PRE>
 * <DD>Used with the <code>retrieveDevices()</code> method to return
 * those devices that are defined to be pre-known devices.  Pre-known
 * devices are specified in the BCC.  These are devices that are
 * specified by the user as devices with which the local device will
 * frequently communicate.
 * The value of <code>PREKNOWN</code> is 0x01 (1).
 * <A HREF="../../constant-values.html#javax.bluetooth.DiscoveryAgent.PREKNOWN" tppabs="http://java.sun.com/javame/reference/apis/jsr082/constant-values.html#javax.bluetooth.DiscoveryAgent.PREKNOWN">Constant Field Values</A></DL>
 * 
 * <!-- ============ METHOD DETAIL ========== -->
 * 
 * <A NAME="method_detail"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
 * <B>Method Detail</B></FONT></TH>
 * </TR>
 * </TABLE>
 * 
 * <A NAME="retrieveDevices(int)"><!-- --></A><H3>
 * retrieveDevices</H3>
 * <PRE>
 * public <A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" title="class in javax.bluetooth">RemoteDevice</A>[] <B>retrieveDevices</B>(int&nbsp;option)</PRE>
 * <DD>Returns an array of Bluetooth devices that have either been found
 * by the local device during previous inquiry requests or been
 * specified as a pre-known device depending on the argument. The list
 * of previously found devices is maintained by the implementation of
 * this API. (In other words, maintenance of the list of previously
 * found devices is an implementation detail.) A device can be set as
 * a pre-known device in the Bluetooth Control Center.
 * should be returned; <code>PREKNOWN</code> if pre-known devices
 * should be returned
 * previously found if <code>option</code> is <code>CACHED</code>;
 * an array of devices that are pre-known devices if
 * <code>option</code> is <code>PREKNOWN</code>; <code>null</code>
 * if no devices meet the criteria
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>option</code> is
 * not <code>CACHED</code> or <code>PREKNOWN</code></DL>
 * <HR>
 * 
 * <A NAME="startInquiry(int, javax.bluetooth.DiscoveryListener)"><!-- --></A><H3>
 * startInquiry</H3>
 * <PRE>
 * public boolean <B>startInquiry</B>(int&nbsp;accessCode,
 * <A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth">DiscoveryListener</A>&nbsp;listener)
 * throws <A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></PRE>
 * <DD>Places the device into inquiry mode.  The length of the inquiry is
 * implementation dependent. This method will search for devices with the
 * specified inquiry access code. Devices that responded to the inquiry
 * are returned to the application via the method
 * <code>deviceDiscovered()</code> of the interface
 * <code>DiscoveryListener</code>. The <code>cancelInquiry()</code>
 * method is called to stop the inquiry.
 * discovery events
 * <code>false</code> if the inquiry was not started because the
 * <code>accessCode</code> is not supported
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if the access code provided
 * is not <code>LIAC</code>, <code>GIAC</code>, or in the range
 * 0x9E8B00 to 0x9E8B3F
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>listener</code> is
 * <code>null</code>
 * <DD><CODE><A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></CODE> - if the Bluetooth device does
 * not allow an inquiry to be started due to other operations that are being
 * performed by the device<DT><B>See Also:</B><DD><A HREF="DiscoveryAgent.html#cancelInquiry(javax.bluetooth.DiscoveryListener)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#cancelInquiry(javax.bluetooth.DiscoveryListener)"><CODE>cancelInquiry(javax.bluetooth.DiscoveryListener)</CODE></A>,
 * <A HREF="DiscoveryAgent.html#GIAC" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#GIAC"><CODE>GIAC</CODE></A>,
 * <A HREF="DiscoveryAgent.html#LIAC" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html#LIAC"><CODE>LIAC</CODE></A></DL>
 * <HR>
 * 
 * <A NAME="cancelInquiry(javax.bluetooth.DiscoveryListener)"><!-- --></A><H3>
 * cancelInquiry</H3>
 * <PRE>
 * public boolean <B>cancelInquiry</B>(<A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth">DiscoveryListener</A>&nbsp;listener)</PRE>
 * <DD>Removes the device from inquiry mode.
 * An <code>inquiryCompleted()</code> event will occur with a type of
 * <code>INQUIRY_TERMINATED</code> as a result of calling this
 * method.  After receiving this
 * event, no further <code>deviceDiscovered()</code> events will occur
 * as a result of this inquiry.
 * 
 * 
 * This method will only cancel the inquiry if the
 * <code>listener</code> provided is the listener that started
 * the inquiry.
 * <code>false</code> if the inquiry was not canceled or if the inquiry
 * was not started using <code>listener</code>
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>listener</code> is
 * <code>null</code></DL>
 * <HR>
 * 
 * <A NAME="searchServices(int[], javax.bluetooth.UUID[], javax.bluetooth.RemoteDevice, javax.bluetooth.DiscoveryListener)"><!-- --></A><H3>
 * searchServices</H3>
 * <PRE>
 * public int <B>searchServices</B>(int[]&nbsp;attrSet,
 * <A HREF="UUID.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/UUID.html" title="class in javax.bluetooth">UUID</A>[]&nbsp;uuidSet,
 * <A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" title="class in javax.bluetooth">RemoteDevice</A>&nbsp;btDev,
 * <A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth">DiscoveryListener</A>&nbsp;discListener)
 * throws <A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></PRE>
 * <DD>Searches for services on a remote Bluetooth device that have all the
 * UUIDs specified in <code>uuidSet</code>.  Once the service is found,
 * the attributes specified in <code>attrSet</code> and the default
 * attributes are retrieved.  The default attributes are
 * ServiceRecordHandle (0x0000), ServiceClassIDList
 * (0x0001), ServiceRecordState (0x0002), ServiceID (0x0003), and
 * ProtocolDescriptorList (0x0004).If <code>attrSet</code> is
 * <code>null</code> then only the default attributes will be retrieved.
 * <code>attrSet</code> does not have to be sorted in increasing order,
 * but must only contain values in the range [0 - (2<sup>16</sup>-1)].
 * retrieved on services which have the UUIDs specified in
 * <code>uuidSet</code><DD><CODE>uuidSet</CODE> - the set of UUIDs that are being searched for;  all
 * services returned will contain all the UUIDs specified here<DD><CODE>btDev</CODE> - the remote Bluetooth device to search for services on<DD><CODE>discListener</CODE> - the object that will receive events when
 * services are discovered
 * must be positive
 * <DD><CODE><A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></CODE> - if the number of concurrent
 * service search transactions exceeds the limit specified by the
 * <code>bluetooth.sd.trans.max</code> property obtained from the
 * class <code>LocalDevice</code> or the system is unable to start
 * one due to current conditions
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>attrSet</code> has
 * an illegal service attribute ID or exceeds the property
 * <code>bluetooth.sd.attr.retrievable.max</code>
 * defined in the class <code>LocalDevice</code>; if
 * <code>attrSet</code>
 * or <code>uuidSet</code> is of length 0; if <code>attrSet</code>
 * or <code>uuidSet</code> contains duplicates
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>uuidSet</code>,
 * <code>btDev</code>, or <code>discListener</code> is
 * <code>null</code>; if an element in  <code>uuidSet</code> array is
 * <code>null</code><DT><B>See Also:</B><DD><A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth"><CODE>DiscoveryListener</CODE></A></DL>
 * <HR>
 * 
 * <A NAME="cancelServiceSearch(int)"><!-- --></A><H3>
 * cancelServiceSearch</H3>
 * <PRE>
 * public boolean <B>cancelServiceSearch</B>(int&nbsp;transID)</PRE>
 * <DD>Cancels the service search transaction that has the specified
 * transaction ID. The ID was assigned to the transaction by the
 * method <code>searchServices()</code>. A
 * <code>serviceSearchCompleted()</code> event with a discovery type
 * of <code>SERVICE_SEARCH_TERMINATED</code> will occur when
 * this method is called. After receiving this event, no further
 * <code>servicesDiscovered()</code> events will occur as a result
 * of this search.
 * cancel; returned by <code>searchServices()</code>
 * terminated, else <code>false</code>  if the <code>transID</code>
 * does not represent an active service search transaction</DL>
 * <HR>
 * 
 * <A NAME="selectService(javax.bluetooth.UUID, int, boolean)"><!-- --></A><H3>
 * selectService</H3>
 * <PRE>
 * public java.lang.String <B>selectService</B>(<A HREF="UUID.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/UUID.html" title="class in javax.bluetooth">UUID</A>&nbsp;uuid,
 * int&nbsp;security,
 * boolean&nbsp;master)
 * throws <A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></PRE>
 * <DD>Attempts to locate a service that contains <code>uuid</code> in
 * the ServiceClassIDList of its service record.  This
 * method will return a string that may be used in
 * <code>Connector.open()</code> to establish a connection to the
 * service.  How the service is selected if there are multiple services
 * with <code>uuid</code> and which devices to
 * search is implementation dependent.
 * to this service; must be one of
 * <code>ServiceRecord.NOAUTHENTICATE_NOENCRYPT</code>,
 * <code>ServiceRecord.AUTHENTICATE_NOENCRYPT</code>, or
 * <code>ServiceRecord.AUTHENTICATE_ENCRYPT</code><DD><CODE>master</CODE> - determines if this client must be the master of the
 * connection; <code>true</code> if the client must be the master;
 * <code>false</code> if the client can be the master or the slave
 * with a UUID of <code>uuid</code>; or <code>null</code> if no
 * service could be found with a UUID of <code>uuid</code> in the
 * ServiceClassIDList
 * <DD><CODE><A HREF="BluetoothStateException.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/BluetoothStateException.html" title="class in javax.bluetooth">BluetoothStateException</A></CODE> - if the Bluetooth system cannot
 * start the request due to the current state of the Bluetooth system
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>uuid</code> is
 * <code>null</code>
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>security</code> is
 * not <code>ServiceRecord.NOAUTHENTICATE_NOENCRYPT</code>,
 * <code>ServiceRecord.AUTHENTICATE_NOENCRYPT</code>, or
 * <code>ServiceRecord.AUTHENTICATE_ENCRYPT</code><DT><B>See Also:</B><DD><A HREF="ServiceRecord.html#NOAUTHENTICATE_NOENCRYPT" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html#NOAUTHENTICATE_NOENCRYPT"><CODE>ServiceRecord.NOAUTHENTICATE_NOENCRYPT</CODE></A>,
 * <A HREF="ServiceRecord.html#AUTHENTICATE_NOENCRYPT" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html#AUTHENTICATE_NOENCRYPT"><CODE>ServiceRecord.AUTHENTICATE_NOENCRYPT</CODE></A>,
 * <A HREF="ServiceRecord.html#AUTHENTICATE_ENCRYPT" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html#AUTHENTICATE_ENCRYPT"><CODE>ServiceRecord.AUTHENTICATE_ENCRYPT</CODE></A></DL>
 * <!-- ========= END OF CLASS DATA ========= -->
 * <HR>
 * 
 * 
 * <!-- ======= START OF BOTTOM NAVBAR ====== -->
 * <A NAME="navbar_bottom"><!-- --></A>
 * <A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
 * <TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
 * <TR>
 * <TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
 * <A NAME="navbar_bottom_firstrow"><!-- --></A>
 * <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
 * <TR ALIGN="center" VALIGN="top">
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
 * </TR>
 * </TABLE>
 * </TD>
 * <TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
 * <b>JSR 82</b></EM>
 * </TD>
 * </TR>
 * 
 * <TR>
 * <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 * &nbsp;<A HREF="DeviceClass.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DeviceClass.html" title="class in javax.bluetooth"><B>PREV CLASS</B></A>&nbsp;
 * &nbsp;<A HREF="DiscoveryListener.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryListener.html" title="interface in javax.bluetooth"><B>NEXT CLASS</B></A></FONT></TD>
 * <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 * <A HREF="../../index.html-javax-bluetooth-DiscoveryAgent.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/index.html?javax/bluetooth/DiscoveryAgent.html" target="_top"><B>FRAMES</B></A>  &nbsp;
 * &nbsp;<A HREF="DiscoveryAgent.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/DiscoveryAgent.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
 * &nbsp;<SCRIPT type="text/javascript">
 * <!--
 * if(window==top) {
 * document.writeln('<A HREF="../../allclasses-noframe.html"tpa=http://java.sun.com/javame/reference/apis/jsr082/allclasses-noframe.html><B>All Classes</B></A>');
 * }
 * //-->
 * </SCRIPT>
 * <NOSCRIPT>
 * <A HREF="../../allclasses-noframe.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/allclasses-noframe.html"><B>All Classes</B></A>
 * </NOSCRIPT>
 * 
 * 
 * </FONT></TD>
 * </TR>
 * <TR>
 * <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
 * SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
 * <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
 * DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
 * </TR>
 * </TABLE>
 * <A NAME="skip-navbar_bottom"></A>
 * <!-- ======== END OF BOTTOM NAVBAR ======= -->
 * 
 * <HR>
 * <small>Copyright (c) 2006 Sun Microsystems, Inc. All rights reserved. <b>Use is subject to <a href="http://java.sun.com/javame/reference/apis/license.html" target="_top">License Terms</a>.</b> Your use of this web site or any of its content or software indicates your agreement to be bound by these License Terms.<br><br>For more information, please consult the <a href="http://jcp.org/en/jsr/detail?id=82" target="_top">JSR 82 specification.</a></small>
 * </BODY>
 * <script language="JavaScript" src="../../../../../../js/omi/jsc/s_code_remote.js" tppabs="http://java.sun.com/js/omi/jsc/s_code_remote.js"></script></HTML>
 * 
 */
public class DiscoveryAgent extends Object
{
	/**
	 * Takes the device out of discoverable mode.
	 * <P>
	 * The value of <code>NOT_DISCOVERABLE</code> is 0x00 (0).
	 * <P>
	 * <DT><B>See Also:</B>
	 * 
	 */
	public static final int NOT_DISCOVERABLE = 0x00;

	/**
	 * The inquiry access code for General/Unlimited Inquiry Access Code
	 * (GIAC). This is used to specify the type of inquiry to complete or
	 * respond to.
	 * <P>
	 * The value of <code>GIAC</code> is 0x9E8B33 (10390323). This value
	 * is defined in the Bluetooth Assigned Numbers document.
	 * <P>
	 * <DT><B>See Also:</B>
	 * 
	 */
	public static final int GIAC = 0x9E8B33;

	/**
	 * The inquiry access code for Limited Dedicated Inquiry Access Code
	 * (LIAC). This is used to specify the type of inquiry to complete or
	 * respond to.
	 * <P>
	 * The value of <code>LIAC</code> is 0x9E8B00 (10390272). This value
	 * is defined in the Bluetooth Assigned Numbers document.
	 * <P>
	 * <DT><B>See Also:</B>
	 * 
	 */
	public static final int LIAC = 0x9E8B00;

	/**
	 * Used with the <code>retrieveDevices()</code> method to return
	 * those devices that were found via a previous inquiry.  If no
	 * inquiries have been started, this will cause the method to return
	 * <code>null</code>.
	 * <P>
	 * The value of <code>CACHED</code> is 0x00 (0).
	 * <P>
	 * <DT><B>See Also:</B>
	 * <A HREF="../../constant-values.html#javax.bluetooth.DiscoveryAgent.CACHED" tppabs="http://java.sun.com/javame/reference/apis/jsr082/constant-values.html#javax.bluetooth.DiscoveryAgent.CACHED">Constant Field Values</A></DL>
	 * 
	 */
	public static final int CACHED = 0x00;

	/**
	 * Used with the <code>retrieveDevices()</code> method to return
	 * those devices that are defined to be pre-known devices.  Pre-known
	 * devices are specified in the BCC.  These are devices that are
	 * specified by the user as devices with which the local device will
	 * frequently communicate.
	 * <P>
	 * The value of <code>PREKNOWN</code> is 0x01 (1).
	 * <P>
	 * <DT><B>See Also:</B>
	 * <A HREF="../../constant-values.html#javax.bluetooth.DiscoveryAgent.PREKNOWN" tppabs="http://java.sun.com/javame/reference/apis/jsr082/constant-values.html#javax.bluetooth.DiscoveryAgent.PREKNOWN">Constant Field Values</A></DL>
	 * 
	 * 
	 */
	public static final int PREKNOWN = 0x01;

	private DiscoveryListener discoveryListener;

	DiscoveryAgent(){
		// Hidden.
	}

	/**
	 * Returns an array of Bluetooth devices that have either been found
	 * by the local device during previous inquiry requests or been
	 * specified as a pre-known device depending on the argument. The list
	 * of previously found devices is maintained by the implementation of
	 * this API. (In other words, maintenance of the list of previously
	 * found devices is an implementation detail.) A device can be set as
	 * a pre-known device in the Bluetooth Control Center.
	 * <P>
	 * 
	 * @param option - CACHED if previously found devices should be returned; PREKNOWN if pre-known devices should be returned
	 * @return an array containing the Bluetooth devices that were previously found if option is CACHED; an array of devices that are pre-known devices if option is PREKNOWN; null if no devices meet the criteria
	 * @throws java.lang.IllegalArgumentException - if option is not CACHED or PREKNOWN
	 */
	public RemoteDevice[] retrieveDevices(int option)
	{
		return null;
		//TODO implement retrieveDevices
	}

	/**
	 * Places the device into inquiry mode.  The length of the inquiry is
	 * implementation dependent. This method will search for devices with the
	 * specified inquiry access code. Devices that responded to the inquiry
	 * are returned to the application via the method
	 * <code>deviceDiscovered()</code> of the interface
	 * <code>DiscoveryListener</code>. The <code>cancelInquiry()</code>
	 * method is called to stop the inquiry.
	 * <P>
	 * 
	 * @param accessCode - the type of inquiry to complete
	 * @param listener - the event listener that will receive device discovery events
	 * @return true if the inquiry was started; false if the inquiry was not started because the accessCode is not supported
	 * @throws java.lang.IllegalArgumentException - if the access code provided is not LIAC, GIAC, or in the range 0x9E8B00 to 0x9E8B3F
	 * @throws java.lang.NullPointerException - if listener is null
	 * @throws BluetoothStateException - if the Bluetooth device does not allow an inquiry to be started due to other operations that are being performed by the device
	 * @see #cancelInquiry(DiscoveryListener)
	 * @see #GIAC
	 * @see #LIAC
	 */
	public boolean startInquiry(int accessCode, DiscoveryListener listener) throws BluetoothStateException
	{
		if(accessCode != GIAC) {
			return false;
		}
		BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
		if(adapter == null) {
			throw new BluetoothStateException("Bluetooth is not active at the moment");
		}
		
		if(adapter.isDiscovering()) {
			// Stop the running inquery. Inform the old listeners.
			adapter.cancelDiscovery();
			//TODO: How to inform the listener about the termination? The cancelDiscovery will also trigger an intent which will be delivered.
			if(this.discoveryListener != null) {
				//TODO: The old termination event will now be delivered to the new listener!
				BluetoothEventReceiver.getInstance().setDiscoveryListener(listener);
				this.discoveryListener.inquiryCompleted(DiscoveryListener.INQUIRY_TERMINATED);
			}
		}
		this.discoveryListener = listener;
		adapter.startDiscovery();
		return true;
	}

	/**
	 * Removes the device from inquiry mode.
	 * <P>
	 * An <code>inquiryCompleted()</code> event will occur with a type of
	 * <code>INQUIRY_TERMINATED</code> as a result of calling this
	 * method.  After receiving this
	 * event, no further <code>deviceDiscovered()</code> events will occur
	 * as a result of this inquiry.
	 * 
	 * <P>
	 * 
	 * This method will only cancel the inquiry if the
	 * <code>listener</code> provided is the listener that started
	 * the inquiry.
	 * <P>
	 * 
	 * @param listener - the listener that is receiving inquiry events
	 * @return true if the inquiry was canceled; otherwise false if the inquiry was not canceled or if the inquiry was not started using listener
	 * @throws java.lang.NullPointerException - if listener is null
	 */
	public boolean cancelInquiry( DiscoveryListener listener)
	{
		return false;
		//TODO implement cancelInquiry
	}

	/**
	 * Searches for services on a remote Bluetooth device that have all the
	 * UUIDs specified in <code>uuidSet</code>.  Once the service is found,
	 * the attributes specified in <code>attrSet</code> and the default
	 * attributes are retrieved.  The default attributes are
	 * ServiceRecordHandle (0x0000), ServiceClassIDList
	 * (0x0001), ServiceRecordState (0x0002), ServiceID (0x0003), and
	 * ProtocolDescriptorList (0x0004).If <code>attrSet</code> is
	 * <code>null</code> then only the default attributes will be retrieved.
	 * <code>attrSet</code> does not have to be sorted in increasing order,
	 * but must only contain values in the range [0 - (2<sup>16</sup>-1)].
	 * <P>
	 * 
	 * @param attrSet - indicates the attributes whose values will be retrieved on services which have the UUIDs specified in uuidSet
	 * @param uuidSet - the set of UUIDs that are being searched for;  all services returned will contain all the UUIDs specified here
	 * @param btDev - the remote Bluetooth device to search for services on
	 * @param discListener - the object that will receive events when services are discovered
	 * @return the transaction ID of the service search; this number must be positive
	 * @throws BluetoothStateException - if the number of concurrent service search transactions exceeds the limit specified by the bluetooth.sd.trans.max property obtained from the class LocalDevice or the system is unable to start one due to current conditions
	 * @throws java.lang.IllegalArgumentException - if attrSet has an illegal service attribute ID or exceeds the property bluetooth.sd.attr.retrievable.max defined in the class LocalDevice; if attrSet or uuidSet is of length 0; if attrSet or uuidSet contains duplicates
	 * @throws java.lang.NullPointerException - if uuidSet, btDev, or discListener is null; if an element in  uuidSet array is null
	 * @see DiscoveryListener
	 */
	public int searchServices(int[] attrSet, UUID[] uuidSet, RemoteDevice btDev, DiscoveryListener discListener) throws BluetoothStateException
	{
		return 0;
		//TODO implement searchServices
	}

	/**
	 * Cancels the service search transaction that has the specified
	 * transaction ID. The ID was assigned to the transaction by the
	 * method <code>searchServices()</code>. A
	 * <code>serviceSearchCompleted()</code> event with a discovery type
	 * of <code>SERVICE_SEARCH_TERMINATED</code> will occur when
	 * this method is called. After receiving this event, no further
	 * <code>servicesDiscovered()</code> events will occur as a result
	 * of this search.
	 * <P>
	 * 
	 * @param transID - the ID of the service search transaction to cancel; returned by searchServices()
	 * @return true if the service search transaction is terminated, else false  if the transID does not represent an active service search transaction
	 */
	public boolean cancelServiceSearch(int transID)
	{
		return false;
		//TODO implement cancelServiceSearch
	}

	/**
	 * Attempts to locate a service that contains <code>uuid</code> in
	 * the ServiceClassIDList of its service record.  This
	 * method will return a string that may be used in
	 * <code>Connector.open()</code> to establish a connection to the
	 * service.  How the service is selected if there are multiple services
	 * with <code>uuid</code> and which devices to
	 * search is implementation dependent.
	 * <P>
	 * 
	 * @param uuid - the UUID to search for in the ServiceClassIDList
	 * @param security - specifies the security requirements for a connection to this service; must be one of ServiceRecord.NOAUTHENTICATE_NOENCRYPT, ServiceRecord.AUTHENTICATE_NOENCRYPT, or ServiceRecord.AUTHENTICATE_ENCRYPT
	 * @param master - determines if this client must be the master of the connection; true if the client must be the master; false if the client can be the master or the slave
	 * @return the connection string used to connect to the service with a UUID of uuid; or null if no service could be found with a UUID of uuid in the ServiceClassIDList
	 * @throws BluetoothStateException - if the Bluetooth system cannot start the request due to the current state of the Bluetooth system
	 * @throws java.lang.NullPointerException - if uuid is null
	 * @throws java.lang.IllegalArgumentException - if security is not ServiceRecord.NOAUTHENTICATE_NOENCRYPT, ServiceRecord.AUTHENTICATE_NOENCRYPT, or ServiceRecord.AUTHENTICATE_ENCRYPT
	 * @see ServiceRecord#NOAUTHENTICATE_NOENCRYPT
	 * @see ServiceRecord#AUTHENTICATE_NOENCRYPT
	 * @see ServiceRecord#AUTHENTICATE_ENCRYPT
	 */
	public java.lang.String selectService( UUID uuid, int security, boolean master) throws BluetoothStateException
	{
		return null;
		//TODO implement selectService
	}

}
