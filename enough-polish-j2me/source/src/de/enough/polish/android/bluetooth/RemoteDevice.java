//#condition polish.javaplatform >= Android/2.0
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Tue Mar 24 10:34:27 EET 2009
package de.enough.polish.android.bluetooth;

import android.bluetooth.BluetoothClass;
import android.bluetooth.BluetoothDevice;
import de.enough.polish.android.io.Connection;

/**
 * 
 * The <code>RemoteDevice</code> class represents a remote Bluetooth device.
 * It provides basic
 * information about a remote device including the device's Bluetooth address
 * and its friendly name.
 * 
 * <DD>1.8, 07/26/04</DD>
 * <HR>
 * 
 * 
 * <!-- ======== CONSTRUCTOR SUMMARY ======== -->
 * 
 * <A NAME="constructor_summary"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
 * <B>Constructor Summary</B></FONT></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>protected </CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#RemoteDevice(java.lang.String)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#RemoteDevice(java.lang.String)">RemoteDevice</A></B>(java.lang.String&nbsp;address)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a Bluetooth device based upon its address.</TD>
 * </TR>
 * </TABLE>
 * &nbsp;
 * <!-- ========== METHOD SUMMARY =========== -->
 * 
 * <A NAME="method_summary"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
 * <B>Method Summary</B></FONT></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#authenticate()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#authenticate()">authenticate</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to authenticate this <code>RemoteDevice</code>.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#authorize(Connection)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#authorize(Connection)">authorize</A></B>(Connection&nbsp;conn)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if this <code>RemoteDevice</code> should be allowed
 * to continue to access the local service provided by the
 * <code>Connection</code>.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#encrypt(Connection, boolean)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#encrypt(Connection, boolean)">encrypt</A></B>(Connection&nbsp;conn,
 * boolean&nbsp;on)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to turn encryption on or off for an existing
 * connection.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#equals(java.lang.Object)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#equals(java.lang.Object)">equals</A></B>(java.lang.Object&nbsp;obj)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if two <code>RemoteDevice</code>s are equal.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;java.lang.String</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#getBluetoothAddress()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#getBluetoothAddress()">getBluetoothAddress</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the Bluetooth address of this device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;java.lang.String</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#getFriendlyName(boolean)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#getFriendlyName(boolean)">getFriendlyName</A></B>(boolean&nbsp;alwaysAsk)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of this device.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>static&nbsp;<A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" title="class in javax.bluetooth">RemoteDevice</A></CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#getRemoteDevice(Connection)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#getRemoteDevice(Connection)">getRemoteDevice</A></B>(Connection&nbsp;conn)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the Bluetooth device that is at the other end of the Bluetooth
 * Serial Port Profile connection, L2CAP connection, or OBEX over RFCOMM
 * connection provided.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;int</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#hashCode()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#hashCode()">hashCode</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the hash code for this object.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#isAuthenticated()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#isAuthenticated()">isAuthenticated</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if this <code>RemoteDevice</code> has been
 * authenticated.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#isAuthorized(Connection)" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#isAuthorized(Connection)">isAuthorized</A></B>(Connection&nbsp;conn)</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if this <code>RemoteDevice</code> has been
 * authorized previously by the BCC of the local device to
 * exchange data related to the service associated with the
 * connection.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#isEncrypted()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#isEncrypted()">isEncrypted</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if data exchanges with this <code>RemoteDevice</code>
 * are currently being encrypted.</TD>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
 * <CODE>&nbsp;boolean</CODE></FONT></TD>
 * <TD><CODE><B><A HREF="RemoteDevice.html#isTrustedDevice()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#isTrustedDevice()">isTrustedDevice</A></B>()</CODE>
 * 
 * <BR>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if this is a trusted device according to the BCC.</TD>
 * </TR>
 * </TABLE>
 * &nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
 * <TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
 * </TR>
 * <TR BGCOLOR="white" CLASS="TableRowColor">
 * <TD><CODE>clone, finalize, getClass, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
 * </TR>
 * </TABLE>
 * &nbsp;
 * 
 * <!-- ========= CONSTRUCTOR DETAIL ======== -->
 * 
 * <A NAME="constructor_detail"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
 * <B>Constructor Detail</B></FONT></TH>
 * </TR>
 * </TABLE>
 * 
 * <A NAME="RemoteDevice(java.lang.String)"><!-- --></A><H3>
 * RemoteDevice</H3>
 * <PRE>
 * protected <B>RemoteDevice</B>(java.lang.String&nbsp;address)</PRE>
 * <DD>Creates a Bluetooth device based upon its address.  The Bluetooth
 * address must be 12 hex characters long.  Valid characters are 0-9, a-f,
 * and A-F.  There is no preceding "0x" in the string.  For example, valid
 * Bluetooth addresses include but are not limited to:<BR>
 * <code>008037144297</code><BR>
 * <code>00af8300cd0b</code><BR>
 * <code>014bd91DA8FC</code>
 * hex string.
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>address</code> is
 * <code>null</code>.
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>address</code> is the
 * address of the local device or is not a valid Bluetooth
 * address.</DL>
 * 
 * <!-- ============ METHOD DETAIL ========== -->
 * 
 * <A NAME="method_detail"><!-- --></A>
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 * <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
 * <B>Method Detail</B></FONT></TH>
 * </TR>
 * </TABLE>
 * 
 * <A NAME="isTrustedDevice()"><!-- --></A><H3>
 * isTrustedDevice</H3>
 * <PRE>
 * public boolean <B>isTrustedDevice</B>()</PRE>
 * <DD>Determines if this is a trusted device according to the BCC.
 * 
 * <code>false</code></DL>
 * <HR>
 * 
 * <A NAME="getFriendlyName(boolean)"><!-- --></A><H3>
 * getFriendlyName</H3>
 * <PRE>
 * public java.lang.String <B>getFriendlyName</B>(boolean&nbsp;alwaysAsk)
 * throws java.io.IOException</PRE>
 * <DD>Returns the name of this device. The Bluetooth
 * specification calls this name the "Bluetooth device name" or the
 * "user-friendly name".  This method will only contact
 * the remote device if the name is not known or
 * <code>alwaysAsk</code> is <code>true</code>.
 * contacted for its name, otherwise, if there exists a known
 * name for this device, the name will be returned without
 * contacting the remote device
 * Bluetooth system does not support this feature; if the local device
 * is able to contact the remote device, the result will never be
 * <code>null</code>; if the remote device does not have a name
 * then an empty string will be returned
 * <DD><CODE>java.io.IOException</CODE> - if the remote device can not be contacted or the
 * remote device could not provide its name.</DL>
 * <HR>
 * 
 * <A NAME="getBluetoothAddress()"><!-- --></A><H3>
 * getBluetoothAddress</H3>
 * <PRE>
 * public final java.lang.String <B>getBluetoothAddress</B>()</PRE>
 * <DD>Retrieves the Bluetooth address of this device.  The Bluetooth address
 * will be 12 characters long.  Valid characters are 0-9 and A-F.  This
 * method will never return <code>null</code>.
 * 
 * <HR>
 * 
 * <A NAME="equals(java.lang.Object)"><!-- --></A><H3>
 * equals</H3>
 * <PRE>
 * public boolean <B>equals</B>(java.lang.Object&nbsp;obj)</PRE>
 * <DD>Determines if two <code>RemoteDevice</code>s are equal.  Two devices are
 * equal if they have the same Bluetooth device address.
 * address; <code>false</code> if both devices do not have the same address;
 * <code>false</code> if <code>obj</code> is <code>null</code>;
 * <code>false</code> if <code>obj</code> is not a
 * <code>RemoteDevice</code></DL>
 * <HR>
 * 
 * <A NAME="hashCode()"><!-- --></A><H3>
 * hashCode</H3>
 * <PRE>
 * public int <B>hashCode</B>()</PRE>
 * <DD>Computes the hash code for this object. This method will return the
 * same value when it is called multiple times on the same object.
 * 
 * <HR>
 * 
 * <A NAME="getRemoteDevice(Connection)"><!-- --></A><H3>
 * getRemoteDevice</H3>
 * <PRE>
 * public static <A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" title="class in javax.bluetooth">RemoteDevice</A> <B>getRemoteDevice</B>(Connection&nbsp;conn)
 * throws java.io.IOException</PRE>
 * <DD>Retrieves the Bluetooth device that is at the other end of the Bluetooth
 * Serial Port Profile connection, L2CAP connection, or OBEX over RFCOMM
 * connection provided.  This method will never return <code>null</code>.
 * or OBEX over RFCOMM connection whose remote Bluetooth device
 * is needed.
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>conn</code> is not a
 * Bluetooth Serial Port Profile connection, L2CAP connection,
 * or OBEX over RFCOMM connection; if <code>conn</code> is a
 * <code>L2CAPConnectionNotifier</code>,
 * <code>StreamConnectionNotifier</code>, or
 * <code>SessionNotifier</code>.
 * <DD><CODE>java.io.IOException</CODE> - if the connection is closed.
 * <DD><CODE>java.lang.NullPointerException</CODE> - if <code>conn</code> is
 * <code>null</code>.</DL>
 * <HR>
 * 
 * <A NAME="authenticate()"><!-- --></A><H3>
 * authenticate</H3>
 * <PRE>
 * public boolean <B>authenticate</B>()
 * throws java.io.IOException</PRE>
 * <DD>Attempts to authenticate this <code>RemoteDevice</code>.
 * Authentication is a means of verifying the identity of a remote
 * device. Authentication involves a device-to-device challenge and
 * response scheme that requires a 128-bit common secret link key
 * derived from a PIN code shared by both devices. If either side's
 * PIN code does not match, the authentication process fails and the
 * method returns <code>false</code>.  The method will also return
 * <code>false</code> if authentication is incompatible with the
 * current security settings of the local device established by the
 * BCC, if the stack does not
 * support authentication at all, or if the stack does not support
 * authentication subsequent to connection establishment.
 * 
 * <p> If this <code>RemoteDevice</code> has previously been
 * authenticated, then this method returns <code>true</code>
 * without attempting to re-authenticate this
 * <code>RemoteDevice</code>.
 * 
 * otherwise <code>false</code>
 * <DD><CODE>java.io.IOException</CODE> - if there are no open connections between
 * the local device and this <code>RemoteDevice</code></DL>
 * <HR>
 * 
 * <A NAME="authorize(Connection)"><!-- --></A><H3>
 * authorize</H3>
 * <PRE>
 * public boolean <B>authorize</B>(Connection&nbsp;conn)
 * throws java.io.IOException</PRE>
 * <DD>Determines if this <code>RemoteDevice</code> should be allowed
 * to continue to access the local service provided by the
 * <code>Connection</code>.  In Bluetooth, authorization is
 * defined as the process of deciding if device X is allowed to
 * access service Y.  The implementation of the
 * <code>authorize(Connection conn)</code> method asks the
 * Bluetooth Control Center (BCC) to decide if it is acceptable
 * for <code>RemoteDevice</code> to continue to access a local
 * service over the connection <code>conn</code>.  In devices with
 * a user interface, the BCC is expected to consult with the user
 * to obtain approval.
 * 
 * <p> Some Bluetooth systems may allow the user to permanently
 * authorize a remote device for all local services. When a device
 * is authorized in this way, it is known as a "trusted device"
 * -- see <A HREF="RemoteDevice.html#isTrustedDevice()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#isTrustedDevice()"><CODE>isTrustedDevice()</CODE></A>.
 * 
 * <p> The <code>authorize()</code> method will also check that the
 * identity of the <code>RemoteDevice</code> can be verified through
 * authentication.
 * If this <code>RemoteDevice</code> has been authorized for
 * <code>conn</code> previously, then this method returns
 * <code>true</code> without attempting to re-authorize this
 * <code>RemoteDevice</code>.
 * using to access a local service
 * successfully authenticated and authorized, otherwise
 * <code>false</code> if authentication or authorization fails
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>conn</code> is not
 * a connection to this <code>RemoteDevice</code>, or if the local
 * device initiated the connection, i.e., the local device is the
 * client rather than the server.  This exception is also thrown if
 * <code>conn</code> was created by <code>RemoteDevice</code>
 * using a scheme other than <code>btspp</code>,
 * <code>btl2cap</code>, or <code>btgoep</code>. This exception
 * is thrown if <code>conn</code> is a notifier used by a server
 * to wait for a client connection, since the notifier is not a
 * connection to this <code>RemoteDevice</code>.
 * <DD><CODE>java.io.IOException</CODE> - if <code>conn</code> is closed<DT><B>See Also:</B><DD><A HREF="RemoteDevice.html#isTrustedDevice()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#isTrustedDevice()"><CODE>isTrustedDevice()</CODE></A></DL>
 * <HR>
 * 
 * <A NAME="encrypt(Connection, boolean)"><!-- --></A><H3>
 * encrypt</H3>
 * <PRE>
 * public boolean <B>encrypt</B>(Connection&nbsp;conn,
 * boolean&nbsp;on)
 * throws java.io.IOException</PRE>
 * <DD>Attempts to turn encryption on or off for an existing
 * connection.  In the case where the parameter <code>on</code> is
 * <code>true</code>, this method will first authenticate this
 * <code>RemoteDevice</code> if it has not already been
 * authenticated.  Then it will attempt to turn on encryption.  If
 * the connection is already encrypted then this method
 * returns <code>true</code>.  Otherwise, when the parameter <code>on</code>
 * is <code>true</code>, either: <UL> <LI> the method succeeds in
 * turning on encryption for the connection and returns
 * <code>true</code>, or <LI> the method was unsuccessful in
 * turning on encryption and returns <code>false</code>.  This
 * could happen because the stack does not support encryption or
 * because encryption conflicts with the user's security settings
 * for the device.  </UL>
 * 
 * <p> In the case where the parameter <code>on</code> is
 * <code>false</code>, there are again two possible outcomes: <UL>
 * <LI> encryption is turned off on the connection and
 * <code>true</code> is returned, or <LI> encryption is left on
 * for the connection and <code>false</code> is returned.  </UL>
 * Encryption may be left on following <code>encrypt(conn,
 * false)</code> for a variety of reasons.  The user's current
 * security settings for the device may require encryption or the
 * stack may not have a mechanism to turn off encryption.  Also,
 * the BCC may have determined that encryption will be kept on for
 * the physical link to this <code>RemoteDevice</code>.  The
 * details of the BCC are implementation dependent, but encryption
 * might be left on because other connections to the same device
 * need encryption.  (All of the connections over the same
 * physical link must be encrypted if any of them are encrypted.)
 * 
 * <p> While attempting to turn encryption off may not succeed
 * immediately because other connections need encryption on, there
 * may be a delayed effect.  At some point, all of the connections
 * over this physical link needing encryption could be closed or
 * also have had the method <code>encrypt(conn, false)</code>
 * invoked for them.  In this case, the BCC may turn off
 * encryption for all connections over this physical link.  (The
 * policy used by the BCC is implementation dependent.)  It is
 * recommended that applications do <code>encrypt(conn,
 * false)</code> once they no longer need encryption to allow the
 * BCC to determine if it can reduce the overhead on connections
 * to this <code>RemoteDevice</code>.
 * 
 * <p> The fact that <code>encrypt(conn, false)</code> may not
 * succeed in turning off encryption has very few consequences for
 * applications.  The stack handles encryption and decryption, so
 * the application does not have to do anything different
 * depending on whether the connection is still encrypted or not.
 * <code>false</code> attempts to turn off encryption
 * <code>false</code> if it failed
 * <DD><CODE>java.io.IOException</CODE> - if <code>conn</code> is closed
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>conn</code> is not
 * a connection to this <code>RemoteDevice</code>; if <code>conn</code> was
 * created by the
 * client side of the connection using a scheme other than
 * <code>btspp</code>, <code>btl2cap</code>, or
 * <code>btgoep</code> (for example, this exception will be
 * thrown if <code>conn</code> was created using the
 * <code>file</code> or <code>http</code> schemes.);
 * if <code>conn</code> is a notifier used by a server
 * to wait for a client connection, since the notifier is not a
 * connection to this <code>RemoteDevice</code></DL>
 * <HR>
 * 
 * <A NAME="isAuthenticated()"><!-- --></A><H3>
 * isAuthenticated</H3>
 * <PRE>
 * public boolean <B>isAuthenticated</B>()</PRE>
 * <DD>Determines if this <code>RemoteDevice</code> has been
 * authenticated.
 * A device may have been authenticated by this application
 * or another application.  Authentication applies to an ACL link between
 * devices and not on a specific L2CAP, RFCOMM, or OBEX connection.
 * Therefore, if <code>authenticate()</code> is performed when an L2CAP
 * connection is made to device A, then <code>isAuthenticated()</code> may
 * return <code>true</code> when tested as part of making an RFCOMM
 * connection to device A.
 * 
 * previously been authenticated; <code>false</code> if it has not
 * been authenticated or there are no open connections between the
 * local device and this <code>RemoteDevice</code></DL>
 * <HR>
 * 
 * <A NAME="isAuthorized(Connection)"><!-- --></A><H3>
 * isAuthorized</H3>
 * <PRE>
 * public boolean <B>isAuthorized</B>(Connection&nbsp;conn)
 * throws java.io.IOException</PRE>
 * <DD>Determines if this <code>RemoteDevice</code> has been
 * authorized previously by the BCC of the local device to
 * exchange data related to the service associated with the
 * connection. Both clients and servers can call this method.
 * However, for clients this method returns <code>false</code> for
 * all legal values of the <code>conn</code> argument.
 * using to access a service or provide a service
 * connection and this <code>RemoteDevice</code> has been
 * authorized; <code>false</code> if <code>conn</code> is a
 * client-side connection, or a server-side connection that has not
 * been authorized
 * <DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>conn</code> is not
 * a connection to this <code>RemoteDevice</code>; if
 * <code>conn</code> was not created using one of the schemes
 * <code>btspp</code>, <code>btl2cap</code>, or
 * <code>btgoep</code>; or if <code>conn</code> is a notifier
 * used by a server to wait for a client connection, since the
 * notifier is not a connection to this <code>RemoteDevice</code>.
 * <DD><CODE>java.io.IOException</CODE> - if <code>conn</code> is closed</DL>
 * <HR>
 * 
 * <A NAME="isEncrypted()"><!-- --></A><H3>
 * isEncrypted</H3>
 * <PRE>
 * public boolean <B>isEncrypted</B>()</PRE>
 * <DD>Determines if data exchanges with this <code>RemoteDevice</code>
 * are currently being encrypted.
 * Encryption may have been previously turned on by this or another
 * application.  Encryption applies to an ACL link
 * between devices and not on a specific L2CAP, RFCOMM, or OBEX connection.
 * Therefore, if <code>encrypt()</code> is performed with the
 * <code>on</code> parameter set to <code>true</code> when an L2CAP
 * connection is made to device A, then <code>isEncrypted()</code> may
 * return <code>true</code> when tested as part of making an RFCOMM
 * connection to device A.
 * 
 * <code>RemoteDevice</code> are being encrypted; <code>false</code>
 * if they are not being encrypted, or there are no open connections
 * between the local device and this <code>RemoteDevice</code></DL>
 * <!-- ========= END OF CLASS DATA ========= -->
 * <HR>
 * 
 * 
 * <!-- ======= START OF BOTTOM NAVBAR ====== -->
 * <A NAME="navbar_bottom"><!-- --></A>
 * <A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
 * <TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
 * <TR>
 * <TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
 * <A NAME="navbar_bottom_firstrow"><!-- --></A>
 * <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
 * <TR ALIGN="center" VALIGN="top">
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
 * <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
 * </TR>
 * </TABLE>
 * </TD>
 * <TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
 * <b>JSR 82</b></EM>
 * </TD>
 * </TR>
 * 
 * <TR>
 * <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 * &nbsp;<A HREF="LocalDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/LocalDevice.html" title="class in javax.bluetooth"><B>PREV CLASS</B></A>&nbsp;
 * &nbsp;<A HREF="ServiceRecord.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/ServiceRecord.html" title="interface in javax.bluetooth"><B>NEXT CLASS</B></A></FONT></TD>
 * <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
 * <A HREF="../../index.html-javax-bluetooth-RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/index.html?javax/bluetooth/RemoteDevice.html" target="_top"><B>FRAMES</B></A>  &nbsp;
 * &nbsp;<A HREF="RemoteDevice.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
 * &nbsp;<SCRIPT type="text/javascript">
 * <!--
 * if(window==top) {
 * document.writeln('<A HREF="../../allclasses-noframe.html"tpa=http://java.sun.com/javame/reference/apis/jsr082/allclasses-noframe.html><B>All Classes</B></A>');
 * }
 * //-->
 * </SCRIPT>
 * <NOSCRIPT>
 * <A HREF="../../allclasses-noframe.html" tppabs="http://java.sun.com/javame/reference/apis/jsr082/allclasses-noframe.html"><B>All Classes</B></A>
 * </NOSCRIPT>
 * 
 * 
 * </FONT></TD>
 * </TR>
 * <TR>
 * <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
 * SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
 * <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
 * DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
 * </TR>
 * </TABLE>
 * <A NAME="skip-navbar_bottom"></A>
 * <!-- ======== END OF BOTTOM NAVBAR ======= -->
 * 
 * <HR>
 * <small>Copyright (c) 2006 Sun Microsystems, Inc. All rights reserved. <b>Use is subject to <a href="http://java.sun.com/javame/reference/apis/license.html" target="_top">License Terms</a>.</b> Your use of this web site or any of its content or software indicates your agreement to be bound by these License Terms.<br><br>For more information, please consult the <a href="http://jcp.org/en/jsr/detail?id=82" target="_top">JSR 82 specification.</a></small>
 * </BODY>
 * <script language="JavaScript" src="../../../../../../js/omi/jsc/s_code_remote.js" tppabs="http://java.sun.com/js/omi/jsc/s_code_remote.js"></script></HTML>
 * 
 */
public class RemoteDevice extends java.lang.Object
{
	private BluetoothDevice androidBluetoothDevice;

	/**
	 * Creates a Bluetooth device based upon its address.  The Bluetooth
	 * address must be 12 hex characters long.  Valid characters are 0-9, a-f,
	 * and A-F.  There is no preceding "0x" in the string.  For example, valid
	 * Bluetooth addresses include but are not limited to:<BR>
	 * <code>008037144297</code><BR>
	 * <code>00af8300cd0b</code><BR>
	 * <code>014bd91DA8FC</code>
	 * <P>
	 * 
	 * @param address - the address of the Bluetooth device as a 12 character hex string.
	 * @throws java.lang.NullPointerException - if address is null.
	 * @throws java.lang.IllegalArgumentException - if address is the address of the local device or is not a valid Bluetooth address.
	 */
	protected RemoteDevice(java.lang.String address)
	{
		//TODO implement RemoteDevice
	}

	public RemoteDevice(BluetoothDevice androidBluetoothDevice) {
		this.androidBluetoothDevice = androidBluetoothDevice;
		// TODO Auto-generated constructor stub
	}

	/**
	 * Determines if this is a trusted device according to the BCC.
	 * <P>
	 * 
	 * 
	 * @return true if the device is a trusted device, otherwise false
	 */
	public boolean isTrustedDevice()
	{
		return false;
		//TODO implement isTrustedDevice
	}

	/**
	 * Returns the name of this device. The Bluetooth
	 * specification calls this name the "Bluetooth device name" or the
	 * "user-friendly name".  This method will only contact
	 * the remote device if the name is not known or
	 * <code>alwaysAsk</code> is <code>true</code>.
	 * <P>
	 * 
	 * @param alwaysAsk - if true then the device will be contacted for its name, otherwise, if there exists a known name for this device, the name will be returned without contacting the remote device
	 * @return the name of the device, or null if the Bluetooth system does not support this feature; if the local device is able to contact the remote device, the result will never be null; if the remote device does not have a name then an empty string will be returned
	 * @throws java.io.IOException - if the remote device can not be contacted or the remote device could not provide its name.
	 */
	public java.lang.String getFriendlyName(boolean alwaysAsk) throws java.io.IOException{
		return this.androidBluetoothDevice.getName();
	}

	/**
	 * Retrieves the Bluetooth address of this device.  The Bluetooth address
	 * will be 12 characters long.  Valid characters are 0-9 and A-F.  This
	 * method will never return <code>null</code>.
	 * <P>
	 * 
	 * 
	 * @return the Bluetooth address of the remote device
	 */
	public final java.lang.String getBluetoothAddress()
	{
		String address = this.androidBluetoothDevice.getAddress();
		String result = null; 
		//#= result = address.replaceAll("\\:", ""); 
		return result; 
	}

	/**
	 * Determines if two <code>RemoteDevice</code>s are equal.  Two devices are
	 * equal if they have the same Bluetooth device address.
	 * <P>
	 * 
	 * @param obj - the object to compare to
	 * @return true if both devices have the same Bluetooth address; false if both devices do not have the same address; false if obj is null; false if obj is not a RemoteDevice
	 * @see Object#equals
	 */
	public boolean equals(java.lang.Object obj)
	{
		return false;
		//TODO implement equals
	}

	/**
	 * Computes the hash code for this object. This method will return the
	 * same value when it is called multiple times on the same object.
	 * <P>
	 * 
	 * @return the hash code for this object
	 * @see Object#hashCode
	 */
	public int hashCode()
	{
		return 0;
		//TODO implement hashCode
	}

	/**
	 * Retrieves the Bluetooth device that is at the other end of the Bluetooth
	 * Serial Port Profile connection, L2CAP connection, or OBEX over RFCOMM
	 * connection provided.  This method will never return <code>null</code>.
	 * <P>
	 * 
	 * @param conn - the Bluetooth Serial Port connection, L2CAP connection, or OBEX over RFCOMM connection whose remote Bluetooth device is needed.
	 * @return the remote device involved in the connection
	 * @throws java.lang.IllegalArgumentException - if conn is not a Bluetooth Serial Port Profile connection, L2CAP connection, or OBEX over RFCOMM connection; if conn is a L2CAPConnectionNotifier, StreamConnectionNotifier, or SessionNotifier.
	 * @throws java.io.IOException - if the connection is closed.
	 * @throws java.lang.NullPointerException - if conn is null.
	 */
	public static RemoteDevice getRemoteDevice(Connection conn) throws java.io.IOException
	{
		return null;
		//TODO implement getRemoteDevice
	}

	/**
	 * Attempts to authenticate this <code>RemoteDevice</code>.
	 * Authentication is a means of verifying the identity of a remote
	 * device. Authentication involves a device-to-device challenge and
	 * response scheme that requires a 128-bit common secret link key
	 * derived from a PIN code shared by both devices. If either side's
	 * PIN code does not match, the authentication process fails and the
	 * method returns <code>false</code>.  The method will also return
	 * <code>false</code> if authentication is incompatible with the
	 * current security settings of the local device established by the
	 * BCC, if the stack does not
	 * support authentication at all, or if the stack does not support
	 * authentication subsequent to connection establishment.
	 * 
	 * <p> If this <code>RemoteDevice</code> has previously been
	 * authenticated, then this method returns <code>true</code>
	 * without attempting to re-authenticate this
	 * <code>RemoteDevice</code>.
	 * <P>
	 * 
	 * 
	 * @return true if authentication is successful; otherwise false
	 * @throws java.io.IOException - if there are no open connections between the local device and this RemoteDevice
	 */
	public boolean authenticate() throws java.io.IOException
	{
		return false;
		//TODO implement authenticate
	}

	/**
	 * Determines if this <code>RemoteDevice</code> should be allowed
	 * to continue to access the local service provided by the
	 * <code>Connection</code>.  In Bluetooth, authorization is
	 * defined as the process of deciding if device X is allowed to
	 * access service Y.  The implementation of the
	 * <code>authorize(Connection conn)</code> method asks the
	 * Bluetooth Control Center (BCC) to decide if it is acceptable
	 * for <code>RemoteDevice</code> to continue to access a local
	 * service over the connection <code>conn</code>.  In devices with
	 * a user interface, the BCC is expected to consult with the user
	 * to obtain approval.
	 * 
	 * <p> Some Bluetooth systems may allow the user to permanently
	 * authorize a remote device for all local services. When a device
	 * is authorized in this way, it is known as a "trusted device"
	 * -- see <A HREF="RemoteDevice.html#isTrustedDevice()" tppabs="http://java.sun.com/javame/reference/apis/jsr082/javax/bluetooth/RemoteDevice.html#isTrustedDevice()"><CODE>isTrustedDevice()</CODE></A>.
	 * 
	 * <p> The <code>authorize()</code> method will also check that the
	 * identity of the <code>RemoteDevice</code> can be verified through
	 * authentication.
	 * If this <code>RemoteDevice</code> has been authorized for
	 * <code>conn</code> previously, then this method returns
	 * <code>true</code> without attempting to re-authorize this
	 * <code>RemoteDevice</code>.
	 * <P>
	 * 
	 * @param conn - the connection that this RemoteDevice is using to access a local service
	 * @return true if this RemoteDevice is successfully authenticated and authorized, otherwise false if authentication or authorization fails
	 * @throws java.lang.IllegalArgumentException - if conn is not a connection to this RemoteDevice, or if the local device initiated the connection, i.e., the local device is the client rather than the server.  This exception is also thrown if conn was created by RemoteDevice using a scheme other than btspp, btl2cap, or btgoep. This exception is thrown if conn is a notifier used by a server to wait for a client connection, since the notifier is not a connection to this RemoteDevice.
	 * @throws java.io.IOException - if conn is closed
	 * @see #isTrustedDevice()
	 */
	public boolean authorize(Connection conn) throws java.io.IOException
	{
		return false;
		//TODO implement authorize
	}

	/**
	 * Attempts to turn encryption on or off for an existing
	 * connection.  In the case where the parameter <code>on</code> is
	 * <code>true</code>, this method will first authenticate this
	 * <code>RemoteDevice</code> if it has not already been
	 * authenticated.  Then it will attempt to turn on encryption.  If
	 * the connection is already encrypted then this method
	 * returns <code>true</code>.  Otherwise, when the parameter <code>on</code>
	 * is <code>true</code>, either: <UL> <LI> the method succeeds in
	 * turning on encryption for the connection and returns
	 * <code>true</code>, or <LI> the method was unsuccessful in
	 * turning on encryption and returns <code>false</code>.  This
	 * could happen because the stack does not support encryption or
	 * because encryption conflicts with the user's security settings
	 * for the device.  </UL>
	 * 
	 * <p> In the case where the parameter <code>on</code> is
	 * <code>false</code>, there are again two possible outcomes: <UL>
	 * <LI> encryption is turned off on the connection and
	 * <code>true</code> is returned, or <LI> encryption is left on
	 * for the connection and <code>false</code> is returned.  </UL>
	 * Encryption may be left on following <code>encrypt(conn,
	 * false)</code> for a variety of reasons.  The user's current
	 * security settings for the device may require encryption or the
	 * stack may not have a mechanism to turn off encryption.  Also,
	 * the BCC may have determined that encryption will be kept on for
	 * the physical link to this <code>RemoteDevice</code>.  The
	 * details of the BCC are implementation dependent, but encryption
	 * might be left on because other connections to the same device
	 * need encryption.  (All of the connections over the same
	 * physical link must be encrypted if any of them are encrypted.)
	 * 
	 * <p> While attempting to turn encryption off may not succeed
	 * immediately because other connections need encryption on, there
	 * may be a delayed effect.  At some point, all of the connections
	 * over this physical link needing encryption could be closed or
	 * also have had the method <code>encrypt(conn, false)</code>
	 * invoked for them.  In this case, the BCC may turn off
	 * encryption for all connections over this physical link.  (The
	 * policy used by the BCC is implementation dependent.)  It is
	 * recommended that applications do <code>encrypt(conn,
	 * false)</code> once they no longer need encryption to allow the
	 * BCC to determine if it can reduce the overhead on connections
	 * to this <code>RemoteDevice</code>.
	 * 
	 * <p> The fact that <code>encrypt(conn, false)</code> may not
	 * succeed in turning off encryption has very few consequences for
	 * applications.  The stack handles encryption and decryption, so
	 * the application does not have to do anything different
	 * depending on whether the connection is still encrypted or not.
	 * <P>
	 * 
	 * @param conn - the connection whose need for encryption has changed
	 * @param on - true attempts to turn on encryption; false attempts to turn off encryption
	 * @return true if the change succeeded, otherwise false if it failed
	 * @throws java.io.IOException - if conn is closed
	 * @throws java.lang.IllegalArgumentException - if conn is not a connection to this RemoteDevice; if conn was created by the client side of the connection using a scheme other than btspp, btl2cap, or btgoep (for example, this exception will be thrown if conn was created using the file or http schemes.); if conn is a notifier used by a server to wait for a client connection, since the notifier is not a connection to this RemoteDevice
	 */
	public boolean encrypt(Connection conn, boolean on) throws java.io.IOException
	{
		return false;
		//TODO implement encrypt
	}

	/**
	 * Determines if this <code>RemoteDevice</code> has been
	 * authenticated.
	 * <P>
	 * A device may have been authenticated by this application
	 * or another application.  Authentication applies to an ACL link between
	 * devices and not on a specific L2CAP, RFCOMM, or OBEX connection.
	 * Therefore, if <code>authenticate()</code> is performed when an L2CAP
	 * connection is made to device A, then <code>isAuthenticated()</code> may
	 * return <code>true</code> when tested as part of making an RFCOMM
	 * connection to device A.
	 * <P>
	 * 
	 * 
	 * @return true if this RemoteDevice has previously been authenticated; false if it has not been authenticated or there are no open connections between the local device and this RemoteDevice
	 */
	public boolean isAuthenticated()
	{
		return false;
		//TODO implement isAuthenticated
	}

	/**
	 * Determines if this <code>RemoteDevice</code> has been
	 * authorized previously by the BCC of the local device to
	 * exchange data related to the service associated with the
	 * connection. Both clients and servers can call this method.
	 * However, for clients this method returns <code>false</code> for
	 * all legal values of the <code>conn</code> argument.
	 * <P>
	 * 
	 * @param conn - a connection that this RemoteDevice is using to access a service or provide a service
	 * @return true if conn is a server-side connection and this RemoteDevice has been authorized; false if conn is a client-side connection, or a server-side connection that has not been authorized
	 * @throws java.lang.IllegalArgumentException - if conn is not a connection to this RemoteDevice; if conn was not created using one of the schemes btspp, btl2cap, or btgoep; or if conn is a notifier used by a server to wait for a client connection, since the notifier is not a connection to this RemoteDevice.
	 * @throws java.io.IOException - if conn is closed
	 */
	public boolean isAuthorized(Connection conn) throws java.io.IOException
	{
		return false;
		//TODO implement isAuthorized
	}

	/**
	 * Determines if data exchanges with this <code>RemoteDevice</code>
	 * are currently being encrypted.
	 * <P>
	 * Encryption may have been previously turned on by this or another
	 * application.  Encryption applies to an ACL link
	 * between devices and not on a specific L2CAP, RFCOMM, or OBEX connection.
	 * Therefore, if <code>encrypt()</code> is performed with the
	 * <code>on</code> parameter set to <code>true</code> when an L2CAP
	 * connection is made to device A, then <code>isEncrypted()</code> may
	 * return <code>true</code> when tested as part of making an RFCOMM
	 * connection to device A.
	 * <P>
	 * 
	 * 
	 * @return true if data exchanges with this RemoteDevice are being encrypted; false if they are not being encrypted, or there are no open connections between the local device and this RemoteDevice
	 */
	public boolean isEncrypted()
	{
		return false;
		//TODO implement isEncrypted
	}

	public String toString() {
		return "RemoteDevice.Name:"+this.androidBluetoothDevice.getName()+".Address:"+getBluetoothAddress();
	}
}
