//#condition polish.android
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Wed Jan 21 21:07:47 CET 2009
package de.enough.polish.android.media.control;

import de.enough.polish.android.media.Control;
import de.enough.polish.android.media.MediaException;

/**
 * 
 * <code>RecordControl</code> controls the recording of media
 * from a <code>Player</code>.  <code>RecordControl</code> records
 * what's currently being played by the <code>Player</code>.
 * <p>
 * <h2>Example</h2>
 * <blockquote>
 * <pre>
 * try {
 * // Create a Player that captures live audio.
 * Player p = Manager.createPlayer("capture://audio");
 * p.realize();
 * // Get the RecordControl, set the record stream,
 * // start the Player and record for 5 seconds.
 * RecordControl rc = (RecordControl)p.getControl("RecordControl");
 * ByteArrayOutputStream output = new ByteArrayOutputStream();
 * rc.setRecordStream(output);
 * rc.startRecord();
 * p.start();
 * Thread.currentThread().sleep(5000);
 * rc.commit();
 * p.close();
 * } catch (IOException ioe) {
 * } catch (MediaException me) {
 * } catch (InterruptedException ie) { }
 * </pre>
 * </blockquote>
 */
public interface RecordControl extends Control
{
	/**
	 * Set the output stream where the data will be
	 * recorded.
	 * <p>
	 * Whenever possible, the recording format is the same as the format
	 * of the input media.  In some cases, the recording format may be
	 * different from the input format if the input format is not a
	 * recordable format, e.g. streaming media data.  An application
	 * can query the recorded format by calling the
	 * <code>getContentType</code> method.
	 * <P>
	 * 
	 * @param stream - The output stream where the data will be recorded.
	 * @throws java.lang.IllegalStateException - Thrown if one of the following conditions is true:   startRecord has been called and commit has not been called.  setRecordLocation has been called and commit has not been called.
	 * @throws java.lang.IllegalArgumentException - Thrown if stream is null.
	 * @throws java.lang.SecurityException - Thrown if the caller does not have security permission to set the record stream.
	 */
	void setRecordStream(java.io.OutputStream stream);

	/**
	 * Set the output location where the data will be recorded.
	 * <p>
	 * Whenever possible, the recording format is the same as the format
	 * of the input media.  In some cases, the recording format may be
	 * different from the input format if the input format is not a
	 * recordable format, e.g. streaming media data.  An application
	 * can query the recorded format by calling the
	 * <code>getContentType</code> method.
	 * <P>
	 * 
	 * @param locator - The locator specifying where the recorded media will be saved.  The locator must be specified as a URL.
	 * @throws java.lang.IllegalStateException - Thrown if one of the following conditions is true:   startRecord has been called and commit has not been called.  setRecordStream has been called and commit has not been called.
	 * @throws java.lang.IllegalArgumentException - Thrown if locator is null.
	 * @throws java.io.IOException - Thrown if protocol is valid but the media cannot be created at the specified location.
	 * @throws MediaException - Thrown if the locator is not in URL syntax or it specifies a protocol that is not supported.
	 * @throws java.lang.SecurityException - Thrown if the caller does not have security permission to set the record location.
	 */
	void setRecordLocation(java.lang.String locator) throws java.io.IOException, MediaException;

	/**
	 * Return the content type of the recorded media.
	 * 
	 * The content type is given in the
	 * <a HREF="../Manager.html#content-type">content type syntax</a>.
	 * <P>
	 * 
	 * 
	 * @return The content type of the media.
	 */
	java.lang.String getContentType();

	/**
	 * Start recording the media.
	 * <p>
	 * If the <code>Player</code> is already started, <code>startRecord</code>
	 * will immediately start the recording.  If the <code>Player</code>
	 * is not already started, <code>startRecord</code> will not
	 * record any media.  It will put the recording in a "standby" mode.
	 * As soon as the <code>Player</code> is started,
	 * the recording will start right away.
	 * <p>
	 * If <code>startRecord</code> is called when the recording has
	 * already started, it will be ignored.
	 * <p>
	 * When <code>startRecord</code> returns, the recording has started
	 * and a <i>RECORD_STARTED</i> event will be delivered through the
	 * <code>PlayerListener</code>.
	 * <p>
	 * If an error occurs while recording is in progress,
	 * <i>RECORD_ERROR</i> event will be delivered via the PlayerListener.
	 * <P>
	 * 
	 * 
	 * @throws java.lang.IllegalStateException - Thrown if any of the following conditions is true:   if setRecordLocation or setRecordStream has not been called for the first time.  If commit has been called and setRecordLocation or setRecordStream has not been called.
	 */
	void startRecord();

	/**
	 * Stop recording the media.  <code>stopRecord</code> will not
	 * automatically stop the <code>Player</code>.  It only stops
	 * the recording.
	 * <p>
	 * Stopping the <code>Player</code> does not imply
	 * a <code>stopRecord</code>.  Rather, the recording
	 * will be put into a "standby" mode.  Once the <code>Player</code>
	 * is re-started, the recording will resume automatically.
	 * <p>
	 * After <code>stopRecord</code>, <code>startRecord</code> can
	 * be called to resume the recording.
	 * <p>
	 * If <code>stopRecord</code> is called when the recording has
	 * already stopped, it will be ignored.
	 * <p>
	 * When <code>stopRecord</code> returns, the recording has stopped
	 * and a <i>RECORD_STOPPED</i> event will be delivered through the
	 * <code>PlayerListener</code>.
	 * <P>
	 * 
	 */
	void stopRecord();

	/**
	 * Complete the current recording.
	 * <p>
	 * If the recording is in progress, <code>commit</code>
	 * will implicitly call <code>stopRecord</code>.
	 * <p>
	 * To record again after <code>commit</code> has been called,
	 * <code>setRecordLocation</code> or <code>setRecordStream</code>
	 * must be called.
	 * <P>
	 * 
	 * 
	 * @throws java.io.IOException - Thrown if an I/O error occurs during commit. The current recording is not valid. To record again, setRecordLocation or setRecordStream must be called.
	 */
	void commit() throws java.io.IOException;

	/**
	 * Set the record size limit.  This limits the size of the
	 * recorded media to the number of bytes specified.
	 * <p>
	 * When recording is in progress, <code>commit</code> will be
	 * called implicitly in the following cases:
	 * <ul>
	 * <li>
	 * Record size limit is reached
	 * <li>
	 * If the requested size is less than the already recorded size
	 * <li>
	 * No more space is available.
	 * </ul>
	 * <p>
	 * Once a record size limit has been set, it will remain so
	 * for future recordings until it is changed by another
	 * <code>setRecordSizeLimit</code> call.
	 * <p>
	 * To remove the record size limit, set it to
	 * <code>Integer.MAX_VALUE</code>.
	 * By default, the record size limit is not set.
	 * <p>
	 * Only positive values can be set.  Zero or negative values
	 * are invalid and an <code>IllegalArgumentException</code>
	 * will be thrown.
	 * <P>
	 * 
	 * @param size - The record size limit in number of bytes.
	 * @return The actual size limit set.
	 * @throws java.lang.IllegalArgumentException - Thrown if the given size is invalid.
	 * @throws MediaException - Thrown if setting the record size limit is not supported.
	 */
	int setRecordSizeLimit(int size) throws MediaException;

	/**
	 * Erase the current recording.
	 * <p>
	 * If the recording is in progress, <code>reset</code>
	 * will implicitly call <code>stopRecord</code>.
	 * <p>
	 * Calling <code>reset</code> after <code>commit</code>
	 * will have no effect on the current recording.
	 * <p>
	 * If the <code>Player</code> that is associated with this
	 * <code>RecordControl</code> is closed, <code>reset</code>
	 * will be called implicitly.
	 * <P>
	 * 
	 * 
	 * @throws java.io.IOException - Thrown if the current recording cannot be erased. The current recording is not valid. To record again, setRecordLocation or setRecordStream must be called.
	 */
	void reset() throws java.io.IOException;

}
