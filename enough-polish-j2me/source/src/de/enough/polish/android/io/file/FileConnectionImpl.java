//#condition polish.android

// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Wed Jan 21 22:12:19 CET 2009

package de.enough.polish.android.io.file;


import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.util.Enumeration;
import java.util.Vector;

import android.os.StatFs;

public class FileConnectionImpl 
implements FileConnection
{
    File connectionFile;  
    String url;

    DataInputStream dis;
    DataOutputStream dos;
    
    InputStream is;
    OutputStream os;

    
    public FileConnectionImpl(String url, int mode) 
    {
        this.url = url;
        String fileName = url.substring("file://".length());
        System.out.println("opening file " + fileName);
        if ("//".equals(fileName)) {
        	fileName = "/";
        }
        this.connectionFile = new File(fileName);        
    }

    public long availableSize()
    {
        StatFs statFs=new StatFs(getPath());
        return (statFs.getAvailableBlocks()*statFs.getBlockSize());
    }

    public boolean canRead()
    {                
        return this.connectionFile.canRead();
    }

    public boolean canWrite()
    {        
        return this.connectionFile.canWrite();
    }

    public void create() throws IOException
    {
    	this.connectionFile.createNewFile();        
    }

    public void delete() throws IOException
    {
    	this.connectionFile.delete();        
    }

    public long directorySize(boolean includeSubDirs) throws IOException
    {
    	if (!this.connectionFile.isDirectory()) {
    		throw new IOException(this.connectionFile.getAbsolutePath() + " is not a directory");
    	}
    	return directorySizeImpl(this.connectionFile, includeSubDirs);
    }
    
    private long directorySizeImpl(File rootDir, boolean includeSubDirs) throws IOException
    {
    	long size = 0;
        File[] files = rootDir.listFiles();
        if (files != null) {
        	for (int i = 0; i < files.length; i++) {
				File file = files[i];
				if (file.isDirectory()) {
					if (includeSubDirs) {
						size += directorySizeImpl(file, includeSubDirs);
					}
				} else {
					size += file.length();
				}
			}
        }
        return size;
    }


    public boolean exists()
    {
        return this.connectionFile.exists();
    }

    public long fileSize() throws IOException
    {        
        return this.connectionFile.length();
    }

    public String getName()
    {
        String name = this.connectionFile.getName();
        int lastSlashIndex = name.lastIndexOf('/');
        if(lastSlashIndex == -1) {
            return name;
        }
        name = name.substring(lastSlashIndex);
        return name;
    }

    public String getPath()
    {   
        String path = this.connectionFile.getPath();
        int lastSlashIndex = path.lastIndexOf('/');
        if (lastSlashIndex == -1) {
            return path;
        }
        path = path.substring( 0, lastSlashIndex );
        return path;
    }

    public String getURL()
    {
        return this.url;
    }

    public boolean isDirectory()
    {     
        return this.connectionFile.isDirectory();
    }

    public boolean isHidden()
    {
        return this.connectionFile.isHidden();
    }

    public boolean isOpen()
    {
        if(this.dis!=null||this.dos!=null||this.is!=null||this.os!=null)
            return true;
        else
            return false;
    }

    public long lastModified()
    {
        return this.connectionFile.lastModified();
    }

    public Enumeration list() throws IOException
    {
    	File[] files = this.connectionFile.listFiles();
    	if (files == null) {
    		// file does not exist or is not a directory:
    		throw new IOException( connectionFile.getAbsolutePath() + " does not exist or is not a directory.");
    	}
        Vector<String> vector = new Vector<String>(files.length);
        for (int i = 0; i < files.length; i++) {
        	File childFile = files[i];
        	if (childFile.isDirectory() || childFile.isHidden()) {
        		continue;
        	}
			vector.addElement(childFile.getName());
		}
        return vector.elements();
    }

    public Enumeration list(String filterString, boolean includeHidden) throws IOException
    {
    	SimpleFileNameFilter filter = null;
    	if ((filterString != null) && !("*".equals(filterString)) && !("".equals(filterString))) {
    		filter = new SimpleFileNameFilter(filterString);
    	}
    	
    	File[] files = this.connectionFile.listFiles();
    	if (files == null) {
    		// file does not exist or is not a directory:
    		throw new IOException( connectionFile.getAbsolutePath() + " does not exist or is not a directory.");
    	}
        Vector<String> vector = new Vector<String>(files.length);
        for (int i = 0; i < files.length; i++) {
        	File childFile = files[i];
        	if (!includeHidden && childFile.isHidden()) {
        		continue;
        	}
        	if ((filter == null) || (filter.matches(childFile))) {
    			String fileName = childFile.getName();
    			if (childFile.isDirectory()) {
    				fileName += "/";
    			}
				vector.addElement(fileName);
        	}
		}
        return vector.elements();
    }

    public void mkdir() throws IOException
    {
    	this.connectionFile.mkdir();        
    }

    public DataInputStream openDataInputStream() throws IOException
    {
        this.dis=new DataInputStream(openInputStream());
        return this.dis;
    }

    public DataOutputStream openDataOutputStream() throws IOException
    {
        this.dos=new DataOutputStream(openOutputStream());
        return this.dos;
    }

    public InputStream openInputStream() throws IOException
    {
        this.is=new FileInputStream(this.connectionFile);
        return this.is;
    }

    public OutputStream openOutputStream() throws IOException
    {
        this.os=new FileOutputStream(this.connectionFile);
        return this.os;
    }

    public OutputStream openOutputStream(long byteOffset) throws IOException
    {
    	RandomAccessFile raf = new RandomAccessFile(this.connectionFile, "rw");
    	raf.seek(byteOffset);
    	this.os = new RandomAccessFileOutputStream(raf);
        return this.os;
    }

    public void rename(String newName) throws IOException
    {
        File newFile=new File(getPath(), newName);        
        this.connectionFile.renameTo(newFile);                
    }

    public void setFileConnection(String fileName) throws IOException
    {
    	if (!this.connectionFile.isDirectory()) {
			throw new IOException("not a directory: " + this.connectionFile.getAbsolutePath());    		
    	}
    	if ("..".equals(fileName)) {
    		File parentFile = this.connectionFile.getParentFile();
    		if (parentFile == null) {
    			throw new IOException("cannot enter parent directory of " + this.connectionFile.getAbsolutePath());
    		}
    		this.connectionFile = parentFile;
    	} else {
    		File nextFile = new File( this.connectionFile, fileName);
    		if (!nextFile.exists()) {
    			throw new IllegalArgumentException(nextFile.getAbsolutePath() + " does not exist");
    		}
    		this.connectionFile = nextFile;
    	}
        
    }

    public void setHidden(boolean hidden) throws IOException
    {
        // can be ignored on Unix systems, instead a rename operation should be used
        
    }

    public void setReadable(boolean readable) throws IOException
    {
    	this.connectionFile.setReadable(readable);        
    }

    public void setWritable(boolean writable) throws IOException
    {
    	this.connectionFile.setWritable(writable);
    }

    public long totalSize()
    {
    	return this.connectionFile.getTotalSpace();
    }

    public void truncate(long byteOffset) throws IOException
    {
//    	// flush any streams:
//    	try {
//	    	if (this.dos != null) {
//	    		this.dos.flush();
//	    	}
//	    	if (this.os != null) {
//	    		this.os.flush();
//	    	}
//    	} catch (Exception e) {
//    		//#debug error
//    		System.out.println("Unable to flush in FileConnection.truncate()" + e);
//    	}
//    	if (byteOffset >= this.connectionFile.length()) {
//    		// cannot truncate after the file's end:
//    		return;
//    	}
//    	if (byteOffset <= 0) {
//    		throw new IllegalArgumentException("for byteOffset " + byteOffset );
//    	}
    	// Problem here is that we probably should conserve any streams, which in turn requires that we wrap our streams used here
    	// This makes it somewhat more difficult to implement. As this method is deemed to be used only seldomly, we ignore it for now. 
    	throw new IllegalStateException("not implemented");        
        // TODO Auto-generated method stub
        
    }

    public long usedSize()
    {
    	return this.connectionFile.getTotalSpace() - this.connectionFile.getFreeSpace();
    }

    public void close() throws IOException
    {
        if (this.dos!=null)
        {    
            this.dos.close();
            this.dos = null;
        }
        if (this.dis!=null)
        {    
            this.dis.close();
            this.dis=null;
        }
        if (this.os!=null)
        {    
            this.os.close();           
            this.os=null;
        }
        if (this.is!=null)
        {    
            this.is.close();           
            this.is=null;
        }
    }

    private static class SimpleFileNameFilter {
    	private boolean hasAsteriskAtStart;
    	private boolean hasAsteriskAtEnd;
    	private String matchString;
    	public SimpleFileNameFilter(String filterString) {
    		// filter - String against which all files and directories are matched for retrieval. An asterisk ("*") can be used as a wildcard to represent 0 or more occurrences of any character.
    		this.hasAsteriskAtStart = (	filterString.charAt(0) == '*'); 
    		if (this.hasAsteriskAtStart) {
    			filterString = filterString.substring(1);
    		}
    		this.hasAsteriskAtEnd = (filterString.charAt(filterString.length()-1) == '*');
    		if (this.hasAsteriskAtEnd) {
    			filterString = filterString.substring(0, filterString.length()-1);
    		}
    		this.matchString = filterString;
    	}
		public boolean matches(File file) {
			String fileName = file.getName();
			int pos = fileName.indexOf(this.matchString);
			if (pos == -1) {
				return false;
			}
			if (this.hasAsteriskAtStart && this.hasAsteriskAtEnd) {
				return true;
			}
			if (this.hasAsteriskAtEnd && (pos == 0)) {
				return true;
			}
			if (this.hasAsteriskAtStart && (pos == (fileName.length() - this.matchString.length()))) {
				return true;
			}
			return false;
		}
    }

}
