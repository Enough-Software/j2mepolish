/*
 * Created on May 30, 2008 at 2:26:06 PM.
 * 
 * Copyright (c) 2007 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.obfuscate;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;


/**
 * <p>Allows to easily digest obfuscation maps generated by ProGuard</p>
 *
 * <p>Copyright Enough Software 2008</p>
 * @author Robert Virkus, j2mepolish@enough.de
 */
public class ProGuardObfuscationMap
{
	private final Map classEntriesByName;

	public ProGuardObfuscationMap( File file ) throws IOException {
		this( new FileInputStream( file ));
	}

	public ProGuardObfuscationMap( InputStream in ) throws IOException {
		this.classEntriesByName = new HashMap();
		read( in );
	}

	



	/**
	 * @param file
	 */
	public void read(File file) throws IOException 
	{
		read( new FileInputStream( file ) );
	}
	
	/**
	 * @param in
	 */
	public void read(InputStream in) throws IOException
	{
		BufferedReader reader = new BufferedReader( new InputStreamReader(in) );
		String line;
		while ( (line = reader.readLine()) != null ) {
			parseLine( line );
		}
		reader.close();
		in.close();
	}
	
	private void parseLine(String line)
	{
		//System.out.println("parsing line " + line);
		int splitPos = line.indexOf("->");
		if (splitPos == -1) {
			return;
		}
		String original = line.substring(0, splitPos ).trim();
		String obfuscated = line.substring(splitPos + "->".length() );
		if(isClass(line))
		{
			addClass( original, obfuscated.substring(0, obfuscated.length() - 1) );
		}
//		else if(isMethod(line))
//		{
//		}
//		else if(isField(line))
//		{
//		}
	}
	

	/**
	 * @param original
	 * @param obfuscated
	 */
	private void addClass(String original, String obfuscated)
	{
		this.classEntriesByName.put( original, obfuscated);
	}

	private boolean isClass(String line)
	{
		return line.indexOf(":") != -1 && line.indexOf("->") != -1;
	}
	
//	private boolean isField(String line)
//	{
//		String name = line.split("->")[0].trim();
//		return name.indexOf(" ") != -1 && name.indexOf("(") == -1;
//	}
	
//	private boolean isMethod(String line)
//	{
//		String name = line.split("->")[0].trim();
//		return name.indexOf(" ") != -1 && name.indexOf("(") != -1;
//	}
	
	public String[] getClassNames() {
		return (String[]) this.classEntriesByName.keySet().toArray( new String[ this.classEntriesByName.size() ] );
	}
	
	public String getObfuscatedClassNameFor( String className ) {
		return (String) this.classEntriesByName.get(className);
	}

}
